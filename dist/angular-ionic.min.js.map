{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/angular-ionic.min.js","webpack:///webpack/bootstrap f7d57e32578d658fa0df","webpack:///./entry.js","webpack:///./~/ionic-sdk/js/angular/service/decorators/angular-ios9-uiwebview.patch.js","webpack:///./~/ionic-sdk/js/angular/main.js","webpack:///./~/ionic-sdk/js/angular/service/decorators/compile.js","webpack:///./~/ionic-sdk/js/angular/service/decorators/location.js","webpack:///./~/ionic-sdk/js/angular/service/actionSheet.js","webpack:///./~/ionic-sdk/js/angular/service/angularOverrides.js","webpack:///./~/ionic-sdk/js/angular/service/backdrop.js","webpack:///./~/ionic-sdk/js/angular/service/bind.js","webpack:///./~/ionic-sdk/js/angular/service/body.js","webpack:///./~/ionic-sdk/js/angular/service/clickBlock.js","webpack:///./~/ionic-sdk/js/angular/service/gesture.js","webpack:///./~/ionic-sdk/js/angular/service/history.js","webpack:///./~/ionic-sdk/js/angular/service/ionicConfig.js","webpack:///./~/ionic-sdk/js/angular/service/loading.js","webpack:///./~/ionic-sdk/js/angular/service/modal.js","webpack:///./~/ionic-sdk/js/angular/service/navBarDelegate.js","webpack:///./~/ionic-sdk/js/angular/service/navViewDelegate.js","webpack:///./~/ionic-sdk/js/angular/service/platform.js","webpack:///./~/ionic-sdk/js/angular/service/popover.js","webpack:///./~/ionic-sdk/js/angular/service/popup.js","webpack:///./~/ionic-sdk/js/angular/service/position.js","webpack:///./~/ionic-sdk/js/angular/service/scrollDelegate.js","webpack:///./~/ionic-sdk/js/angular/service/sideMenuDelegate.js","webpack:///./~/ionic-sdk/js/angular/service/slideBoxDelegate.js","webpack:///./~/ionic-sdk/js/angular/service/tabsDelegate.js","webpack:///./~/ionic-sdk/js/angular/service/templateCache.js","webpack:///./~/ionic-sdk/js/angular/service/templateLoader.js","webpack:///./~/ionic-sdk/js/angular/service/viewService.js","webpack:///./~/ionic-sdk/js/angular/service/viewSwitcher.js","webpack:///./~/ionic-sdk/js/angular/controller/headerBarController.js","webpack:///./~/ionic-sdk/js/angular/controller/infiniteScrollController.js","webpack:///./~/ionic-sdk/js/angular/controller/listController.js","webpack:///./~/ionic-sdk/js/angular/controller/navBarController.js","webpack:///./~/ionic-sdk/js/angular/controller/navViewController.js","webpack:///./~/ionic-sdk/js/angular/controller/refresherController.js","webpack:///./~/ionic-sdk/js/angular/controller/scrollController.js","webpack:///./~/ionic-sdk/js/angular/controller/sideMenuController.js","webpack:///./~/ionic-sdk/js/angular/controller/spinnerController.js","webpack:///./~/ionic-sdk/js/angular/controller/tabController.js","webpack:///./~/ionic-sdk/js/angular/controller/tabsController.js","webpack:///./~/ionic-sdk/js/angular/controller/viewController.js","webpack:///./~/ionic-sdk/js/angular/directive/actionSheet.js","webpack:///./~/ionic-sdk/js/angular/directive/checkbox.js","webpack:///./~/ionic-sdk/js/angular/directive/collectionRepeat.js","webpack:///./~/ionic-sdk/js/angular/directive/content.js","webpack:///./~/ionic-sdk/js/angular/directive/exposeAsideWhen.js","webpack:///./~/ionic-sdk/js/angular/directive/gesture.js","webpack:///./~/ionic-sdk/js/angular/directive/headerFooterBar.js","webpack:///./~/ionic-sdk/js/angular/directive/infiniteScroll.js","webpack:///./~/ionic-sdk/js/angular/directive/input.js","webpack:///./~/ionic-sdk/js/angular/directive/itemDeleteButton.js","webpack:///./~/ionic-sdk/js/angular/directive/itemFloatingLabel.js","webpack:///./~/ionic-sdk/js/angular/directive/item.js","webpack:///./~/ionic-sdk/js/angular/directive/itemOptionButton.js","webpack:///./~/ionic-sdk/js/angular/directive/itemReorderButton.js","webpack:///./~/ionic-sdk/js/angular/directive/keyboardAttach.js","webpack:///./~/ionic-sdk/js/angular/directive/list.js","webpack:///./~/ionic-sdk/js/angular/directive/menuClose.js","webpack:///./~/ionic-sdk/js/angular/directive/menuToggle.js","webpack:///./~/ionic-sdk/js/angular/directive/modal.js","webpack:///./~/ionic-sdk/js/angular/directive/modalView.js","webpack:///./~/ionic-sdk/js/angular/directive/navBackButton.js","webpack:///./~/ionic-sdk/js/angular/directive/navBar.js","webpack:///./~/ionic-sdk/js/angular/directive/navButtons.js","webpack:///./~/ionic-sdk/js/angular/directive/navDirection.js","webpack:///./~/ionic-sdk/js/angular/directive/navTitle.js","webpack:///./~/ionic-sdk/js/angular/directive/navTransition.js","webpack:///./~/ionic-sdk/js/angular/directive/navView.js","webpack:///./~/ionic-sdk/js/angular/directive/ngClick.js","webpack:///./~/ionic-sdk/js/angular/directive/pane.js","webpack:///./~/ionic-sdk/js/angular/directive/popover.js","webpack:///./~/ionic-sdk/js/angular/directive/popoverView.js","webpack:///./~/ionic-sdk/js/angular/directive/radio.js","webpack:///./~/ionic-sdk/js/angular/directive/refresher.js","webpack:///./~/ionic-sdk/js/angular/directive/scroll.js","webpack:///./~/ionic-sdk/js/angular/directive/sideMenuContent.js","webpack:///./~/ionic-sdk/js/angular/directive/sideMenu.js","webpack:///./~/ionic-sdk/js/angular/directive/sideMenus.js","webpack:///./~/ionic-sdk/js/angular/directive/slideBox.js","webpack:///./~/ionic-sdk/js/angular/directive/slides.js","webpack:///./~/ionic-sdk/js/angular/directive/spinner.js","webpack:///./~/ionic-sdk/js/angular/directive/tab.js","webpack:///./~/ionic-sdk/js/angular/directive/tabNav.js","webpack:///./~/ionic-sdk/js/angular/directive/tabs.js","webpack:///./~/ionic-sdk/js/angular/directive/title.js","webpack:///./~/ionic-sdk/js/angular/directive/toggle.js","webpack:///./~/ionic-sdk/js/angular/directive/view.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","angular","config","$provide","decorator","$delegate","$window","isIOS9UIWebView","userAgent","test","applyIOS9Shim","browser","clearPendingLocationUrl","pendingLocationUrl","originalUrlFn","url","arguments","length","apply","window","addEventListener","navigator","extend","forEach","isDefined","isNumber","isString","element","noop","IonicModule","$compile","$$addScopeInfo","$element","scope","isolated","noTemplate","dataName","data","$LocationDecorator","$location","$timeout","__hash","hash","value","scroll","document","querySelector","scrollTop","$rootScope","$animate","$ionicTemplateLoader","$ionicPlatform","$ionicBody","IONIC_BACK_PRIORITY","actionSheet","opts","textForIcon","text","$actionSheetHasIcon","$new","cancel","destructiveButtonClicked","buttonClicked","$deregisterBackButton","buttons","cancelOnStateChange","x","cancelText","destructiveText","sheetEl","jqLite","stateChangeListenDone","$on","removeSheet","done","removed","removeClass","then","$destroy","remove","$scope","showSheet","append","addClass","registerBackButtonAction","index","show","prototype","cssClasses","y","cssClass","el","splitClasses","existingClasses","setAttribute","indexOf","classList","add","getAttribute","replace","split","trim","$document","$$rAF","retain","backdropHolds","$broadcast","release","Math","max","getElement","body","appendChild","_element","$parse","$interpolate","LOCAL_REGEXP","attrs","bindDefinition","definition","scopeName","parentGet","unwatch","match","attrName","mode","$observe","$watch","RegExp","Error","locals","enableClass","shouldEnableClass","args","Array","slice","ele","get","preventClick","ev","preventDefault","stopPropagation","addClickBlock","pendingShow","cbEle","CSS_HIDE","createElement","className","removeClickBlock","fallbackTimer","autoExpire","hide","on","eventType","cb","options","ionic","onGesture","off","gesture","offGesture","$state","$ionicViewSwitcher","$ionicNavViewDelegate","getViewById","viewId","viewHistory","views","getBackView","view","backViewId","getForwardView","forwardViewId","getHistoryById","historyId","histories","getHistory","histObj","getParentHistoryObj","parentHistoryId","$parent","stack","cursor","parentScope","hasOwnProperty","$historyId","setNavViews","currentView","backView","forwardView","getCurrentStateId","current","name","params","key","Utils","nextUid","getCurrentStateParams","rtn","isAbstractTag","tagName","canSwipeBack","viewLocals","$$state","self","attr","lastStateId","nextViewOptions","deregisterStateChangeListener","nextViewExpireTimer","forcedNav","ACTION_INITIAL_VIEW","ACTION_NEW_VIEW","ACTION_MOVE_BACK","ACTION_MOVE_FORWARD","DIRECTION_BACK","DIRECTION_FORWARD","DIRECTION_ENTER","DIRECTION_EXIT","DIRECTION_SWAP","DIRECTION_NONE","stateChangeCounter","View","initialize","go","stateName","stateParams","history","destroy","register","tmp","currentStateId","hist","action","direction","stateId","switchToView","createViewEle","isAbstractEle","console","log","stackItem","splice","createView","currentStateName","push","disableAnimate","disableBack","historyRoot","enableBack","enabledBack","isHistoryRoot","registerHistory","newView","currentHistoryId","currentTitle","val","title","backTitle","isCurrentStateNavView","navView","goToHistoryRoot","goBack","backCount","currentHistory","newCursor","clearStateIds","fwdView","clearCache","clearHistory","stateIds","_instances","instance","expire","children","isActiveScope","foundHistoryId","climbScope","$$disconnected","$activeHistoryId","run","$ionicHistory","onHardwareBackButton","e","Platform","exitApp","keyboard","uiSref","href","$ionicGoBack","provider","setPlatformConfig","platformName","platformConfigs","configProperties","platform","addConfig","createConfig","configObj","platformObj","n","PLATFORM","isObject","providerObj","platformPath","namespace","newValue","platformConfig","stringObj","obj","str","i","maxCache","forwardCache","transition","swipeBackEnabled","swipeBackHitWidth","navBar","alignTitle","positionPrimaryButtons","positionSecondaryButtons","backButton","icon","previousTitleText","form","checkbox","toggle","scrolling","jsScrolling","spinner","tabs","style","position","templates","maxPrefetch","transitions","ios","enteringEle","leavingEle","shouldAnimate","setStyles","opacity","boxShadowOpacity","css","CSS","TRANSITION_DURATION","d","boxShadow","TRANSFORM","DomUtil","cachedStyles","step","enteringHeaderBar","leavingHeaderBar","ctrl","titleX","backTextX","setCss","enter","ctrlA","ctrlB","titleTextX","titleWidth","backButtonTextLeft","leave","titleLeftRight","enteringHeaderCtrl","controller","leavingHeaderCtrl","android","none","$get","$compileProvider","aHrefSanitizationWhitelist","imgSrcSanitizationWhitelist","LOADING_TPL","LOADING_HIDE_DEPRECATED","LOADING_SHOW_DEPRECATED","LOADING_SET_DEPRECATED","constant","template","$ionicLoadingConfig","$ionicBackdrop","$q","$log","getLoader","loaderInstance","compile","appendTo","templatePromise","templateUrl","load","when","content","isShown","hasBackdrop","noBackdrop","showBackdrop","duration","durationTimeout","bind","deregisterBackAction","loading","html","contents","requestAnimationFrame","showLoader","delay","showDelay","deregisterStateListener1","deregisterStateListener2","hideOnStateChange","hideLoader","loadingShowDelay","loader","error","setContent","_getLoader","$$q","$ionicClickBlock","ModalView","Modal","inherit","animation","target","$$destroyed","viewType","modalEl","_isShown","parentElement","scrollCtrl","resize","positionView","_onWindowResize","_deregisterBackButton","hardwareBackButtonClose","modal","trigger","$el","isInScroll","getParentOrSelfWithClass","backdropClickToClose","isHighest","hideDelay","createModal","templateString","$hasHeader","$hasSubheader","$hasFooter","$hasSubfooter","$hasTabs","$hasTabsTop","modalStack","fromTemplate","fromTemplateUrl","_","isFunction","service","DelegateService","sideMenu","popup","$ionicScrollDelegate","ready","offHardwareBackButton","fn","removeEventListener","$backButtonActions","priority","actionId","_hasBackButtonHandler","hardwareBackButtonClick","priorityAction","is","type","q","defer","resolve","promise","$ionicModal","$ionicPosition","popoverEle","targetEle","buttonOffset","offset","popoverWidth","prop","popoverHeight","bodyWidth","innerWidth","bodyHeight","innerHeight","popoverCSS","left","width","arrowEle","POPOVER_BODY_PADDING","top","height","marginLeft","POPOVER_OPTIONS","POPUP_TPL","createPopup","responseDeferred","subTitle","$buttonTapped","button","event","result","onTap","originalEvent","defaultPrevented","popupBody","focusInput","callback","last","popupStack","showPopup","doShow","$ionicPopup","_backButtonActionDone","_createPopup","stackPushDelay","close","notify","focusOn","focus","showAlert","okText","okType","showConfirm","cancelType","showPrompt","fieldtype","inputType","response","defaultText","placeholder","inputPlaceholder","maxlength","maxLength","parseInt","alert","confirm","prompt","_popupStack","getStyle","cssprop","currentStyle","getComputedStyle","isStaticPositioned","parentOffsetEl","docDomEl","offsetParent","elBCR","offsetParentBCR","offsetParentEl","clientTop","clientLeft","scrollLeft","boundingClientRect","getBoundingClientRect","pageYOffset","documentElement","pageXOffset","templatesToCache","$http","$templateCache","$ionicTemplateCache","toCache","hasRun","_runCount","pop","cache","$stateProvider","$ionicConfigProvider","stateProviderState","state","enabled","prefetchTemplate","$controller","fetchTemplate","loadAndCompile","warn","oldMethod","newMethod","methodsMap","getCurrentView","getCurrentStateName","$ionicConfig","$ionicNavBarDelegate","getViewElementIdentifier","viewState","getTransitionData","viewTransition","nextTransition","cachedAttr","navBarTransition","nextDirection","viewDirection","getViewData","navViewAttr","NAV_VIEW_ATTR","destroyViewEle","viewScope","$emit","DATA_VIEW","TRANSITIONEND_EVENT","DATA_NO_CACHE","DATA_DESTROY_ELE","DATA_ELE_IDENTIFIER","DATA_VIEW_ACCESSED","DATA_FALLBACK_TIMER","VIEW_STATUS_ACTIVE","VIEW_STATUS_CACHED","VIEW_STATUS_STAGED","transitionCounter","isActive","isActiveTimer","transitionPromises","defaultTimeout","ionicViewSwitcher","create","navViewCtrl","enteringView","leavingView","renderStart","renderEnd","alreadyInDom","transitionId","switcher","init","registerData","isTransitioning","loadViewElements","render","l","viewEle","viewElements","getViewElements","enteringEleIdentifier","navViewActiveEleId","activeEleId","eq","reconnectScope","enteringData","transitionFn","appendViewElement","Date","now","allowAnimate","onReflow","triggerTransitionStart","transitionComplete","completeOnTransitionEnd","deferred","all","transitionEnd","emit","leavingData","cleanup","triggerTransitionEnd","cancelOnTransitionEnd","cancelTransition","fromCache","parent","enteringScope","leavingScope","transData","viewElement","removableEle","viewElementsLength","removeOldestAccess","oldestAccess","navViewCtrls","containerEle","$template","innerHTML","viewEleIsActive","isActiveAttr","$attrs","getEle","eleCache","TITLE","BACK_TEXT","BACK_BUTTON","DEFAULT_TITLE","PREVIOUS_TITLE","HIDE","titleText","titleLeft","titleRight","titleCss","isBackEnabled","isBackShown","isNavBackShown","isBackElementShown","titleTextWidth","beforeEnter","viewData","newTitleText","shouldEnable","disableReset","updateBackButton","showBack","shouldShow","showNavBack","backButtonIcon","backButtonText","textContent","bounds","getTextBounds","min","offsetWidth","offsetLeft","resetBackButton","previousTitleEle","newPreviousTitleText","defaultTitleEle","align","textAlign","titleEle","widths","calcWidths","previousTitleWidths","availableTitleWidth","updatePositions","buttonsLeft","buttonsRight","showPrevTitle","isPreviousTitle","z","b","childSize","isCountRightOfTitle","backBtnEle","childNodes","updateTitleLeft","updateTitleRight","updateCss","backButtonWidth","nodeType","contains","nodeValue","margin","showPreviousTitle","right","prevTitle","defaultTitle","scrollWidth","minRight","testRight","elementClassname","onInfinite","isLoading","$apply","finishInfiniteScroll","scrollView","__container","offsetHeight","checkBounds","checkInfiniteBounds","maxScroll","getJSMaxScroll","scrollValues","getValues","getNativeMaxScroll","scrollEl","clientWidth","clientHeight","calculateMaxValue","maximum","distance","isPercent","parseFloat","throttle","maxValues","getScrollMax","scrollingX","scrollingY","scrollHeight","computedStyle","overflowX","overflowY","__finishInfiniteScroll","$ionicListDelegate","isSwipeable","isReorderShown","isDeleteShown","deregisterInstance","_registerInstance","delegateHandle","showReorder","showDelete","canSwipeItems","can","closeOptionButtons","listView","clearDragEffects","deprecatedWarning","createNavElement","navElementHtml","getOnScreenHeaderBar","headerBars","getOffScreenHeaderBar","navBarAttr","navSwipeAttr","queuedTransitionStart","queuedTransitionEnd","latestTransitionId","DATA_NAV_BAR_CTRL","PRIMARY_BUTTONS","SECONDARY_BUTTONS","ITEM_TYPES","isVisible","createHeaderBar","positionItem","itemType","rightButtonsEle","headerBarEle","prepend","leftButtonsEle","navEle","after","noTapScroll","lastViewItemEle","headerBarCtrl","headerBarInstance","setItem","navBarItemEle","removeItem","afterLeave","removeData","navElement","update","showNavBar","hasHeaderBar","enable","isInitialized","showBar","navBarItems","activeTransition","enteringHeaderBarCtrl","speed","cancelData","runApply","showBackButton","complete","triggerTransitionId","visibleBar","$isBackButtonShown","showActiveBackButton","headerBar","$title","hasTabsTop","isTabsTop","hasBarSubheader","isBarSubheader","changeTitle","setTitle","getTitle","back","getPreviousTitle","onTabsLeave","onTabsTop","associatedNavBarCtrl","getAssociatedNavBarCtrl","onBarSubheader","navBarDelegate","$$delegateHandle","inheritedData","disableRenderStartViewId","disableAnimation","isPrimary","navViewName","parentViewName","isSwipeFreeze","freezeAllScrolls","cacheCleanup","isWebView","initSwipeBack","parentNavViewCtrl","transitionData","eleId","disconnectScope","eleIdentifier","linkFn","$$controller","$$controllerAs","enableBackButton","onDragStart","startDragX","getDragX","windowWidth","dragPoints","deregDrag","onDrag","deregRelease","onRelease","dragX","t","getSwipeCompletion","releaseX","startDrag","isSwipingRight","releaseSwipeCompletion","velocity","abs","tap","pointerCoord","srcEvent","deregDragStart","$ionicBind","handleMousedown","touches","screenX","screenY","startY","floor","handleTouchstart","handleTouchend","canOverscroll","isDragging","dragOffset","lastOverscroll","ptrThreshold","start","scrollTo","scrollTime","deactivate","isOverscrolling","setScrollLock","handleTouchmove","deltaY","isAndroid","version","isCrosswalk","scrollParent","nativescroll","overscroll","activated","activate","handleScroll","scrollChild","newScrollTop","createEvent","initUIEvent","dispatchEvent","Y","easeOutCubic","currentTime","time","easedT","from","touchStartEvent","touchMoveEvent","touchEndEvent","$onPulling","$onRefresh","tail","pullingIcon","$set","showSpinner","refreshingIcon","showIcon","pullingText","refreshingText","disablePullingRotation","pointerEnabled","msPointerEnabled","getRefresherDomMethods","__handleTouchmove","__getScrollChild","__getScrollParent","scrollViewOptions","__timeout","_scrollViewOptions","isNative","nativeScrolling","ScrollNative","Scroll","bouncing","deceleration","scrollFunc","detail","$onScroll","__cleanup","getScrollView","getScrollPosition","triggerHandler","scrollBottom","zoomTo","zoom","originLeft","originTop","zoomBy","scrollBy","anchorScroll","elm","getElementById","curElm","offsetTop","attributes","freezeScroll","freeze","freezeScrollShut","freezeShut","shouldFreeze","_setRefresher","refresherScope","refresherElement","refresherMethods","refresher","refresherHeight","activatePullToRefresh","$ionicSideMenuDelegate","rightShowing","leftShowing","startX","lastX","offsetX","isAsideExposed","enableMenuWithBackViews","dragThresholdX","_handleDrag","endDrag","_endDrag","isOpenLeft","getOpenAmount","isOpenRight","toggleLeft","shouldOpen","isEnabled","openAmount","enableAnimation","openPercentage","toggleRight","side","getTranslateX","getOpenRatio","amount","isOpen","getOpenPercentage","percentage","setCanScroll","maxLeft","maxRight","setTranslateX","pushDown","bringUp","snapToRest","ratio","velocityThreshold","velocityX","exposeAside","shouldExposeAside","setMarginLeftAndRight","setMarginLeft","setMarginRight","activeAsideResizing","isResizing","dragContent","pageX","canDragContent","canDrag","edgeThreshold","edgeThresholdEnabled","edgeDragThreshold","isDraggableTarget","shouldOnlyAllowEdgeDrag","startEvent","center","dragIsWithinBounds","menuEnabled","isContentEditable","dataset","preventScroll","sideMenuContentTranslateX","deregisterBackButtonAction","closeSideMenu","createSvgElement","spinnerName","k","SHORTCUTS","isArray","setSvgAttribute","v","animationValues","strValues","values","front","concat","reverse","join","easeInOutCubic","TRANSLATE32","STROKE_OPACITY","ROUND","INDEFINITE","DURATION","NONE","a","an","at","da","os","f","lc","rc","sw","SPIN_ANIMATION","dur","IOS_SPINNER","line","y1","y2","spinners","r","cx","cy","ios-small","bubbles","cos","PI","sin","circles","crescent","dots","lines","x1","x2","ripple","fill-rule","circle","begin","keyTimes","keySplines","calcMode","spiral","defs","linearGradient","gradientUnits","stop","class","g","path","stroke","animations","startTime","scaleX","translateX","dasharray","dashoffset","rIndex","rotateLine","circleEle","rotateCircle","svgEle","anim","container","viewBox","hrefMatchesState","srefMatchesState","includes","navNameMatchesState","tabMatchesState","selectedTabIndex","selectedTab","previousSelectedTab","selectedIndex","tab","tabIndex","$tabSelected","deselect","newTabIndex","select","onDeselect","shouldEmitEvent","onSelect","hasNavView","hasActiveScope","afterEnter","viewTitleAttr","viewTitle","titleUpdate","deregisters","hideBackButton","hideNavBar","newTitle","deregisterFns","generateNavBarItem","attrTrue","$eval","navBarDelegateHandle","hasViewHeaderBar","deregIonNavBarInit","modalCtrl","viewNotified","$$phase","$digest","directive","restrict","link","keyUp","which","backdropClick","unbind","require","transclude","input","find","ng-value","ngValue","ng-model","ngModel","ng-checked","ngChecked","ng-disabled","ngDisabled","ng-true-value","ngTrueValue","ng-false-value","ngFalseValue","ng-change","ngChange","ng-required","ngRequired","required","checkboxWrapper","CollectionRepeatDirective","$ionicCollectionManager","postLink","onResize","changeValidator","resizeRequiresRefresh","__clientWidth","__clientHeight","refreshDimensions","makeChangeValidator","dataLength","newWidth","newHeight","requiresRefresh","dataChangeRequiresRefresh","newData","getRepeatManager","repeatManager","afterItemsNode","afterItemsContainer","containerNode","heightData","widthData","forceRefreshImages","keyExpression","keyExpr","renderBuffer","initAfterItemsContainer","__content","elementIsAfterRepeater","afterNodes","filter","node","initDimensions","heightExpr","parseDimensionAttr","computed","widthExpr","hasData","computeStyleDimensions","computedStyleDimensions","repeatExpr","dynamic","getValue","refreshLayout","attrValue","dimensionData","parsedValue","constantAttrValue","isConstant","decimalValue","charAt","computedStyleNode","computedStyleScope","clone","removeAttribute","listGetter","removeChild","parentNode","replaceChild","collectionRepeat","listExpr","renderBufferExpr","itemRenderBuffer","collectionBufferSize","DEFAULT_RENDER_BUFFER","itemHeight","collectionItemHeight","itemWidth","collectionItemWidth","unlistenToExposeAside","animationFrameThrottle","$watchCollection","$$postDigest","setData","$$tlb","RepeatManagerFactory","EMPTY_DIMENSION","primaryPos","secondaryPos","primarySize","secondarySize","rowPrimarySize","forceRerender","destroyed","ii","item","dim","scrollValue","getScrollValue","scrollValueEnd","scrollPrimarySize","updateRenderRange","renderStartIndex","renderEndIndex","itemsShownMap","itemsLeaving","itemsPool","shift","RepeatItem","itemsEntering","$index","$first","$last","$middle","$odd","$even","getDimensions","TRANSLATE_TEMPLATE_STR","PRIMARY","SECONDARY","cssText","WIDTH_HEIGHT_REGEX","WIDTH_HEIGHT_TEMPLATE_STR","images","img","j","jj","src","ONE_PX_TRANSPARENT_IMG_SRC","rootScopePhase","digestEnteringItems","running","nextItemId","getElementsByTagName","VerticalViewType","getItemPrimarySize","heightGetter","getItemSecondarySize","widthGetter","__scrollTop","repeaterBeforeSize","__maxScrollTop","repeaterAfterSize","refreshDirection","scrollSecondarySize","estimatedPrimarySize","estimatedHeight","estimatedSecondarySize","estimatedWidth","estimatedItemsAcross","isGridView","HorizontalViewType","__scrollLeft","__maxScrollLeft","GridViewType","getEstimatedSecondaryPos","getEstimatedPrimaryPos","getEstimatedIndex","ListViewType","StaticViewType","getContentSize","renderBeforeBoundary","renderAfterBoundary","DynamicViewType","calculateDimensionsList","toIndex","prevDimension","dimensionsIndex","dimensions","calculateDimensionsGrid","rowStartIndex","debouncedScrollViewSetDimensions","debounce","scrollViewSetDimensions","calculateDimensions","onDestroy","onRefreshData","onRefreshLayout","oldRenderStartIndex","oldScrollValue","len","lastRowDim","getterLocals","heightFn","widthFn","isVertical","isStaticView","setDimensions","contentSizeStr","originalGetContentSize","__$callback","__callback","transformLeft","transformTop","wasResize","isLayoutReady","isDataReady","firstStyle","firstElementChild","lastStyle","lastElementChild","containerPrevNode","previousElementSibling","beforeStyle","beforeMargin","poolSize","$inject","prelink","$attr","onScrollComplete","$onScrollComplete","oldClassName","hasBouncing","padding","scrollbarX","scrollbarY","scrollEventInterval","newVal","innerElement","toggleClass","locking","scrollingComplete","$$element","overflowScroll","pre","sideMenuCtrl","checkAsideExpose","mq","exposeAsideWhen","matchMedia","matches","debouncedCheck","mql","addListener","$evalAsync","gestureDirective","directiveName","$ionicGesture","substr","toLowerCase","listener","$event","GESTURE_DIRECTIVES","headerFooterBarDirective","isHeader","tElement","isSubheader","isSubfooter","getElementsByClassName","ctrls","infiniteScrollCtrl","scrollingType","doImmediateCheck","immediateCheck","labelIds","setInputAriaLabeledBy","inputs","querySelectorAll","ionInputCtrl","ITEM_TPL_DELETE_BUTTON","Number","MAX_VALUE","listCtrl","itemCtrl","inputLabel","onInput","ngModelCtrl","$render","$viewValue","isAnchor","ngHref","isComplexItem","$href","$target","$$ionicOptionsOpen","TRANSITION","ITEM_TPL_OPTION_BUTTONS","optionsContainer","ITEM_TPL_REORDER_BUTTON","onReorderFn","onReorder","$onReorder","oldIndex","newIndex","$fromIndex","$toIndex","ngClick","onClick","onclick","keyboardAttachGetClientHeight","onShow","isFullScreen","keyboardHeight","bottom","onHide","listEl","setButtonShown","shown","ListView","itemScope","canSwipe","deregister","wasShown","deleteButton","reorderButton","menuToggle","tAttrs","hasIconClass","buttonEle","childNode","hasInnerText","hasButtonText","hasPreviousTitle","hasIcon","defaultIcon","buttonTextEle","empty","navBarCtrl","outerHTML","spanEle","navElementType","parentViewCtrl","navDirection","navTransition","terminal","updateView","firstTime","$current","latestLocals","eventStopPropagation","clickExpr","clickHandler","$ionicNgClick","ionStopEvent","iconElm","disabled","refresherCtrl","finishPullToRefresh","paging","zooming","minZoom","maxZoom","isPaging","speedMultiplier","onContentTap","gestureEvt","startCoord","primaryScrollAxis","onDragX","getPrimaryScrollAxis","onDragY","onDragRelease","endCoord","xDistance","yDistance","scrollAxis","canScroll","scrollScope","xTransform","amountLeft","amountRight","animationEnabled","gestureOpts","stop_browser_behavior","prevent_default_directions","contentTapGesture","dragRightGesture","dragLeftGesture","dragUpGesture","dragDownGesture","releaseGesture","isUndefined","SideMenu","numberVal","setWidth","setIsEnabled","evt","$exposeAside","active","$ionicSlideBoxDelegate","autoPlay","doesContinue","slideInterval","showPager","pagerClick","disableScroll","onSlideChanged","activeSlide","bounce","_this","isScrollFreeze","continuous","shouldAutoPlay","slider","Slider","auto","startSlide","slidesChanged","currentSlide","currentIndex","slideIndex","onDragEnd","enableSlide","nv","slide","next","prev","__slider","kill","slidesCount","onPagerClick","getPager","pager","childScope","undefined","slideBox","selectPage","numSlides","_options","loop","createLoop","slides","rapidUpdate","getSlider","newOptions","pagination","paginationClickable","lazyLoading","preloadImages","Swiper","ionSlidesCtrl","attrStr","tabNavTemplate","iconOn","iconOff","badge","badgeStyle","hidden","tabContentEle","cloneNode","childElementCount","isNavView","selectIfMatchesState","tabCtrl","tabsCtrl","tabSelected","isSelected","isTabContentAttached","childElement","destroyTab","$tabsDestroy","tabNavElement","isolateScope","$tabsElement","selectTab","isHidden","getIconOn","getIconOff","isTabActive","$ionicTabsDelegate","emitLifecycleEvent","post","track","handle","ngModelController","Toggle","onChange","$setViewValue","checked","viewCtrl"],"mappings":"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","file":"dist/angular-ionic.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularIonic\"] = factory();\n\telse\n\t\troot[\"angularIonic\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/*! angular-ionic v1.2.4 */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularIonic\"] = factory();\n\telse\n\t\troot[\"angularIonic\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\t__webpack_require__(2);\n\t__webpack_require__(3);\n\t__webpack_require__(4);\n\t__webpack_require__(5);\n\t__webpack_require__(6);\n\t__webpack_require__(7);\n\t__webpack_require__(8);\n\t__webpack_require__(9);\n\t__webpack_require__(10);\n\t__webpack_require__(11);\n\t__webpack_require__(12);\n\t__webpack_require__(13);\n\t__webpack_require__(14);\n\t__webpack_require__(15);\n\t__webpack_require__(16);\n\t__webpack_require__(17);\n\t__webpack_require__(18);\n\t__webpack_require__(19);\n\t__webpack_require__(20);\n\t__webpack_require__(21);\n\t__webpack_require__(22);\n\t__webpack_require__(23);\n\t__webpack_require__(24);\n\t__webpack_require__(25);\n\t__webpack_require__(26);\n\t__webpack_require__(27);\n\t__webpack_require__(28);\n\t__webpack_require__(29);\n\t__webpack_require__(30);\n\t__webpack_require__(31);\n\t__webpack_require__(32);\n\t__webpack_require__(33);\n\t__webpack_require__(34);\n\t__webpack_require__(35);\n\t__webpack_require__(36);\n\t__webpack_require__(37);\n\t__webpack_require__(38);\n\t__webpack_require__(39);\n\t__webpack_require__(40);\n\t__webpack_require__(41);\n\t__webpack_require__(42);\n\t__webpack_require__(43);\n\t__webpack_require__(44);\n\t__webpack_require__(45);\n\t__webpack_require__(46);\n\t__webpack_require__(47);\n\t__webpack_require__(48);\n\t__webpack_require__(49);\n\t__webpack_require__(50);\n\t__webpack_require__(51);\n\t__webpack_require__(52);\n\t__webpack_require__(53);\n\t__webpack_require__(54);\n\t__webpack_require__(55);\n\t__webpack_require__(56);\n\t__webpack_require__(57);\n\t__webpack_require__(58);\n\t__webpack_require__(59);\n\t__webpack_require__(60);\n\t__webpack_require__(61);\n\t__webpack_require__(62);\n\t__webpack_require__(63);\n\t__webpack_require__(64);\n\t__webpack_require__(65);\n\t__webpack_require__(66);\n\t__webpack_require__(67);\n\t__webpack_require__(68);\n\t__webpack_require__(69);\n\t__webpack_require__(70);\n\t__webpack_require__(71);\n\t__webpack_require__(72);\n\t__webpack_require__(73);\n\t__webpack_require__(74);\n\t__webpack_require__(75);\n\t__webpack_require__(76);\n\t__webpack_require__(77);\n\t__webpack_require__(78);\n\t__webpack_require__(79);\n\t__webpack_require__(80);\n\t__webpack_require__(81);\n\t__webpack_require__(82);\n\t__webpack_require__(83);\n\t__webpack_require__(84);\n\t__webpack_require__(85);\n\t__webpack_require__(86);\n\t__webpack_require__(87);\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/**\n\t * ==================  angular-ios9-uiwebview.patch.js v1.1.1 ==================\n\t *\n\t * This patch works around iOS9 UIWebView regression that causes infinite digest\n\t * errors in Angular.\n\t *\n\t * The patch can be applied to Angular 1.2.0  1.4.5. Newer versions of Angular\n\t * have the workaround baked in.\n\t *\n\t * To apply this patch load/bundle this file with your application and add a\n\t * dependency on the \"ngIOS9UIWebViewPatch\" module to your main app module.\n\t *\n\t * For example:\n\t *\n\t * ```\n\t * angular.module('myApp', ['ngRoute'])`\n\t * ```\n\t *\n\t * becomes\n\t *\n\t * ```\n\t * angular.module('myApp', ['ngRoute', 'ngIOS9UIWebViewPatch'])\n\t * ```\n\t *\n\t *\n\t * More info:\n\t * - https://openradar.appspot.com/22186109\n\t * - https://github.com/angular/angular.js/issues/12241\n\t * - https://github.com/driftyco/ionic/issues/4082\n\t *\n\t *\n\t * @license AngularJS\n\t * (c) 2010-2015 Google, Inc. http://angularjs.org\n\t * License: MIT\n\t */\n\t\n\tangular.module('ngIOS9UIWebViewPatch', ['ng']).config(['$provide', function($provide) {\n\t  'use strict';\n\t\n\t  $provide.decorator('$browser', ['$delegate', '$window', function($delegate, $window) {\n\t\n\t    if (isIOS9UIWebView($window.navigator.userAgent)) {\n\t      return applyIOS9Shim($delegate);\n\t    }\n\t\n\t    return $delegate;\n\t\n\t    function isIOS9UIWebView(userAgent) {\n\t      return /(iPhone|iPad|iPod).* OS 9_\\d/.test(userAgent) && !/Version\\/9\\./.test(userAgent);\n\t    }\n\t\n\t    function applyIOS9Shim(browser) {\n\t      var pendingLocationUrl = null;\n\t      var originalUrlFn = browser.url;\n\t\n\t      browser.url = function() {\n\t        if (arguments.length) {\n\t          pendingLocationUrl = arguments[0];\n\t          return originalUrlFn.apply(browser, arguments);\n\t        }\n\t\n\t        return pendingLocationUrl || originalUrlFn.apply(browser, arguments);\n\t      };\n\t\n\t      window.addEventListener('popstate', clearPendingLocationUrl, false);\n\t      window.addEventListener('hashchange', clearPendingLocationUrl, false);\n\t\n\t      function clearPendingLocationUrl() {\n\t        pendingLocationUrl = null;\n\t      }\n\t\n\t      return browser;\n\t    }\n\t  }]);\n\t}]);\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t/* eslint no-unused-vars:0 */\n\tvar IonicModule = angular.module('ionic', ['ngAnimate', 'ngSanitize', 'ui.router', 'ngIOS9UIWebViewPatch']),\n\t  extend = angular.extend,\n\t  forEach = angular.forEach,\n\t  isDefined = angular.isDefined,\n\t  isNumber = angular.isNumber,\n\t  isString = angular.isString,\n\t  jqLite = angular.element,\n\t  noop = angular.noop;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @private\n\t * Parts of Ionic requires that $scope data is attached to the element.\n\t * We do not want to disable adding $scope data to the $element when\n\t * $compileProvider.debugInfoEnabled(false) is used.\n\t */\n\tIonicModule.config(['$provide', function($provide) {\n\t  $provide.decorator('$compile', ['$delegate', function($compile) {\n\t     $compile.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {\n\t       var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';\n\t       $element.data(dataName, scope);\n\t     };\n\t     return $compile;\n\t  }]);\n\t}]);\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @private\n\t */\n\tIonicModule.config([\n\t  '$provide',\n\tfunction($provide) {\n\t  function $LocationDecorator($location, $timeout) {\n\t\n\t    $location.__hash = $location.hash;\n\t    //Fix: when window.location.hash is set, the scrollable area\n\t    //found nearest to body's scrollTop is set to scroll to an element\n\t    //with that ID.\n\t    $location.hash = function(value) {\n\t      if (isDefined(value) && value.length > 0) {\n\t        $timeout(function() {\n\t          var scroll = document.querySelector('.scroll-content');\n\t          if (scroll) {\n\t            scroll.scrollTop = 0;\n\t          }\n\t        }, 0, false);\n\t      }\n\t      return $location.__hash(value);\n\t    };\n\t\n\t    return $location;\n\t  }\n\t\n\t  $provide.decorator('$location', ['$delegate', '$timeout', $LocationDecorator]);\n\t}]);\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicActionSheet\n\t * @module ionic\n\t * @description\n\t * The Action Sheet is a slide-up pane that lets the user choose from a set of options.\n\t * Dangerous options are highlighted in red and made obvious.\n\t *\n\t * There are easy ways to cancel out of the action sheet, such as tapping the backdrop or even\n\t * hitting escape on the keyboard for desktop testing.\n\t *\n\t * ![Action Sheet](http://ionicframework.com.s3.amazonaws.com/docs/controllers/actionSheet.gif)\n\t *\n\t * @usage\n\t * To trigger an Action Sheet in your code, use the $ionicActionSheet service in your angular controllers:\n\t *\n\t * ```js\n\t * angular.module('mySuperApp', ['ionic'])\n\t * .controller(function($scope, $ionicActionSheet, $timeout) {\n\t *\n\t *  // Triggered on a button click, or some other target\n\t *  $scope.show = function() {\n\t *\n\t *    // Show the action sheet\n\t *    var hideSheet = $ionicActionSheet.show({\n\t *      buttons: [\n\t *        { text: '<b>Share</b> This' },\n\t *        { text: 'Move' }\n\t *      ],\n\t *      destructiveText: 'Delete',\n\t *      titleText: 'Modify your album',\n\t *      cancelText: 'Cancel',\n\t *      cancel: function() {\n\t          // add cancel code..\n\t        },\n\t *      buttonClicked: function(index) {\n\t *        return true;\n\t *      }\n\t *    });\n\t *\n\t *    // For example's sake, hide the sheet after two seconds\n\t *    $timeout(function() {\n\t *      hideSheet();\n\t *    }, 2000);\n\t *\n\t *  };\n\t * });\n\t * ```\n\t *\n\t */\n\tIonicModule\n\t.factory('$ionicActionSheet', [\n\t  '$rootScope',\n\t  '$compile',\n\t  '$animate',\n\t  '$timeout',\n\t  '$ionicTemplateLoader',\n\t  '$ionicPlatform',\n\t  '$ionicBody',\n\t  'IONIC_BACK_PRIORITY',\n\tfunction($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {\n\t\n\t  return {\n\t    show: actionSheet\n\t  };\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicActionSheet#show\n\t   * @description\n\t   * Load and return a new action sheet.\n\t   *\n\t   * A new isolated scope will be created for the\n\t   * action sheet and the new element will be appended into the body.\n\t   *\n\t   * @param {object} options The options for this ActionSheet. Properties:\n\t   *\n\t   *  - `[Object]` `buttons` Which buttons to show.  Each button is an object with a `text` field.\n\t   *  - `{string}` `titleText` The title to show on the action sheet.\n\t   *  - `{string=}` `cancelText` the text for a 'cancel' button on the action sheet.\n\t   *  - `{string=}` `destructiveText` The text for a 'danger' on the action sheet.\n\t   *  - `{function=}` `cancel` Called if the cancel button is pressed, the backdrop is tapped or\n\t   *     the hardware back button is pressed.\n\t   *  - `{function=}` `buttonClicked` Called when one of the non-destructive buttons is clicked,\n\t   *     with the index of the button that was clicked and the button object. Return true to close\n\t   *     the action sheet, or false to keep it opened.\n\t   *  - `{function=}` `destructiveButtonClicked` Called when the destructive button is clicked.\n\t   *     Return true to close the action sheet, or false to keep it opened.\n\t   *  -  `{boolean=}` `cancelOnStateChange` Whether to cancel the actionSheet when navigating\n\t   *     to a new state.  Default true.\n\t   *  - `{string}` `cssClass` The custom CSS class name.\n\t   *\n\t   * @returns {function} `hideSheet` A function which, when called, hides & cancels the action sheet.\n\t   */\n\t  function actionSheet(opts) {\n\t    var scope = $rootScope.$new(true);\n\t\n\t    extend(scope, {\n\t      cancel: noop,\n\t      destructiveButtonClicked: noop,\n\t      buttonClicked: noop,\n\t      $deregisterBackButton: noop,\n\t      buttons: [],\n\t      cancelOnStateChange: true\n\t    }, opts || {});\n\t\n\t    function textForIcon(text) {\n\t      if (text && /icon/.test(text)) {\n\t        scope.$actionSheetHasIcon = true;\n\t      }\n\t    }\n\t\n\t    for (var x = 0; x < scope.buttons.length; x++) {\n\t      textForIcon(scope.buttons[x].text);\n\t    }\n\t    textForIcon(scope.cancelText);\n\t    textForIcon(scope.destructiveText);\n\t\n\t    // Compile the template\n\t    var element = scope.element = $compile('<ion-action-sheet ng-class=\"cssClass\" buttons=\"buttons\"></ion-action-sheet>')(scope);\n\t\n\t    // Grab the sheet element for animation\n\t    var sheetEl = jqLite(element[0].querySelector('.action-sheet-wrapper'));\n\t\n\t    var stateChangeListenDone = scope.cancelOnStateChange ?\n\t      $rootScope.$on('$stateChangeSuccess', function() { scope.cancel(); }) :\n\t      noop;\n\t\n\t    // removes the actionSheet from the screen\n\t    scope.removeSheet = function(done) {\n\t      if (scope.removed) return;\n\t\n\t      scope.removed = true;\n\t      sheetEl.removeClass('action-sheet-up');\n\t      $timeout(function() {\n\t        // wait to remove this due to a 300ms delay native\n\t        // click which would trigging whatever was underneath this\n\t        $ionicBody.removeClass('action-sheet-open');\n\t      }, 400);\n\t      scope.$deregisterBackButton();\n\t      stateChangeListenDone();\n\t\n\t      $animate.removeClass(element, 'active').then(function() {\n\t        scope.$destroy();\n\t        element.remove();\n\t        // scope.cancel.$scope is defined near the bottom\n\t        scope.cancel.$scope = sheetEl = null;\n\t        (done || noop)(opts.buttons);\n\t      });\n\t    };\n\t\n\t    scope.showSheet = function(done) {\n\t      if (scope.removed) return;\n\t\n\t      $ionicBody.append(element)\n\t                .addClass('action-sheet-open');\n\t\n\t      $animate.addClass(element, 'active').then(function() {\n\t        if (scope.removed) return;\n\t        (done || noop)();\n\t      });\n\t      $timeout(function() {\n\t        if (scope.removed) return;\n\t        sheetEl.addClass('action-sheet-up');\n\t      }, 20, false);\n\t    };\n\t\n\t    // registerBackButtonAction returns a callback to deregister the action\n\t    scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(\n\t      function() {\n\t        $timeout(scope.cancel);\n\t      },\n\t      IONIC_BACK_PRIORITY.actionSheet\n\t    );\n\t\n\t    // called when the user presses the cancel button\n\t    scope.cancel = function() {\n\t      // after the animation is out, call the cancel callback\n\t      scope.removeSheet(opts.cancel);\n\t    };\n\t\n\t    scope.buttonClicked = function(index) {\n\t      // Check if the button click event returned true, which means\n\t      // we can close the action sheet\n\t      if (opts.buttonClicked(index, opts.buttons[index]) === true) {\n\t        scope.removeSheet();\n\t      }\n\t    };\n\t\n\t    scope.destructiveButtonClicked = function() {\n\t      // Check if the destructive button click event returned true, which means\n\t      // we can close the action sheet\n\t      if (opts.destructiveButtonClicked() === true) {\n\t        scope.removeSheet();\n\t      }\n\t    };\n\t\n\t    scope.showSheet();\n\t\n\t    // Expose the scope on $ionicActionSheet's return value for the sake\n\t    // of testing it.\n\t    scope.cancel.$scope = scope;\n\t\n\t    return scope.cancel;\n\t  }\n\t}]);\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t\n\tjqLite.prototype.addClass = function(cssClasses) {\n\t  var x, y, cssClass, el, splitClasses, existingClasses;\n\t  if (cssClasses && cssClasses != 'ng-scope' && cssClasses != 'ng-isolate-scope') {\n\t    for (x = 0; x < this.length; x++) {\n\t      el = this[x];\n\t      if (el.setAttribute) {\n\t\n\t        if (cssClasses.indexOf(' ') < 0 && el.classList.add) {\n\t          el.classList.add(cssClasses);\n\t        } else {\n\t          existingClasses = (' ' + (el.getAttribute('class') || '') + ' ')\n\t            .replace(/[\\n\\t]/g, \" \");\n\t          splitClasses = cssClasses.split(' ');\n\t\n\t          for (y = 0; y < splitClasses.length; y++) {\n\t            cssClass = splitClasses[y].trim();\n\t            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {\n\t              existingClasses += cssClass + ' ';\n\t            }\n\t          }\n\t          el.setAttribute('class', existingClasses.trim());\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return this;\n\t};\n\t\n\tjqLite.prototype.removeClass = function(cssClasses) {\n\t  var x, y, splitClasses, cssClass, el;\n\t  if (cssClasses) {\n\t    for (x = 0; x < this.length; x++) {\n\t      el = this[x];\n\t      if (el.getAttribute) {\n\t        if (cssClasses.indexOf(' ') < 0 && el.classList.remove) {\n\t          el.classList.remove(cssClasses);\n\t        } else {\n\t          splitClasses = cssClasses.split(' ');\n\t\n\t          for (y = 0; y < splitClasses.length; y++) {\n\t            cssClass = splitClasses[y];\n\t            el.setAttribute('class', (\n\t                (\" \" + (el.getAttribute('class') || '') + \" \")\n\t                .replace(/[\\n\\t]/g, \" \")\n\t                .replace(\" \" + cssClass.trim() + \" \", \" \")).trim()\n\t            );\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return this;\n\t};\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicBackdrop\n\t * @module ionic\n\t * @description\n\t * Shows and hides a backdrop over the UI.  Appears behind popups, loading,\n\t * and other overlays.\n\t *\n\t * Often, multiple UI components require a backdrop, but only one backdrop is\n\t * ever needed in the DOM at a time.\n\t *\n\t * Therefore, each component that requires the backdrop to be shown calls\n\t * `$ionicBackdrop.retain()` when it wants the backdrop, then `$ionicBackdrop.release()`\n\t * when it is done with the backdrop.\n\t *\n\t * For each time `retain` is called, the backdrop will be shown until `release` is called.\n\t *\n\t * For example, if `retain` is called three times, the backdrop will be shown until `release`\n\t * is called three times.\n\t *\n\t * **Notes:**\n\t * - The backdrop service will broadcast 'backdrop.shown' and 'backdrop.hidden' events from the root scope,\n\t * this is useful for alerting native components not in html.\n\t *\n\t * @usage\n\t *\n\t * ```js\n\t * function MyController($scope, $ionicBackdrop, $timeout, $rootScope) {\n\t *   //Show a backdrop for one second\n\t *   $scope.action = function() {\n\t *     $ionicBackdrop.retain();\n\t *     $timeout(function() {\n\t *       $ionicBackdrop.release();\n\t *     }, 1000);\n\t *   };\n\t *\n\t *   // Execute action on backdrop disappearing\n\t *   $scope.$on('backdrop.hidden', function() {\n\t *     // Execute action\n\t *   });\n\t *\n\t *   // Execute action on backdrop appearing\n\t *   $scope.$on('backdrop.shown', function() {\n\t *     // Execute action\n\t *   });\n\t *\n\t * }\n\t * ```\n\t */\n\tIonicModule\n\t.factory('$ionicBackdrop', [\n\t  '$document', '$timeout', '$$rAF', '$rootScope',\n\tfunction($document, $timeout, $$rAF, $rootScope) {\n\t\n\t  var el = jqLite('<div class=\"backdrop\">');\n\t  var backdropHolds = 0;\n\t\n\t  $document[0].body.appendChild(el[0]);\n\t\n\t  return {\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicBackdrop#retain\n\t     * @description Retains the backdrop.\n\t     */\n\t    retain: retain,\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicBackdrop#release\n\t     * @description\n\t     * Releases the backdrop.\n\t     */\n\t    release: release,\n\t\n\t    getElement: getElement,\n\t\n\t    // exposed for testing\n\t    _element: el\n\t  };\n\t\n\t  function retain() {\n\t    backdropHolds++;\n\t    if (backdropHolds === 1) {\n\t      el.addClass('visible');\n\t      $rootScope.$broadcast('backdrop.shown');\n\t      $$rAF(function() {\n\t        // If we're still at >0 backdropHolds after async...\n\t        if (backdropHolds >= 1) el.addClass('active');\n\t      });\n\t    }\n\t  }\n\t  function release() {\n\t    if (backdropHolds === 1) {\n\t      el.removeClass('active');\n\t      $rootScope.$broadcast('backdrop.hidden');\n\t      $timeout(function() {\n\t        // If we're still at 0 backdropHolds after async...\n\t        if (backdropHolds === 0) el.removeClass('visible');\n\t      }, 400, false);\n\t    }\n\t    backdropHolds = Math.max(0, backdropHolds - 1);\n\t  }\n\t\n\t  function getElement() {\n\t    return el;\n\t  }\n\t\n\t}]);\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @private\n\t */\n\tIonicModule\n\t.factory('$ionicBind', ['$parse', '$interpolate', function($parse, $interpolate) {\n\t  var LOCAL_REGEXP = /^\\s*([@=&])(\\??)\\s*(\\w*)\\s*$/;\n\t  return function(scope, attrs, bindDefinition) {\n\t    forEach(bindDefinition || {}, function(definition, scopeName) {\n\t      //Adapted from angular.js $compile\n\t      var match = definition.match(LOCAL_REGEXP) || [],\n\t        attrName = match[3] || scopeName,\n\t        mode = match[1], // @, =, or &\n\t        parentGet,\n\t        unwatch;\n\t\n\t      switch (mode) {\n\t        case '@':\n\t          if (!attrs[attrName]) {\n\t            return;\n\t          }\n\t          attrs.$observe(attrName, function(value) {\n\t            scope[scopeName] = value;\n\t          });\n\t          // we trigger an interpolation to ensure\n\t          // the value is there for use immediately\n\t          if (attrs[attrName]) {\n\t            scope[scopeName] = $interpolate(attrs[attrName])(scope);\n\t          }\n\t          break;\n\t\n\t        case '=':\n\t          if (!attrs[attrName]) {\n\t            return;\n\t          }\n\t          unwatch = scope.$watch(attrs[attrName], function(value) {\n\t            scope[scopeName] = value;\n\t          });\n\t          //Destroy parent scope watcher when this scope is destroyed\n\t          scope.$on('$destroy', unwatch);\n\t          break;\n\t\n\t        case '&':\n\t          /* jshint -W044 */\n\t          if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + '\\(.*?\\)'))) {\n\t            throw new Error('& expression binding \"' + scopeName + '\" looks like it will recursively call \"' +\n\t                          attrs[attrName] + '\" and cause a stack overflow! Please choose a different scopeName.');\n\t          }\n\t          parentGet = $parse(attrs[attrName]);\n\t          scope[scopeName] = function(locals) {\n\t            return parentGet(scope, locals);\n\t          };\n\t          break;\n\t      }\n\t    });\n\t  };\n\t}]);\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicBody\n\t * @module ionic\n\t * @description An angular utility service to easily and efficiently\n\t * add and remove CSS classes from the document's body element.\n\t */\n\tIonicModule\n\t.factory('$ionicBody', ['$document', function($document) {\n\t  return {\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicBody#addClass\n\t     * @description Add a class to the document's body element.\n\t     * @param {string} class Each argument will be added to the body element.\n\t     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n\t     */\n\t    addClass: function() {\n\t      for (var x = 0; x < arguments.length; x++) {\n\t        $document[0].body.classList.add(arguments[x]);\n\t      }\n\t      return this;\n\t    },\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicBody#removeClass\n\t     * @description Remove a class from the document's body element.\n\t     * @param {string} class Each argument will be removed from the body element.\n\t     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n\t     */\n\t    removeClass: function() {\n\t      for (var x = 0; x < arguments.length; x++) {\n\t        $document[0].body.classList.remove(arguments[x]);\n\t      }\n\t      return this;\n\t    },\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicBody#enableClass\n\t     * @description Similar to the `add` method, except the first parameter accepts a boolean\n\t     * value determining if the class should be added or removed. Rather than writing user code,\n\t     * such as \"if true then add the class, else then remove the class\", this method can be\n\t     * given a true or false value which reduces redundant code.\n\t     * @param {boolean} shouldEnableClass A true/false value if the class should be added or removed.\n\t     * @param {string} class Each remaining argument would be added or removed depending on\n\t     * the first argument.\n\t     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n\t     */\n\t    enableClass: function(shouldEnableClass) {\n\t      var args = Array.prototype.slice.call(arguments).slice(1);\n\t      if (shouldEnableClass) {\n\t        this.addClass.apply(this, args);\n\t      } else {\n\t        this.removeClass.apply(this, args);\n\t      }\n\t      return this;\n\t    },\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicBody#append\n\t     * @description Append a child to the document's body.\n\t     * @param {element} element The element to be appended to the body. The passed in element\n\t     * can be either a jqLite element, or a DOM element.\n\t     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n\t     */\n\t    append: function(ele) {\n\t      $document[0].body.appendChild(ele.length ? ele[0] : ele);\n\t      return this;\n\t    },\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicBody#get\n\t     * @description Get the document's body element.\n\t     * @returns {element} Returns the document's body element.\n\t     */\n\t    get: function() {\n\t      return $document[0].body;\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.factory('$ionicClickBlock', [\n\t  '$document',\n\t  '$ionicBody',\n\t  '$timeout',\n\tfunction($document, $ionicBody, $timeout) {\n\t  var CSS_HIDE = 'click-block-hide';\n\t  var cbEle, fallbackTimer, pendingShow;\n\t\n\t  function preventClick(ev) {\n\t    ev.preventDefault();\n\t    ev.stopPropagation();\n\t  }\n\t\n\t  function addClickBlock() {\n\t    if (pendingShow) {\n\t      if (cbEle) {\n\t        cbEle.classList.remove(CSS_HIDE);\n\t      } else {\n\t        cbEle = $document[0].createElement('div');\n\t        cbEle.className = 'click-block';\n\t        $ionicBody.append(cbEle);\n\t        cbEle.addEventListener('touchstart', preventClick);\n\t        cbEle.addEventListener('mousedown', preventClick);\n\t      }\n\t      pendingShow = false;\n\t    }\n\t  }\n\t\n\t  function removeClickBlock() {\n\t    cbEle && cbEle.classList.add(CSS_HIDE);\n\t  }\n\t\n\t  return {\n\t    show: function(autoExpire) {\n\t      pendingShow = true;\n\t      $timeout.cancel(fallbackTimer);\n\t      fallbackTimer = $timeout(this.hide, autoExpire || 310, false);\n\t      addClickBlock();\n\t    },\n\t    hide: function() {\n\t      pendingShow = false;\n\t      $timeout.cancel(fallbackTimer);\n\t      removeClickBlock();\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicGesture\n\t * @module ionic\n\t * @description An angular service exposing ionic\n\t * {@link ionic.utility:ionic.EventController}'s gestures.\n\t */\n\tIonicModule\n\t.factory('$ionicGesture', [function() {\n\t  return {\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicGesture#on\n\t     * @description Add an event listener for a gesture on an element. See {@link ionic.utility:ionic.EventController#onGesture}.\n\t     * @param {string} eventType The gesture event to listen for.\n\t     * @param {function(e)} callback The function to call when the gesture\n\t     * happens.\n\t     * @param {element} $element The angular element to listen for the event on.\n\t     * @param {object} options object.\n\t     * @returns {ionic.Gesture} The gesture object (use this to remove the gesture later on).\n\t     */\n\t    on: function(eventType, cb, $element, options) {\n\t      return window.ionic.onGesture(eventType, cb, $element[0], options);\n\t    },\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicGesture#off\n\t     * @description Remove an event listener for a gesture on an element. See {@link ionic.utility:ionic.EventController#offGesture}.\n\t     * @param {ionic.Gesture} gesture The gesture that should be removed.\n\t     * @param {string} eventType The gesture event to remove the listener for.\n\t     * @param {function(e)} callback The listener to remove.\n\t     */\n\t    off: function(gesture, eventType, cb) {\n\t      return window.ionic.offGesture(gesture, eventType, cb);\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicHistory\n\t * @module ionic\n\t * @description\n\t * $ionicHistory keeps track of views as the user navigates through an app. Similar to the way a\n\t * browser behaves, an Ionic app is able to keep track of the previous view, the current view, and\n\t * the forward view (if there is one).  However, a typical web browser only keeps track of one\n\t * history stack in a linear fashion.\n\t *\n\t * Unlike a traditional browser environment, apps and webapps have parallel independent histories,\n\t * such as with tabs. Should a user navigate few pages deep on one tab, and then switch to a new\n\t * tab and back, the back button relates not to the previous tab, but to the previous pages\n\t * visited within _that_ tab.\n\t *\n\t * `$ionicHistory` facilitates this parallel history architecture.\n\t */\n\t\n\tIonicModule\n\t.factory('$ionicHistory', [\n\t  '$rootScope',\n\t  '$state',\n\t  '$location',\n\t  '$window',\n\t  '$timeout',\n\t  '$ionicViewSwitcher',\n\t  '$ionicNavViewDelegate',\n\tfunction($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {\n\t\n\t  // history actions while navigating views\n\t  var ACTION_INITIAL_VIEW = 'initialView';\n\t  var ACTION_NEW_VIEW = 'newView';\n\t  var ACTION_MOVE_BACK = 'moveBack';\n\t  var ACTION_MOVE_FORWARD = 'moveForward';\n\t\n\t  // direction of navigation\n\t  var DIRECTION_BACK = 'back';\n\t  var DIRECTION_FORWARD = 'forward';\n\t  var DIRECTION_ENTER = 'enter';\n\t  var DIRECTION_EXIT = 'exit';\n\t  var DIRECTION_SWAP = 'swap';\n\t  var DIRECTION_NONE = 'none';\n\t\n\t  var stateChangeCounter = 0;\n\t  var lastStateId, nextViewOptions, deregisterStateChangeListener, nextViewExpireTimer, forcedNav;\n\t\n\t  var viewHistory = {\n\t    histories: { root: { historyId: 'root', parentHistoryId: null, stack: [], cursor: -1 } },\n\t    views: {},\n\t    backView: null,\n\t    forwardView: null,\n\t    currentView: null\n\t  };\n\t\n\t  var View = function() {};\n\t  View.prototype.initialize = function(data) {\n\t    if (data) {\n\t      for (var name in data) this[name] = data[name];\n\t      return this;\n\t    }\n\t    return null;\n\t  };\n\t  View.prototype.go = function() {\n\t\n\t    if (this.stateName) {\n\t      return $state.go(this.stateName, this.stateParams);\n\t    }\n\t\n\t    if (this.url && this.url !== $location.url()) {\n\t\n\t      if (viewHistory.backView === this) {\n\t        return $window.history.go(-1);\n\t      } else if (viewHistory.forwardView === this) {\n\t        return $window.history.go(1);\n\t      }\n\t\n\t      $location.url(this.url);\n\t    }\n\t\n\t    return null;\n\t  };\n\t  View.prototype.destroy = function() {\n\t    if (this.scope) {\n\t      this.scope.$destroy && this.scope.$destroy();\n\t      this.scope = null;\n\t    }\n\t  };\n\t\n\t\n\t  function getViewById(viewId) {\n\t    return (viewId ? viewHistory.views[ viewId ] : null);\n\t  }\n\t\n\t  function getBackView(view) {\n\t    return (view ? getViewById(view.backViewId) : null);\n\t  }\n\t\n\t  function getForwardView(view) {\n\t    return (view ? getViewById(view.forwardViewId) : null);\n\t  }\n\t\n\t  function getHistoryById(historyId) {\n\t    return (historyId ? viewHistory.histories[ historyId ] : null);\n\t  }\n\t\n\t  function getHistory(scope) {\n\t    var histObj = getParentHistoryObj(scope);\n\t\n\t    if (!viewHistory.histories[ histObj.historyId ]) {\n\t      // this history object exists in parent scope, but doesn't\n\t      // exist in the history data yet\n\t      viewHistory.histories[ histObj.historyId ] = {\n\t        historyId: histObj.historyId,\n\t        parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,\n\t        stack: [],\n\t        cursor: -1\n\t      };\n\t    }\n\t    return getHistoryById(histObj.historyId);\n\t  }\n\t\n\t  function getParentHistoryObj(scope) {\n\t    var parentScope = scope;\n\t    while (parentScope) {\n\t      if (parentScope.hasOwnProperty('$historyId')) {\n\t        // this parent scope has a historyId\n\t        return { historyId: parentScope.$historyId, scope: parentScope };\n\t      }\n\t      // nothing found keep climbing up\n\t      parentScope = parentScope.$parent;\n\t    }\n\t    // no history for the parent, use the root\n\t    return { historyId: 'root', scope: $rootScope };\n\t  }\n\t\n\t  function setNavViews(viewId) {\n\t    viewHistory.currentView = getViewById(viewId);\n\t    viewHistory.backView = getBackView(viewHistory.currentView);\n\t    viewHistory.forwardView = getForwardView(viewHistory.currentView);\n\t  }\n\t\n\t  function getCurrentStateId() {\n\t    var id;\n\t    if ($state && $state.current && $state.current.name) {\n\t      id = $state.current.name;\n\t      if ($state.params) {\n\t        for (var key in $state.params) {\n\t          if ($state.params.hasOwnProperty(key) && $state.params[key]) {\n\t            id += \"_\" + key + \"=\" + $state.params[key];\n\t          }\n\t        }\n\t      }\n\t      return id;\n\t    }\n\t    // if something goes wrong make sure its got a unique stateId\n\t    return ionic.Utils.nextUid();\n\t  }\n\t\n\t  function getCurrentStateParams() {\n\t    var rtn;\n\t    if ($state && $state.params) {\n\t      for (var key in $state.params) {\n\t        if ($state.params.hasOwnProperty(key)) {\n\t          rtn = rtn || {};\n\t          rtn[key] = $state.params[key];\n\t        }\n\t      }\n\t    }\n\t    return rtn;\n\t  }\n\t\n\t\n\t  return {\n\t\n\t    register: function(parentScope, viewLocals) {\n\t\n\t      var currentStateId = getCurrentStateId(),\n\t          hist = getHistory(parentScope),\n\t          currentView = viewHistory.currentView,\n\t          backView = viewHistory.backView,\n\t          forwardView = viewHistory.forwardView,\n\t          viewId = null,\n\t          action = null,\n\t          direction = DIRECTION_NONE,\n\t          historyId = hist.historyId,\n\t          url = $location.url(),\n\t          tmp, x, ele;\n\t\n\t      if (lastStateId !== currentStateId) {\n\t        lastStateId = currentStateId;\n\t        stateChangeCounter++;\n\t      }\n\t\n\t      if (forcedNav) {\n\t        // we've previously set exactly what to do\n\t        viewId = forcedNav.viewId;\n\t        action = forcedNav.action;\n\t        direction = forcedNav.direction;\n\t        forcedNav = null;\n\t\n\t      } else if (backView && backView.stateId === currentStateId) {\n\t        // they went back one, set the old current view as a forward view\n\t        viewId = backView.viewId;\n\t        historyId = backView.historyId;\n\t        action = ACTION_MOVE_BACK;\n\t        if (backView.historyId === currentView.historyId) {\n\t          // went back in the same history\n\t          direction = DIRECTION_BACK;\n\t\n\t        } else if (currentView) {\n\t          direction = DIRECTION_EXIT;\n\t\n\t          tmp = getHistoryById(backView.historyId);\n\t          if (tmp && tmp.parentHistoryId === currentView.historyId) {\n\t            direction = DIRECTION_ENTER;\n\t\n\t          } else {\n\t            tmp = getHistoryById(currentView.historyId);\n\t            if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {\n\t              direction = DIRECTION_SWAP;\n\t            }\n\t          }\n\t        }\n\t\n\t      } else if (forwardView && forwardView.stateId === currentStateId) {\n\t        // they went to the forward one, set the forward view to no longer a forward view\n\t        viewId = forwardView.viewId;\n\t        historyId = forwardView.historyId;\n\t        action = ACTION_MOVE_FORWARD;\n\t        if (forwardView.historyId === currentView.historyId) {\n\t          direction = DIRECTION_FORWARD;\n\t\n\t        } else if (currentView) {\n\t          direction = DIRECTION_EXIT;\n\t\n\t          if (currentView.historyId === hist.parentHistoryId) {\n\t            direction = DIRECTION_ENTER;\n\t\n\t          } else {\n\t            tmp = getHistoryById(currentView.historyId);\n\t            if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {\n\t              direction = DIRECTION_SWAP;\n\t            }\n\t          }\n\t        }\n\t\n\t        tmp = getParentHistoryObj(parentScope);\n\t        if (forwardView.historyId && tmp.scope) {\n\t          // if a history has already been created by the forward view then make sure it stays the same\n\t          tmp.scope.$historyId = forwardView.historyId;\n\t          historyId = forwardView.historyId;\n\t        }\n\t\n\t      } else if (currentView && currentView.historyId !== historyId &&\n\t                hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length &&\n\t                hist.stack[hist.cursor].stateId === currentStateId) {\n\t        // they just changed to a different history and the history already has views in it\n\t        var switchToView = hist.stack[hist.cursor];\n\t        viewId = switchToView.viewId;\n\t        historyId = switchToView.historyId;\n\t        action = ACTION_MOVE_BACK;\n\t        direction = DIRECTION_SWAP;\n\t\n\t        tmp = getHistoryById(currentView.historyId);\n\t        if (tmp && tmp.parentHistoryId === historyId) {\n\t          direction = DIRECTION_EXIT;\n\t\n\t        } else {\n\t          tmp = getHistoryById(historyId);\n\t          if (tmp && tmp.parentHistoryId === currentView.historyId) {\n\t            direction = DIRECTION_ENTER;\n\t          }\n\t        }\n\t\n\t        // if switching to a different history, and the history of the view we're switching\n\t        // to has an existing back view from a different history than itself, then\n\t        // it's back view would be better represented using the current view as its back view\n\t        tmp = getViewById(switchToView.backViewId);\n\t        if (tmp && switchToView.historyId !== tmp.historyId) {\n\t          hist.stack[hist.cursor].backViewId = currentView.viewId;\n\t        }\n\t\n\t      } else {\n\t\n\t        // create an element from the viewLocals template\n\t        ele = $ionicViewSwitcher.createViewEle(viewLocals);\n\t        if (this.isAbstractEle(ele, viewLocals)) {\n\t          console.log('VIEW', 'abstractView', DIRECTION_NONE, viewHistory.currentView);\n\t          return {\n\t            action: 'abstractView',\n\t            direction: DIRECTION_NONE,\n\t            ele: ele\n\t          };\n\t        }\n\t\n\t        // set a new unique viewId\n\t        viewId = ionic.Utils.nextUid();\n\t\n\t        if (currentView) {\n\t          // set the forward view if there is a current view (ie: if its not the first view)\n\t          currentView.forwardViewId = viewId;\n\t\n\t          action = ACTION_NEW_VIEW;\n\t\n\t          // check if there is a new forward view within the same history\n\t          if (forwardView && currentView.stateId !== forwardView.stateId &&\n\t             currentView.historyId === forwardView.historyId) {\n\t            // they navigated to a new view but the stack already has a forward view\n\t            // since its a new view remove any forwards that existed\n\t            tmp = getHistoryById(forwardView.historyId);\n\t            if (tmp) {\n\t              // the forward has a history\n\t              for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {\n\t                // starting from the end destroy all forwards in this history from this point\n\t                var stackItem = tmp.stack[x];\n\t                stackItem && stackItem.destroy && stackItem.destroy();\n\t                tmp.stack.splice(x);\n\t              }\n\t              historyId = forwardView.historyId;\n\t            }\n\t          }\n\t\n\t          // its only moving forward if its in the same history\n\t          if (hist.historyId === currentView.historyId) {\n\t            direction = DIRECTION_FORWARD;\n\t\n\t          } else if (currentView.historyId !== hist.historyId) {\n\t            direction = DIRECTION_ENTER;\n\t\n\t            tmp = getHistoryById(currentView.historyId);\n\t            if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {\n\t              direction = DIRECTION_SWAP;\n\t\n\t            } else {\n\t              tmp = getHistoryById(tmp.parentHistoryId);\n\t              if (tmp && tmp.historyId === hist.historyId) {\n\t                direction = DIRECTION_EXIT;\n\t              }\n\t            }\n\t          }\n\t\n\t        } else {\n\t          // there's no current view, so this must be the initial view\n\t          action = ACTION_INITIAL_VIEW;\n\t        }\n\t\n\t        if (stateChangeCounter < 2) {\n\t          // views that were spun up on the first load should not animate\n\t          direction = DIRECTION_NONE;\n\t        }\n\t\n\t        // add the new view\n\t        viewHistory.views[viewId] = this.createView({\n\t          viewId: viewId,\n\t          index: hist.stack.length,\n\t          historyId: hist.historyId,\n\t          backViewId: (currentView && currentView.viewId ? currentView.viewId : null),\n\t          forwardViewId: null,\n\t          stateId: currentStateId,\n\t          stateName: this.currentStateName(),\n\t          stateParams: getCurrentStateParams(),\n\t          url: url,\n\t          canSwipeBack: canSwipeBack(ele, viewLocals)\n\t        });\n\t\n\t        // add the new view to this history's stack\n\t        hist.stack.push(viewHistory.views[viewId]);\n\t      }\n\t\n\t      deregisterStateChangeListener && deregisterStateChangeListener();\n\t      $timeout.cancel(nextViewExpireTimer);\n\t      if (nextViewOptions) {\n\t        if (nextViewOptions.disableAnimate) direction = DIRECTION_NONE;\n\t        if (nextViewOptions.disableBack) viewHistory.views[viewId].backViewId = null;\n\t        if (nextViewOptions.historyRoot) {\n\t          for (x = 0; x < hist.stack.length; x++) {\n\t            if (hist.stack[x].viewId === viewId) {\n\t              hist.stack[x].index = 0;\n\t              hist.stack[x].backViewId = hist.stack[x].forwardViewId = null;\n\t            } else {\n\t              delete viewHistory.views[hist.stack[x].viewId];\n\t            }\n\t          }\n\t          hist.stack = [viewHistory.views[viewId]];\n\t        }\n\t        nextViewOptions = null;\n\t      }\n\t\n\t      setNavViews(viewId);\n\t\n\t      if (viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) {\n\t        for (x = 0; x < hist.stack.length; x++) {\n\t          if (hist.stack[x].viewId == viewId) {\n\t            action = 'dupNav';\n\t            direction = DIRECTION_NONE;\n\t            if (x > 0) {\n\t              hist.stack[x - 1].forwardViewId = null;\n\t            }\n\t            viewHistory.forwardView = null;\n\t            viewHistory.currentView.index = viewHistory.backView.index;\n\t            viewHistory.currentView.backViewId = viewHistory.backView.backViewId;\n\t            viewHistory.backView = getBackView(viewHistory.backView);\n\t            hist.stack.splice(x, 1);\n\t            break;\n\t          }\n\t        }\n\t      }\n\t\n\t      console.log('VIEW', action, direction, viewHistory.currentView);\n\t\n\t      hist.cursor = viewHistory.currentView.index;\n\t\n\t      return {\n\t        viewId: viewId,\n\t        action: action,\n\t        direction: direction,\n\t        historyId: historyId,\n\t        enableBack: this.enabledBack(viewHistory.currentView),\n\t        isHistoryRoot: (viewHistory.currentView.index === 0),\n\t        ele: ele\n\t      };\n\t    },\n\t\n\t    registerHistory: function(scope) {\n\t      scope.$historyId = ionic.Utils.nextUid();\n\t    },\n\t\n\t    createView: function(data) {\n\t      var newView = new View();\n\t      return newView.initialize(data);\n\t    },\n\t\n\t    getViewById: getViewById,\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#viewHistory\n\t     * @description The app's view history data, such as all the views and histories, along\n\t     * with how they are ordered and linked together within the navigation stack.\n\t     * @returns {object} Returns an object containing the apps view history data.\n\t     */\n\t    viewHistory: function() {\n\t      return viewHistory;\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#currentView\n\t     * @description The app's current view.\n\t     * @returns {object} Returns the current view.\n\t     */\n\t    currentView: function(view) {\n\t      if (arguments.length) {\n\t        viewHistory.currentView = view;\n\t      }\n\t      return viewHistory.currentView;\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#currentHistoryId\n\t     * @description The ID of the history stack which is the parent container of the current view.\n\t     * @returns {string} Returns the current history ID.\n\t     */\n\t    currentHistoryId: function() {\n\t      return viewHistory.currentView ? viewHistory.currentView.historyId : null;\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#currentTitle\n\t     * @description Gets and sets the current view's title.\n\t     * @param {string=} val The title to update the current view with.\n\t     * @returns {string} Returns the current view's title.\n\t     */\n\t    currentTitle: function(val) {\n\t      if (viewHistory.currentView) {\n\t        if (arguments.length) {\n\t          viewHistory.currentView.title = val;\n\t        }\n\t        return viewHistory.currentView.title;\n\t      }\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#backView\n\t     * @description Returns the view that was before the current view in the history stack.\n\t     * If the user navigated from View A to View B, then View A would be the back view, and\n\t     * View B would be the current view.\n\t     * @returns {object} Returns the back view.\n\t     */\n\t    backView: function(view) {\n\t      if (arguments.length) {\n\t        viewHistory.backView = view;\n\t      }\n\t      return viewHistory.backView;\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#backTitle\n\t     * @description Gets the back view's title.\n\t     * @returns {string} Returns the back view's title.\n\t     */\n\t    backTitle: function(view) {\n\t      var backView = (view && getViewById(view.backViewId)) || viewHistory.backView;\n\t      return backView && backView.title;\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#forwardView\n\t     * @description Returns the view that was in front of the current view in the history stack.\n\t     * A forward view would exist if the user navigated from View A to View B, then\n\t     * navigated back to View A. At this point then View B would be the forward view, and View\n\t     * A would be the current view.\n\t     * @returns {object} Returns the forward view.\n\t     */\n\t    forwardView: function(view) {\n\t      if (arguments.length) {\n\t        viewHistory.forwardView = view;\n\t      }\n\t      return viewHistory.forwardView;\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#currentStateName\n\t     * @description Returns the current state name.\n\t     * @returns {string}\n\t     */\n\t    currentStateName: function() {\n\t      return ($state && $state.current ? $state.current.name : null);\n\t    },\n\t\n\t    isCurrentStateNavView: function(navView) {\n\t      return !!($state && $state.current && $state.current.views && $state.current.views[navView]);\n\t    },\n\t\n\t    goToHistoryRoot: function(historyId) {\n\t      if (historyId) {\n\t        var hist = getHistoryById(historyId);\n\t        if (hist && hist.stack.length) {\n\t          if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) {\n\t            return;\n\t          }\n\t          forcedNav = {\n\t            viewId: hist.stack[0].viewId,\n\t            action: ACTION_MOVE_BACK,\n\t            direction: DIRECTION_BACK\n\t          };\n\t          hist.stack[0].go();\n\t        }\n\t      }\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#goBack\n\t     * @param {number=} backCount Optional negative integer setting how many views to go\n\t     * back. By default it'll go back one view by using the value `-1`. To go back two\n\t     * views you would use `-2`. If the number goes farther back than the number of views\n\t     * in the current history's stack then it'll go to the first view in the current history's\n\t     * stack. If the number is zero or greater then it'll do nothing. It also does not\n\t     * cross history stacks, meaning it can only go as far back as the current history.\n\t     * @description Navigates the app to the back view, if a back view exists.\n\t     */\n\t    goBack: function(backCount) {\n\t      if (isDefined(backCount) && backCount !== -1) {\n\t        if (backCount > -1) return;\n\t\n\t        var currentHistory = viewHistory.histories[this.currentHistoryId()];\n\t        var newCursor = currentHistory.cursor + backCount + 1;\n\t        if (newCursor < 1) {\n\t          newCursor = 1;\n\t        }\n\t\n\t        currentHistory.cursor = newCursor;\n\t        setNavViews(currentHistory.stack[newCursor].viewId);\n\t\n\t        var cursor = newCursor - 1;\n\t        var clearStateIds = [];\n\t        var fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);\n\t        while (fwdView) {\n\t          clearStateIds.push(fwdView.stateId || fwdView.viewId);\n\t          cursor++;\n\t          if (cursor >= currentHistory.stack.length) break;\n\t          fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);\n\t        }\n\t\n\t        var self = this;\n\t        if (clearStateIds.length) {\n\t          $timeout(function() {\n\t            self.clearCache(clearStateIds);\n\t          }, 600);\n\t        }\n\t      }\n\t\n\t      viewHistory.backView && viewHistory.backView.go();\n\t    },\n\t\n\t\n\t    enabledBack: function(view) {\n\t      var backView = getBackView(view);\n\t      return !!(backView && backView.historyId === view.historyId);\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#clearHistory\n\t     * @description Clears out the app's entire history, except for the current view.\n\t     */\n\t    clearHistory: function() {\n\t      var\n\t      histories = viewHistory.histories,\n\t      currentView = viewHistory.currentView;\n\t\n\t      if (histories) {\n\t        for (var historyId in histories) {\n\t\n\t          if (histories[historyId].stack) {\n\t            histories[historyId].stack = [];\n\t            histories[historyId].cursor = -1;\n\t          }\n\t\n\t          if (currentView && currentView.historyId === historyId) {\n\t            currentView.backViewId = currentView.forwardViewId = null;\n\t            histories[historyId].stack.push(currentView);\n\t          } else if (histories[historyId].destroy) {\n\t            histories[historyId].destroy();\n\t          }\n\t\n\t        }\n\t      }\n\t\n\t      for (var viewId in viewHistory.views) {\n\t        if (viewId !== currentView.viewId) {\n\t          delete viewHistory.views[viewId];\n\t        }\n\t      }\n\t\n\t      if (currentView) {\n\t        setNavViews(currentView.viewId);\n\t      }\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#clearCache\n\t\t * @return promise\n\t     * @description Removes all cached views within every {@link ionic.directive:ionNavView}.\n\t     * This both removes the view element from the DOM, and destroy it's scope.\n\t     */\n\t    clearCache: function(stateIds) {\n\t      return $timeout(function() {\n\t        $ionicNavViewDelegate._instances.forEach(function(instance) {\n\t          instance.clearCache(stateIds);\n\t        });\n\t      });\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicHistory#nextViewOptions\n\t     * @description Sets options for the next view. This method can be useful to override\n\t     * certain view/transition defaults right before a view transition happens. For example,\n\t     * the {@link ionic.directive:menuClose} directive uses this method internally to ensure\n\t     * an animated view transition does not happen when a side menu is open, and also sets\n\t     * the next view as the root of its history stack. After the transition these options\n\t     * are set back to null.\n\t     *\n\t     * Available options:\n\t     *\n\t     * * `disableAnimate`: Do not animate the next transition.\n\t     * * `disableBack`: The next view should forget its back view, and set it to null.\n\t     * * `historyRoot`: The next view should become the root view in its history stack.\n\t     *\n\t     * ```js\n\t     * $ionicHistory.nextViewOptions({\n\t     *   disableAnimate: true,\n\t     *   disableBack: true\n\t     * });\n\t     * ```\n\t     */\n\t    nextViewOptions: function(opts) {\n\t      deregisterStateChangeListener && deregisterStateChangeListener();\n\t      if (arguments.length) {\n\t        $timeout.cancel(nextViewExpireTimer);\n\t        if (opts === null) {\n\t          nextViewOptions = opts;\n\t        } else {\n\t          nextViewOptions = nextViewOptions || {};\n\t          extend(nextViewOptions, opts);\n\t          if (nextViewOptions.expire) {\n\t              deregisterStateChangeListener = $rootScope.$on('$stateChangeSuccess', function() {\n\t                nextViewExpireTimer = $timeout(function() {\n\t                  nextViewOptions = null;\n\t                  }, nextViewOptions.expire);\n\t              });\n\t          }\n\t        }\n\t      }\n\t      return nextViewOptions;\n\t    },\n\t\n\t    isAbstractEle: function(ele, viewLocals) {\n\t      if (viewLocals && viewLocals.$$state && viewLocals.$$state.self['abstract']) {\n\t        return true;\n\t      }\n\t      return !!(ele && (isAbstractTag(ele) || isAbstractTag(ele.children())));\n\t    },\n\t\n\t    isActiveScope: function(scope) {\n\t      if (!scope) return false;\n\t\n\t      var climbScope = scope;\n\t      var currentHistoryId = this.currentHistoryId();\n\t      var foundHistoryId;\n\t\n\t      while (climbScope) {\n\t        if (climbScope.$$disconnected) {\n\t          return false;\n\t        }\n\t\n\t        if (!foundHistoryId && climbScope.hasOwnProperty('$historyId')) {\n\t          foundHistoryId = true;\n\t        }\n\t\n\t        if (currentHistoryId) {\n\t          if (climbScope.hasOwnProperty('$historyId') && currentHistoryId == climbScope.$historyId) {\n\t            return true;\n\t          }\n\t          if (climbScope.hasOwnProperty('$activeHistoryId')) {\n\t            if (currentHistoryId == climbScope.$activeHistoryId) {\n\t              if (climbScope.hasOwnProperty('$historyId')) {\n\t                return true;\n\t              }\n\t              if (!foundHistoryId) {\n\t                return true;\n\t              }\n\t            }\n\t          }\n\t        }\n\t\n\t        if (foundHistoryId && climbScope.hasOwnProperty('$activeHistoryId')) {\n\t          foundHistoryId = false;\n\t        }\n\t\n\t        climbScope = climbScope.$parent;\n\t      }\n\t\n\t      return currentHistoryId ? currentHistoryId == 'root' : true;\n\t    }\n\t\n\t  };\n\t\n\t  function isAbstractTag(ele) {\n\t    return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);\n\t  }\n\t\n\t  function canSwipeBack(ele, viewLocals) {\n\t    if (viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === false) {\n\t      return false;\n\t    }\n\t    if (ele && ele.attr('can-swipe-back') === 'false') {\n\t      return false;\n\t    }\n\t    return true;\n\t  }\n\t\n\t}])\n\t\n\t.run([\n\t  '$rootScope',\n\t  '$state',\n\t  '$location',\n\t  '$document',\n\t  '$ionicPlatform',\n\t  '$ionicHistory',\n\t  'IONIC_BACK_PRIORITY',\n\tfunction($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {\n\t\n\t  // always reset the keyboard state when change stage\n\t  $rootScope.$on('$ionicView.beforeEnter', function() {\n\t    ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();\n\t  });\n\t\n\t  $rootScope.$on('$ionicHistory.change', function(e, data) {\n\t    if (!data) return null;\n\t\n\t    var viewHistory = $ionicHistory.viewHistory();\n\t\n\t    var hist = (data.historyId ? viewHistory.histories[ data.historyId ] : null);\n\t    if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {\n\t      // the history they're going to already exists\n\t      // go to it's last view in its stack\n\t      var view = hist.stack[ hist.cursor ];\n\t      return view.go(data);\n\t    }\n\t\n\t    // this history does not have a URL, but it does have a uiSref\n\t    // figure out its URL from the uiSref\n\t    if (!data.url && data.uiSref) {\n\t      data.url = $state.href(data.uiSref);\n\t    }\n\t\n\t    if (data.url) {\n\t      // don't let it start with a #, messes with $location.url()\n\t      if (data.url.indexOf('#') === 0) {\n\t        data.url = data.url.replace('#', '');\n\t      }\n\t      if (data.url !== $location.url()) {\n\t        // we've got a good URL, ready GO!\n\t        $location.url(data.url);\n\t      }\n\t    }\n\t  });\n\t\n\t  $rootScope.$ionicGoBack = function(backCount) {\n\t    $ionicHistory.goBack(backCount);\n\t  };\n\t\n\t  // Set the document title when a new view is shown\n\t  $rootScope.$on('$ionicView.afterEnter', function(ev, data) {\n\t    if (data && data.title) {\n\t      $document[0].title = data.title;\n\t    }\n\t  });\n\t\n\t  // Triggered when devices with a hardware back button (Android) is clicked by the user\n\t  // This is a Cordova/Phonegap platform specifc method\n\t  function onHardwareBackButton(e) {\n\t    var backView = $ionicHistory.backView();\n\t    if (backView) {\n\t      // there is a back view, go to it\n\t      backView.go();\n\t    } else {\n\t      // there is no back view, so close the app instead\n\t      ionic.Platform.exitApp();\n\t    }\n\t    e.preventDefault();\n\t    return false;\n\t  }\n\t  $ionicPlatform.registerBackButtonAction(\n\t    onHardwareBackButton,\n\t    IONIC_BACK_PRIORITY.view\n\t  );\n\t\n\t}]);\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @ngdoc provider\r\n\t * @name $ionicConfigProvider\r\n\t * @module ionic\r\n\t * @description\r\n\t * Ionic automatically takes platform configurations into account to adjust things like what\r\n\t * transition style to use and whether tab icons should show on the top or bottom. For example,\r\n\t * iOS will move forward by transitioning the entering view from right to center and the leaving\r\n\t * view from center to left. However, Android will transition with the entering view going from\r\n\t * bottom to center, covering the previous view, which remains stationary. It should be noted\r\n\t * that when a platform is not iOS or Android, then it'll default to iOS. So if you are\r\n\t * developing on a desktop browser, it's going to take on iOS default configs.\r\n\t *\r\n\t * These configs can be changed using the `$ionicConfigProvider` during the configuration phase\r\n\t * of your app. Additionally, `$ionicConfig` can also set and get config values during the run\r\n\t * phase and within the app itself.\r\n\t *\r\n\t * By default, all base config variables are set to `'platform'`, which means it'll take on the\r\n\t * default config of the platform on which it's running. Config variables can be set at this\r\n\t * level so all platforms follow the same setting, rather than its platform config.\r\n\t * The following code would set the same config variable for all platforms:\r\n\t *\r\n\t * ```js\r\n\t * $ionicConfigProvider.views.maxCache(10);\r\n\t * ```\r\n\t *\r\n\t * Additionally, each platform can have it's own config within the `$ionicConfigProvider.platform`\r\n\t * property. The config below would only apply to Android devices.\r\n\t *\r\n\t * ```js\r\n\t * $ionicConfigProvider.platform.android.views.maxCache(5);\r\n\t * ```\r\n\t *\r\n\t * @usage\r\n\t * ```js\r\n\t * var myApp = angular.module('reallyCoolApp', ['ionic']);\r\n\t *\r\n\t * myApp.config(function($ionicConfigProvider) {\r\n\t *   $ionicConfigProvider.views.maxCache(5);\r\n\t *\r\n\t *   // note that you can also chain configs\r\n\t *   $ionicConfigProvider.backButton.text('Go Back').icon('ion-chevron-left');\r\n\t * });\r\n\t * ```\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#views.transition\r\n\t * @description Animation style when transitioning between views. Default `platform`.\r\n\t *\r\n\t * @param {string} transition Which style of view transitioning to use.\r\n\t *\r\n\t * * `platform`: Dynamically choose the correct transition style depending on the platform\r\n\t * the app is running from. If the platform is not `ios` or `android` then it will default\r\n\t * to `ios`.\r\n\t * * `ios`: iOS style transition.\r\n\t * * `android`: Android style transition.\r\n\t * * `none`: Do not perform animated transitions.\r\n\t *\r\n\t * @returns {string} value\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#views.maxCache\r\n\t * @description  Maximum number of view elements to cache in the DOM. When the max number is\r\n\t * exceeded, the view with the longest time period since it was accessed is removed. Views that\r\n\t * stay in the DOM cache the view's scope, current state, and scroll position. The scope is\r\n\t * disconnected from the `$watch` cycle when it is cached and reconnected when it enters again.\r\n\t * When the maximum cache is `0`, the leaving view's element will be removed from the DOM after\r\n\t * each view transition, and the next time the same view is shown, it will have to re-compile,\r\n\t * attach to the DOM, and link the element again. This disables caching, in effect.\r\n\t * @param {number} maxNumber Maximum number of views to retain. Default `10`.\r\n\t * @returns {number} How many views Ionic will hold onto until the a view is removed.\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#views.forwardCache\r\n\t * @description  By default, when navigating, views that were recently visited are cached, and\r\n\t * the same instance data and DOM elements are referenced when navigating back. However, when\r\n\t * navigating back in the history, the \"forward\" views are removed from the cache. If you\r\n\t * navigate forward to the same view again, it'll create a new DOM element and controller\r\n\t * instance. Basically, any forward views are reset each time. Set this config to `true` to have\r\n\t * forward views cached and not reset on each load.\r\n\t * @param {boolean} value\r\n\t * @returns {boolean}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#scrolling.jsScrolling\r\n\t * @description  Whether to use JS or Native scrolling. Defaults to native scrolling. Setting this to\r\n\t * `true` has the same effect as setting each `ion-content` to have `overflow-scroll='false'`.\r\n\t * @param {boolean} value Defaults to `false` as of Ionic 1.2\r\n\t * @returns {boolean}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#backButton.icon\r\n\t * @description Back button icon.\r\n\t * @param {string} value\r\n\t * @returns {string}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#backButton.text\r\n\t * @description Back button text.\r\n\t * @param {string} value Defaults to `Back`.\r\n\t * @returns {string}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#backButton.previousTitleText\r\n\t * @description If the previous title text should become the back button text. This\r\n\t * is the default for iOS.\r\n\t * @param {boolean} value\r\n\t * @returns {boolean}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#form.checkbox\r\n\t * @description Checkbox style. Android defaults to `square` and iOS defaults to `circle`.\r\n\t * @param {string} value\r\n\t * @returns {string}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#form.toggle\r\n\t * @description Toggle item style. Android defaults to `small` and iOS defaults to `large`.\r\n\t * @param {string} value\r\n\t * @returns {string}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#spinner.icon\r\n\t * @description Default spinner icon to use.\r\n\t * @param {string} value Can be: `android`, `ios`, `ios-small`, `bubbles`, `circles`, `crescent`,\r\n\t * `dots`, `lines`, `ripple`, or `spiral`.\r\n\t * @returns {string}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#tabs.style\r\n\t * @description Tab style. Android defaults to `striped` and iOS defaults to `standard`.\r\n\t * @param {string} value Available values include `striped` and `standard`.\r\n\t * @returns {string}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#tabs.position\r\n\t * @description Tab position. Android defaults to `top` and iOS defaults to `bottom`.\r\n\t * @param {string} value Available values include `top` and `bottom`.\r\n\t * @returns {string}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#templates.maxPrefetch\r\n\t * @description Sets the maximum number of templates to prefetch from the templateUrls defined in\r\n\t * $stateProvider.state. If set to `0`, the user will have to wait\r\n\t * for a template to be fetched the first time when navigating to a new page. Default `30`.\r\n\t * @param {integer} value Max number of template to prefetch from the templateUrls defined in\r\n\t * `$stateProvider.state()`.\r\n\t * @returns {integer}\r\n\t */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#navBar.alignTitle\r\n\t * @description Which side of the navBar to align the title. Default `center`.\r\n\t *\r\n\t * @param {string} value side of the navBar to align the title.\r\n\t *\r\n\t * * `platform`: Dynamically choose the correct title style depending on the platform\r\n\t * the app is running from. If the platform is `ios`, it will default to `center`.\r\n\t * If the platform is `android`, it will default to `left`. If the platform is not\r\n\t * `ios` or `android`, it will default to `center`.\r\n\t *\r\n\t * * `left`: Left align the title in the navBar\r\n\t * * `center`: Center align the title in the navBar\r\n\t * * `right`: Right align the title in the navBar.\r\n\t *\r\n\t * @returns {string} value\r\n\t */\r\n\t\r\n\t/**\r\n\t  * @ngdoc method\r\n\t  * @name $ionicConfigProvider#navBar.positionPrimaryButtons\r\n\t  * @description Which side of the navBar to align the primary navBar buttons. Default `left`.\r\n\t  *\r\n\t  * @param {string} value side of the navBar to align the primary navBar buttons.\r\n\t  *\r\n\t  * * `platform`: Dynamically choose the correct title style depending on the platform\r\n\t  * the app is running from. If the platform is `ios`, it will default to `left`.\r\n\t  * If the platform is `android`, it will default to `right`. If the platform is not\r\n\t  * `ios` or `android`, it will default to `left`.\r\n\t  *\r\n\t  * * `left`: Left align the primary navBar buttons in the navBar\r\n\t  * * `right`: Right align the primary navBar buttons in the navBar.\r\n\t  *\r\n\t  * @returns {string} value\r\n\t  */\r\n\t\r\n\t/**\r\n\t * @ngdoc method\r\n\t * @name $ionicConfigProvider#navBar.positionSecondaryButtons\r\n\t * @description Which side of the navBar to align the secondary navBar buttons. Default `right`.\r\n\t *\r\n\t * @param {string} value side of the navBar to align the secondary navBar buttons.\r\n\t *\r\n\t * * `platform`: Dynamically choose the correct title style depending on the platform\r\n\t * the app is running from. If the platform is `ios`, it will default to `right`.\r\n\t * If the platform is `android`, it will default to `right`. If the platform is not\r\n\t * `ios` or `android`, it will default to `right`.\r\n\t *\r\n\t * * `left`: Left align the secondary navBar buttons in the navBar\r\n\t * * `right`: Right align the secondary navBar buttons in the navBar.\r\n\t *\r\n\t * @returns {string} value\r\n\t */\r\n\t\r\n\tIonicModule\r\n\t.provider('$ionicConfig', function() {\r\n\t\r\n\t  var provider = this;\r\n\t  provider.platform = {};\r\n\t  var PLATFORM = 'platform';\r\n\t\r\n\t  var configProperties = {\r\n\t    views: {\r\n\t      maxCache: PLATFORM,\r\n\t      forwardCache: PLATFORM,\r\n\t      transition: PLATFORM,\r\n\t      swipeBackEnabled: PLATFORM,\r\n\t      swipeBackHitWidth: PLATFORM\r\n\t    },\r\n\t    navBar: {\r\n\t      alignTitle: PLATFORM,\r\n\t      positionPrimaryButtons: PLATFORM,\r\n\t      positionSecondaryButtons: PLATFORM,\r\n\t      transition: PLATFORM\r\n\t    },\r\n\t    backButton: {\r\n\t      icon: PLATFORM,\r\n\t      text: PLATFORM,\r\n\t      previousTitleText: PLATFORM\r\n\t    },\r\n\t    form: {\r\n\t      checkbox: PLATFORM,\r\n\t      toggle: PLATFORM\r\n\t    },\r\n\t    scrolling: {\r\n\t      jsScrolling: PLATFORM\r\n\t    },\r\n\t    spinner: {\r\n\t      icon: PLATFORM\r\n\t    },\r\n\t    tabs: {\r\n\t      style: PLATFORM,\r\n\t      position: PLATFORM\r\n\t    },\r\n\t    templates: {\r\n\t      maxPrefetch: PLATFORM\r\n\t    },\r\n\t    platform: {}\r\n\t  };\r\n\t  createConfig(configProperties, provider, '');\r\n\t\r\n\t\r\n\t\r\n\t  // Default\r\n\t  // -------------------------\r\n\t  setPlatformConfig('default', {\r\n\t\r\n\t    views: {\r\n\t      maxCache: 10,\r\n\t      forwardCache: false,\r\n\t      transition: 'ios',\r\n\t      swipeBackEnabled: true,\r\n\t      swipeBackHitWidth: 45\r\n\t    },\r\n\t\r\n\t    navBar: {\r\n\t      alignTitle: 'center',\r\n\t      positionPrimaryButtons: 'left',\r\n\t      positionSecondaryButtons: 'right',\r\n\t      transition: 'view'\r\n\t    },\r\n\t\r\n\t    backButton: {\r\n\t      icon: 'ion-ios-arrow-back',\r\n\t      text: 'Back',\r\n\t      previousTitleText: true\r\n\t    },\r\n\t\r\n\t    form: {\r\n\t      checkbox: 'circle',\r\n\t      toggle: 'large'\r\n\t    },\r\n\t\r\n\t    scrolling: {\r\n\t      jsScrolling: true\r\n\t    },\r\n\t\r\n\t    spinner: {\r\n\t      icon: 'ios'\r\n\t    },\r\n\t\r\n\t    tabs: {\r\n\t      style: 'standard',\r\n\t      position: 'bottom'\r\n\t    },\r\n\t\r\n\t    templates: {\r\n\t      maxPrefetch: 30\r\n\t    }\r\n\t\r\n\t  });\r\n\t\r\n\t\r\n\t\r\n\t  // iOS (it is the default already)\r\n\t  // -------------------------\r\n\t  setPlatformConfig('ios', {});\r\n\t\r\n\t\r\n\t\r\n\t  // Android\r\n\t  // -------------------------\r\n\t  setPlatformConfig('android', {\r\n\t\r\n\t    views: {\r\n\t      transition: 'android',\r\n\t      swipeBackEnabled: false\r\n\t    },\r\n\t\r\n\t    navBar: {\r\n\t      alignTitle: 'left',\r\n\t      positionPrimaryButtons: 'right',\r\n\t      positionSecondaryButtons: 'right'\r\n\t    },\r\n\t\r\n\t    backButton: {\r\n\t      icon: 'ion-android-arrow-back',\r\n\t      text: false,\r\n\t      previousTitleText: false\r\n\t    },\r\n\t\r\n\t    form: {\r\n\t      checkbox: 'square',\r\n\t      toggle: 'small'\r\n\t    },\r\n\t\r\n\t    spinner: {\r\n\t      icon: 'android'\r\n\t    },\r\n\t\r\n\t    tabs: {\r\n\t      style: 'striped',\r\n\t      position: 'top'\r\n\t    },\r\n\t\r\n\t    scrolling: {\r\n\t      jsScrolling: false\r\n\t    }\r\n\t  });\r\n\t\r\n\t  // Windows Phone\r\n\t  // -------------------------\r\n\t  setPlatformConfig('windowsphone', {\r\n\t    //scrolling: {\r\n\t    //  jsScrolling: false\r\n\t    //}\r\n\t    spinner: {\r\n\t      icon: 'android'\r\n\t    }\r\n\t  });\r\n\t\r\n\t\r\n\t  provider.transitions = {\r\n\t    views: {},\r\n\t    navBar: {}\r\n\t  };\r\n\t\r\n\t\r\n\t  // iOS Transitions\r\n\t  // -----------------------\r\n\t  provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {\r\n\t\r\n\t    function setStyles(ele, opacity, x, boxShadowOpacity) {\r\n\t      var css = {};\r\n\t      css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;\r\n\t      css.opacity = opacity;\r\n\t      if (boxShadowOpacity > -1) {\r\n\t        css.boxShadow = '0 0 10px rgba(0,0,0,' + (d.shouldAnimate ? boxShadowOpacity * 0.45 : 0.3) + ')';\r\n\t      }\r\n\t      css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';\r\n\t      ionic.DomUtil.cachedStyles(ele, css);\r\n\t    }\r\n\t\r\n\t    var d = {\r\n\t      run: function(step) {\r\n\t        if (direction == 'forward') {\r\n\t          setStyles(enteringEle, 1, (1 - step) * 99, 1 - step); // starting at 98% prevents a flicker\r\n\t          setStyles(leavingEle, (1 - 0.1 * step), step * -33, -1);\r\n\t\r\n\t        } else if (direction == 'back') {\r\n\t          setStyles(enteringEle, (1 - 0.1 * (1 - step)), (1 - step) * -33, -1);\r\n\t          setStyles(leavingEle, 1, step * 100, 1 - step);\r\n\t\r\n\t        } else {\r\n\t          // swap, enter, exit\r\n\t          setStyles(enteringEle, 1, 0, -1);\r\n\t          setStyles(leavingEle, 0, 0, -1);\r\n\t        }\r\n\t      },\r\n\t      shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')\r\n\t    };\r\n\t\r\n\t    return d;\r\n\t  };\r\n\t\r\n\t  provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {\r\n\t\r\n\t    function setStyles(ctrl, opacity, titleX, backTextX) {\r\n\t      var css = {};\r\n\t      css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : '0ms';\r\n\t      css.opacity = opacity === 1 ? '' : opacity;\r\n\t\r\n\t      ctrl.setCss('buttons-left', css);\r\n\t      ctrl.setCss('buttons-right', css);\r\n\t      ctrl.setCss('back-button', css);\r\n\t\r\n\t      css[ionic.CSS.TRANSFORM] = 'translate3d(' + backTextX + 'px,0,0)';\r\n\t      ctrl.setCss('back-text', css);\r\n\t\r\n\t      css[ionic.CSS.TRANSFORM] = 'translate3d(' + titleX + 'px,0,0)';\r\n\t      ctrl.setCss('title', css);\r\n\t    }\r\n\t\r\n\t    function enter(ctrlA, ctrlB, step) {\r\n\t      if (!ctrlA || !ctrlB) return;\r\n\t      var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step);\r\n\t      var backTextX = (ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step)) || 0;\r\n\t      setStyles(ctrlA, step, titleX, backTextX);\r\n\t    }\r\n\t\r\n\t    function leave(ctrlA, ctrlB, step) {\r\n\t      if (!ctrlA || !ctrlB) return;\r\n\t      var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - (ctrlA.titleLeftRight())) * step;\r\n\t      setStyles(ctrlA, 1 - step, titleX, 0);\r\n\t    }\r\n\t\r\n\t    var d = {\r\n\t      run: function(step) {\r\n\t        var enteringHeaderCtrl = enteringHeaderBar.controller();\r\n\t        var leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();\r\n\t        if (d.direction == 'back') {\r\n\t          leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step);\r\n\t          enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step);\r\n\t        } else {\r\n\t          enter(enteringHeaderCtrl, leavingHeaderCtrl, step);\r\n\t          leave(leavingHeaderCtrl, enteringHeaderCtrl, step);\r\n\t        }\r\n\t      },\r\n\t      direction: direction,\r\n\t      shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')\r\n\t    };\r\n\t\r\n\t    return d;\r\n\t  };\r\n\t\r\n\t\r\n\t  // Android Transitions\r\n\t  // -----------------------\r\n\t\r\n\t  provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {\r\n\t    shouldAnimate = shouldAnimate && (direction == 'forward' || direction == 'back');\r\n\t\r\n\t    function setStyles(ele, x) {\r\n\t      var css = {};\r\n\t      css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;\r\n\t      css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';\r\n\t      ionic.DomUtil.cachedStyles(ele, css);\r\n\t    }\r\n\t\r\n\t    var d = {\r\n\t      run: function(step) {\r\n\t        if (direction == 'forward') {\r\n\t          setStyles(enteringEle, (1 - step) * 99); // starting at 98% prevents a flicker\r\n\t          setStyles(leavingEle, step * -100);\r\n\t\r\n\t        } else if (direction == 'back') {\r\n\t          setStyles(enteringEle, (1 - step) * -100);\r\n\t          setStyles(leavingEle, step * 100);\r\n\t\r\n\t        } else {\r\n\t          // swap, enter, exit\r\n\t          setStyles(enteringEle, 0);\r\n\t          setStyles(leavingEle, 0);\r\n\t        }\r\n\t      },\r\n\t      shouldAnimate: shouldAnimate\r\n\t    };\r\n\t\r\n\t    return d;\r\n\t  };\r\n\t\r\n\t  provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {\r\n\t\r\n\t    function setStyles(ctrl, opacity) {\r\n\t      if (!ctrl) return;\r\n\t      var css = {};\r\n\t      css.opacity = opacity === 1 ? '' : opacity;\r\n\t\r\n\t      ctrl.setCss('buttons-left', css);\r\n\t      ctrl.setCss('buttons-right', css);\r\n\t      ctrl.setCss('back-button', css);\r\n\t      ctrl.setCss('back-text', css);\r\n\t      ctrl.setCss('title', css);\r\n\t    }\r\n\t\r\n\t    return {\r\n\t      run: function(step) {\r\n\t        setStyles(enteringHeaderBar.controller(), step);\r\n\t        setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);\r\n\t      },\r\n\t      shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')\r\n\t    };\r\n\t  };\r\n\t\r\n\t\r\n\t  // No Transition\r\n\t  // -----------------------\r\n\t\r\n\t  provider.transitions.views.none = function(enteringEle, leavingEle) {\r\n\t    return {\r\n\t      run: function(step) {\r\n\t        provider.transitions.views.android(enteringEle, leavingEle, false, false).run(step);\r\n\t      },\r\n\t      shouldAnimate: false\r\n\t    };\r\n\t  };\r\n\t\r\n\t  provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {\r\n\t    return {\r\n\t      run: function(step) {\r\n\t        provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, false, false).run(step);\r\n\t        provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, false, false).run(step);\r\n\t      },\r\n\t      shouldAnimate: false\r\n\t    };\r\n\t  };\r\n\t\r\n\t\r\n\t  // private: used to set platform configs\r\n\t  function setPlatformConfig(platformName, platformConfigs) {\r\n\t    configProperties.platform[platformName] = platformConfigs;\r\n\t    provider.platform[platformName] = {};\r\n\t\r\n\t    addConfig(configProperties, configProperties.platform[platformName]);\r\n\t\r\n\t    createConfig(configProperties.platform[platformName], provider.platform[platformName], '');\r\n\t  }\r\n\t\r\n\t\r\n\t  // private: used to recursively add new platform configs\r\n\t  function addConfig(configObj, platformObj) {\r\n\t    for (var n in configObj) {\r\n\t      if (n != PLATFORM && configObj.hasOwnProperty(n)) {\r\n\t        if (angular.isObject(configObj[n])) {\r\n\t          if (!isDefined(platformObj[n])) {\r\n\t            platformObj[n] = {};\r\n\t          }\r\n\t          addConfig(configObj[n], platformObj[n]);\r\n\t\r\n\t        } else if (!isDefined(platformObj[n])) {\r\n\t          platformObj[n] = null;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t  }\r\n\t\r\n\t\r\n\t  // private: create methods for each config to get/set\r\n\t  function createConfig(configObj, providerObj, platformPath) {\r\n\t    forEach(configObj, function(value, namespace) {\r\n\t\r\n\t      if (angular.isObject(configObj[namespace])) {\r\n\t        // recursively drill down the config object so we can create a method for each one\r\n\t        providerObj[namespace] = {};\r\n\t        createConfig(configObj[namespace], providerObj[namespace], platformPath + '.' + namespace);\r\n\t\r\n\t      } else {\r\n\t        // create a method for the provider/config methods that will be exposed\r\n\t        providerObj[namespace] = function(newValue) {\r\n\t          if (arguments.length) {\r\n\t            configObj[namespace] = newValue;\r\n\t            return providerObj;\r\n\t          }\r\n\t          if (configObj[namespace] == PLATFORM) {\r\n\t            // if the config is set to 'platform', then get this config's platform value\r\n\t            var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + '.' + namespace);\r\n\t            if (platformConfig || platformConfig === false) {\r\n\t              return platformConfig;\r\n\t            }\r\n\t            // didnt find a specific platform config, now try the default\r\n\t            return stringObj(configProperties.platform, 'default' + platformPath + '.' + namespace);\r\n\t          }\r\n\t          return configObj[namespace];\r\n\t        };\r\n\t      }\r\n\t\r\n\t    });\r\n\t  }\r\n\t\r\n\t  function stringObj(obj, str) {\r\n\t    str = str.split(\".\");\r\n\t    for (var i = 0; i < str.length; i++) {\r\n\t      if (obj && isDefined(obj[str[i]])) {\r\n\t        obj = obj[str[i]];\r\n\t      } else {\r\n\t        return null;\r\n\t      }\r\n\t    }\r\n\t    return obj;\r\n\t  }\r\n\t\r\n\t  provider.setPlatformConfig = setPlatformConfig;\r\n\t\r\n\t\r\n\t  // private: Service definition for internal Ionic use\r\n\t  /**\r\n\t   * @ngdoc service\r\n\t   * @name $ionicConfig\r\n\t   * @module ionic\r\n\t   * @private\r\n\t   */\r\n\t  provider.$get = function() {\r\n\t    return provider;\r\n\t  };\r\n\t})\r\n\t// Fix for URLs in Cordova apps on Windows Phone\r\n\t// http://blogs.msdn.com/b/msdn_answers/archive/2015/02/10/\r\n\t// running-cordova-apps-on-windows-and-windows-phone-8-1-using-ionic-angularjs-and-other-frameworks.aspx\r\n\t.config(['$compileProvider', function($compileProvider) {\r\n\t  $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|sms|tel|geo|ftp|mailto|file|ghttps?|ms-appx-web|ms-appx|x-wmapp0):/);\r\n\t  $compileProvider.imgSrcSanitizationWhitelist(/^\\s*(https?|ftp|file|content|blob|ms-appx|ms-appx-web|x-wmapp0):|data:image\\//);\r\n\t}]);\r\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\r\n\tvar LOADING_TPL =\r\n\t  '<div class=\"loading-container\">' +\r\n\t    '<div class=\"loading\">' +\r\n\t    '</div>' +\r\n\t  '</div>';\r\n\t\r\n\tvar LOADING_HIDE_DEPRECATED = '$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().';\r\n\tvar LOADING_SHOW_DEPRECATED = '$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().';\r\n\tvar LOADING_SET_DEPRECATED = '$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: \\'my content\\' }).';\r\n\t\r\n\t/**\r\n\t * @ngdoc service\r\n\t * @name $ionicLoading\r\n\t * @module ionic\r\n\t * @description\r\n\t * An overlay that can be used to indicate activity while blocking user\r\n\t * interaction.\r\n\t *\r\n\t * @usage\r\n\t * ```js\r\n\t * angular.module('LoadingApp', ['ionic'])\r\n\t * .controller('LoadingCtrl', function($scope, $ionicLoading) {\r\n\t *   $scope.show = function() {\r\n\t *     $ionicLoading.show({\r\n\t *       template: 'Loading...'\r\n\t *     });\r\n\t *   };\r\n\t *   $scope.hide = function(){\r\n\t *     $ionicLoading.hide();\r\n\t *   };\r\n\t * });\r\n\t * ```\r\n\t */\r\n\t/**\r\n\t * @ngdoc object\r\n\t * @name $ionicLoadingConfig\r\n\t * @module ionic\r\n\t * @description\r\n\t * Set the default options to be passed to the {@link ionic.service:$ionicLoading} service.\r\n\t *\r\n\t * @usage\r\n\t * ```js\r\n\t * var app = angular.module('myApp', ['ionic'])\r\n\t * app.constant('$ionicLoadingConfig', {\r\n\t *   template: 'Default Loading Template...'\r\n\t * });\r\n\t * app.controller('AppCtrl', function($scope, $ionicLoading) {\r\n\t *   $scope.showLoading = function() {\r\n\t *     $ionicLoading.show(); //options default to values in $ionicLoadingConfig\r\n\t *   };\r\n\t * });\r\n\t * ```\r\n\t */\r\n\tIonicModule\r\n\t.constant('$ionicLoadingConfig', {\r\n\t  template: '<ion-spinner></ion-spinner>'\r\n\t})\r\n\t.factory('$ionicLoading', [\r\n\t  '$ionicLoadingConfig',\r\n\t  '$ionicBody',\r\n\t  '$ionicTemplateLoader',\r\n\t  '$ionicBackdrop',\r\n\t  '$timeout',\r\n\t  '$q',\r\n\t  '$log',\r\n\t  '$compile',\r\n\t  '$ionicPlatform',\r\n\t  '$rootScope',\r\n\t  'IONIC_BACK_PRIORITY',\r\n\tfunction($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {\r\n\t\r\n\t  var loaderInstance;\r\n\t  //default values\r\n\t  var deregisterBackAction = noop;\r\n\t  var deregisterStateListener1 = noop;\r\n\t  var deregisterStateListener2 = noop;\r\n\t  var loadingShowDelay = $q.when();\r\n\t\r\n\t  return {\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name $ionicLoading#show\r\n\t     * @description Shows a loading indicator. If the indicator is already shown,\r\n\t     * it will set the options given and keep the indicator shown. Note: While this\r\n\t     * function still returns an $ionicLoading instance for backwards compatiblity,\r\n\t     * its use has been deprecated.\r\n\t     * @param {object} opts The options for the loading indicator. Available properties:\r\n\t     *  - `{string=}` `template` The html content of the indicator.\r\n\t     *  - `{string=}` `templateUrl` The url of an html template to load as the content of the indicator.\r\n\t     *  - `{object=}` `scope` The scope to be a child of. Default: creates a child of $rootScope.\r\n\t     *  - `{boolean=}` `noBackdrop` Whether to hide the backdrop. By default it will be shown.\r\n\t     *  - `{boolean=}` `hideOnStateChange` Whether to hide the loading spinner when navigating\r\n\t     *    to a new state. Default false.\r\n\t     *  - `{number=}` `delay` How many milliseconds to delay showing the indicator. By default there is no delay.\r\n\t     *  - `{number=}` `duration` How many milliseconds to wait until automatically\r\n\t     *  hiding the indicator. By default, the indicator will be shown until `.hide()` is called.\r\n\t     */\r\n\t    show: showLoader,\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name $ionicLoading#hide\r\n\t     * @description Hides the loading indicator, if shown.\r\n\t     */\r\n\t    hide: hideLoader,\r\n\t    /**\r\n\t     * @private for testing\r\n\t     */\r\n\t    _getLoader: getLoader\r\n\t  };\r\n\t\r\n\t  function getLoader() {\r\n\t    if (!loaderInstance) {\r\n\t      loaderInstance = $ionicTemplateLoader.compile({\r\n\t        template: LOADING_TPL,\r\n\t        appendTo: $ionicBody.get()\r\n\t      })\r\n\t      .then(function(self) {\r\n\t        self.show = function(options) {\r\n\t          var templatePromise = options.templateUrl ?\r\n\t            $ionicTemplateLoader.load(options.templateUrl) :\r\n\t            //options.content: deprecated\r\n\t            $q.when(options.template || options.content || '');\r\n\t\r\n\t          self.scope = options.scope || self.scope;\r\n\t\r\n\t          if (!self.isShown) {\r\n\t            //options.showBackdrop: deprecated\r\n\t            self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;\r\n\t            if (self.hasBackdrop) {\r\n\t              $ionicBackdrop.retain();\r\n\t              $ionicBackdrop.getElement().addClass('backdrop-loading');\r\n\t            }\r\n\t          }\r\n\t\r\n\t          if (options.duration) {\r\n\t            $timeout.cancel(self.durationTimeout);\r\n\t            self.durationTimeout = $timeout(\r\n\t              angular.bind(self, self.hide),\r\n\t              +options.duration\r\n\t            );\r\n\t          }\r\n\t\r\n\t          deregisterBackAction();\r\n\t          //Disable hardware back button while loading\r\n\t          deregisterBackAction = $ionicPlatform.registerBackButtonAction(\r\n\t            noop,\r\n\t            IONIC_BACK_PRIORITY.loading\r\n\t          );\r\n\t\r\n\t          templatePromise.then(function(html) {\r\n\t            if (html) {\r\n\t              var loading = self.element.children();\r\n\t              loading.html(html);\r\n\t              $compile(loading.contents())(self.scope);\r\n\t            }\r\n\t\r\n\t            //Don't show until template changes\r\n\t            if (self.isShown) {\r\n\t              self.element.addClass('visible');\r\n\t              ionic.requestAnimationFrame(function() {\r\n\t                if (self.isShown) {\r\n\t                  self.element.addClass('active');\r\n\t                  $ionicBody.addClass('loading-active');\r\n\t                }\r\n\t              });\r\n\t            }\r\n\t          });\r\n\t\r\n\t          self.isShown = true;\r\n\t        };\r\n\t        self.hide = function() {\r\n\t\r\n\t          deregisterBackAction();\r\n\t          if (self.isShown) {\r\n\t            if (self.hasBackdrop) {\r\n\t              $ionicBackdrop.release();\r\n\t              $ionicBackdrop.getElement().removeClass('backdrop-loading');\r\n\t            }\r\n\t            self.element.removeClass('active');\r\n\t            $ionicBody.removeClass('loading-active');\r\n\t            self.element.removeClass('visible');\r\n\t            ionic.requestAnimationFrame(function() {\r\n\t              !self.isShown && self.element.removeClass('visible');\r\n\t            });\r\n\t          }\r\n\t          $timeout.cancel(self.durationTimeout);\r\n\t          self.isShown = false;\r\n\t          var loading = self.element.children();\r\n\t          loading.html(\"\");\r\n\t        };\r\n\t\r\n\t        return self;\r\n\t      });\r\n\t    }\r\n\t    return loaderInstance;\r\n\t  }\r\n\t\r\n\t  function showLoader(options) {\r\n\t    options = extend({}, $ionicLoadingConfig || {}, options || {});\r\n\t    var delay = options.delay || options.showDelay || 0;\r\n\t\r\n\t    deregisterStateListener1();\r\n\t    deregisterStateListener2();\r\n\t    if (options.hideOnStateChange) {\r\n\t      deregisterStateListener1 = $rootScope.$on('$stateChangeSuccess', hideLoader);\r\n\t      deregisterStateListener2 = $rootScope.$on('$stateChangeError', hideLoader);\r\n\t    }\r\n\t\r\n\t    //If loading.show() was called previously, cancel it and show with our new options\r\n\t    $timeout.cancel(loadingShowDelay);\r\n\t    loadingShowDelay = $timeout(noop, delay);\r\n\t    loadingShowDelay.then(getLoader).then(function(loader) {\r\n\t      return loader.show(options);\r\n\t    });\r\n\t\r\n\t    return {\r\n\t      hide: function deprecatedHide() {\r\n\t        $log.error(LOADING_HIDE_DEPRECATED);\r\n\t        return hideLoader.apply(this, arguments);\r\n\t      },\r\n\t      show: function deprecatedShow() {\r\n\t        $log.error(LOADING_SHOW_DEPRECATED);\r\n\t        return showLoader.apply(this, arguments);\r\n\t      },\r\n\t      setContent: function deprecatedSetContent(content) {\r\n\t        $log.error(LOADING_SET_DEPRECATED);\r\n\t        return getLoader().then(function(loader) {\r\n\t          loader.show({ template: content });\r\n\t        });\r\n\t      }\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function hideLoader() {\r\n\t    deregisterStateListener1();\r\n\t    deregisterStateListener2();\r\n\t    $timeout.cancel(loadingShowDelay);\r\n\t    getLoader().then(function(loader) {\r\n\t      loader.hide();\r\n\t    });\r\n\t  }\r\n\t}]);\r\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @ngdoc service\r\n\t * @name $ionicModal\r\n\t * @module ionic\r\n\t * @description\r\n\t *\r\n\t * Related: {@link ionic.controller:ionicModal ionicModal controller}.\r\n\t *\r\n\t * The Modal is a content pane that can go over the user's main view\r\n\t * temporarily.  Usually used for making a choice or editing an item.\r\n\t *\r\n\t * Put the content of the modal inside of an `<ion-modal-view>` element.\r\n\t *\r\n\t * **Notes:**\r\n\t * - A modal will broadcast 'modal.shown', 'modal.hidden', and 'modal.removed' events from its originating\r\n\t * scope, passing in itself as an event argument. Both the modal.removed and modal.hidden events are\r\n\t * called when the modal is removed.\r\n\t *\r\n\t * - This example assumes your modal is in your main index file or another template file. If it is in its own\r\n\t * template file, remove the script tags and call it by file name.\r\n\t *\r\n\t * @usage\r\n\t * ```html\r\n\t * <script id=\"my-modal.html\" type=\"text/ng-template\">\r\n\t *   <ion-modal-view>\r\n\t *     <ion-header-bar>\r\n\t *       <h1 class=\"title\">My Modal title</h1>\r\n\t *     </ion-header-bar>\r\n\t *     <ion-content>\r\n\t *       Hello!\r\n\t *     </ion-content>\r\n\t *   </ion-modal-view>\r\n\t * </script>\r\n\t * ```\r\n\t * ```js\r\n\t * angular.module('testApp', ['ionic'])\r\n\t * .controller('MyController', function($scope, $ionicModal) {\r\n\t *   $ionicModal.fromTemplateUrl('my-modal.html', {\r\n\t *     scope: $scope,\r\n\t *     animation: 'slide-in-up'\r\n\t *   }).then(function(modal) {\r\n\t *     $scope.modal = modal;\r\n\t *   });\r\n\t *   $scope.openModal = function() {\r\n\t *     $scope.modal.show();\r\n\t *   };\r\n\t *   $scope.closeModal = function() {\r\n\t *     $scope.modal.hide();\r\n\t *   };\r\n\t *   //Cleanup the modal when we're done with it!\r\n\t *   $scope.$on('$destroy', function() {\r\n\t *     $scope.modal.remove();\r\n\t *   });\r\n\t *   // Execute action on hide modal\r\n\t *   $scope.$on('modal.hidden', function() {\r\n\t *     // Execute action\r\n\t *   });\r\n\t *   // Execute action on remove modal\r\n\t *   $scope.$on('modal.removed', function() {\r\n\t *     // Execute action\r\n\t *   });\r\n\t * });\r\n\t * ```\r\n\t */\r\n\tIonicModule\r\n\t.factory('$ionicModal', [\r\n\t  '$rootScope',\r\n\t  '$ionicBody',\r\n\t  '$compile',\r\n\t  '$timeout',\r\n\t  '$ionicPlatform',\r\n\t  '$ionicTemplateLoader',\r\n\t  '$$q',\r\n\t  '$log',\r\n\t  '$ionicClickBlock',\r\n\t  '$window',\r\n\t  'IONIC_BACK_PRIORITY',\r\n\tfunction($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {\r\n\t\r\n\t  /**\r\n\t   * @ngdoc controller\r\n\t   * @name ionicModal\r\n\t   * @module ionic\r\n\t   * @description\r\n\t   * Instantiated by the {@link ionic.service:$ionicModal} service.\r\n\t   *\r\n\t   * Be sure to call [remove()](#remove) when you are done with each modal\r\n\t   * to clean it up and avoid memory leaks.\r\n\t   *\r\n\t   * Note: a modal will broadcast 'modal.shown', 'modal.hidden', and 'modal.removed' events from its originating\r\n\t   * scope, passing in itself as an event argument. Note: both modal.removed and modal.hidden are\r\n\t   * called when the modal is removed.\r\n\t   */\r\n\t  var ModalView = ionic.views.Modal.inherit({\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name ionicModal#initialize\r\n\t     * @description Creates a new modal controller instance.\r\n\t     * @param {object} options An options object with the following properties:\r\n\t     *  - `{object=}` `scope` The scope to be a child of.\r\n\t     *    Default: creates a child of $rootScope.\r\n\t     *  - `{string=}` `animation` The animation to show & hide with.\r\n\t     *    Default: 'slide-in-up'\r\n\t     *  - `{boolean=}` `focusFirstInput` Whether to autofocus the first input of\r\n\t     *    the modal when shown. Will only show the keyboard on iOS, to force the keyboard to show\r\n\t     *    on Android, please use the [Ionic keyboard plugin](https://github.com/driftyco/ionic-plugin-keyboard#keyboardshow).\r\n\t     *    Default: false.\r\n\t     *  - `{boolean=}` `backdropClickToClose` Whether to close the modal on clicking the backdrop.\r\n\t     *    Default: true.\r\n\t     *  - `{boolean=}` `hardwareBackButtonClose` Whether the modal can be closed using the hardware\r\n\t     *    back button on Android and similar devices.  Default: true.\r\n\t     */\r\n\t    initialize: function(opts) {\r\n\t      ionic.views.Modal.prototype.initialize.call(this, opts);\r\n\t      this.animation = opts.animation || 'slide-in-up';\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name ionicModal#show\r\n\t     * @description Show this modal instance.\r\n\t     * @returns {promise} A promise which is resolved when the modal is finished animating in.\r\n\t     */\r\n\t    show: function(target) {\r\n\t      var self = this;\r\n\t\r\n\t      if (self.scope.$$destroyed) {\r\n\t        $log.error('Cannot call ' + self.viewType + '.show() after remove(). Please create a new ' + self.viewType + ' instance.');\r\n\t        return $$q.when();\r\n\t      }\r\n\t\r\n\t      // on iOS, clicks will sometimes bleed through/ghost click on underlying\r\n\t      // elements\r\n\t      $ionicClickBlock.show(600);\r\n\t      stack.add(self);\r\n\t\r\n\t      var modalEl = jqLite(self.modalEl);\r\n\t\r\n\t      self.el.classList.remove('hide');\r\n\t      $timeout(function() {\r\n\t        if (!self._isShown) return;\r\n\t        $ionicBody.addClass(self.viewType + '-open');\r\n\t      }, 400, false);\r\n\t\r\n\t      if (!self.el.parentElement) {\r\n\t        modalEl.addClass(self.animation);\r\n\t        $ionicBody.append(self.el);\r\n\t      }\r\n\t\r\n\t      // if modal was closed while the keyboard was up, reset scroll view on\r\n\t      // next show since we can only resize it once it's visible\r\n\t      var scrollCtrl = modalEl.data('$$ionicScrollController');\r\n\t      scrollCtrl && scrollCtrl.resize();\r\n\t\r\n\t      if (target && self.positionView) {\r\n\t        self.positionView(target, modalEl);\r\n\t        // set up a listener for in case the window size changes\r\n\t\r\n\t        self._onWindowResize = function() {\r\n\t          if (self._isShown) self.positionView(target, modalEl);\r\n\t        };\r\n\t        ionic.on('resize', self._onWindowResize, window);\r\n\t      }\r\n\t\r\n\t      modalEl.addClass('ng-enter active')\r\n\t             .removeClass('ng-leave ng-leave-active');\r\n\t\r\n\t      self._isShown = true;\r\n\t      self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(\r\n\t        self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop,\r\n\t        IONIC_BACK_PRIORITY.modal\r\n\t      );\r\n\t\r\n\t      ionic.views.Modal.prototype.show.call(self);\r\n\t\r\n\t      $timeout(function() {\r\n\t        if (!self._isShown) return;\r\n\t        modalEl.addClass('ng-enter-active');\r\n\t        ionic.trigger('resize');\r\n\t        self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.shown', self);\r\n\t        self.el.classList.add('active');\r\n\t        self.scope.$broadcast('$ionicHeader.align');\r\n\t        self.scope.$broadcast('$ionicFooter.align');\r\n\t      }, 20);\r\n\t\r\n\t      return $timeout(function() {\r\n\t        if (!self._isShown) return;\r\n\t        self.$el.on('touchmove', function(e) {\r\n\t          //Don't allow scrolling while open by dragging on backdrop\r\n\t          var isInScroll = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'scroll');\r\n\t          if (!isInScroll) {\r\n\t            e.preventDefault();\r\n\t          }\r\n\t        });\r\n\t        //After animating in, allow hide on backdrop click\r\n\t        self.$el.on('click', function(e) {\r\n\t          if (self.backdropClickToClose && e.target === self.el && stack.isHighest(self)) {\r\n\t            self.hide();\r\n\t          }\r\n\t        });\r\n\t      }, 400);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name ionicModal#hide\r\n\t     * @description Hide this modal instance.\r\n\t     * @returns {promise} A promise which is resolved when the modal is finished animating out.\r\n\t     */\r\n\t    hide: function() {\r\n\t      var self = this;\r\n\t      var modalEl = jqLite(self.modalEl);\r\n\t\r\n\t      // on iOS, clicks will sometimes bleed through/ghost click on underlying\r\n\t      // elements\r\n\t      $ionicClickBlock.show(600);\r\n\t      stack.remove(self);\r\n\t\r\n\t      self.el.classList.remove('active');\r\n\t      modalEl.addClass('ng-leave');\r\n\t\r\n\t      $timeout(function() {\r\n\t        if (self._isShown) return;\r\n\t        modalEl.addClass('ng-leave-active')\r\n\t               .removeClass('ng-enter ng-enter-active active');\r\n\t      }, 20, false);\r\n\t\r\n\t      self.$el.off('click');\r\n\t      self._isShown = false;\r\n\t      self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.hidden', self);\r\n\t      self._deregisterBackButton && self._deregisterBackButton();\r\n\t\r\n\t      ionic.views.Modal.prototype.hide.call(self);\r\n\t\r\n\t      // clean up event listeners\r\n\t      if (self.positionView) {\r\n\t        ionic.off('resize', self._onWindowResize, window);\r\n\t      }\r\n\t\r\n\t      return $timeout(function() {\r\n\t        $ionicBody.removeClass(self.viewType + '-open');\r\n\t        self.el.classList.add('hide');\r\n\t      }, self.hideDelay || 320);\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name ionicModal#remove\r\n\t     * @description Remove this modal instance from the DOM and clean up.\r\n\t     * @returns {promise} A promise which is resolved when the modal is finished animating out.\r\n\t     */\r\n\t    remove: function() {\r\n\t      var self = this;\r\n\t      self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.removed', self);\r\n\t\r\n\t      return self.hide().then(function() {\r\n\t        self.scope.$destroy();\r\n\t        self.$el.remove();\r\n\t      });\r\n\t    },\r\n\t\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name ionicModal#isShown\r\n\t     * @returns boolean Whether this modal is currently shown.\r\n\t     */\r\n\t    isShown: function() {\r\n\t      return !!this._isShown;\r\n\t    }\r\n\t  });\r\n\t\r\n\t  var createModal = function(templateString, options) {\r\n\t    // Create a new scope for the modal\r\n\t    var scope = options.scope && options.scope.$new() || $rootScope.$new(true);\r\n\t\r\n\t    options.viewType = options.viewType || 'modal';\r\n\t\r\n\t    extend(scope, {\r\n\t      $hasHeader: false,\r\n\t      $hasSubheader: false,\r\n\t      $hasFooter: false,\r\n\t      $hasSubfooter: false,\r\n\t      $hasTabs: false,\r\n\t      $hasTabsTop: false\r\n\t    });\r\n\t\r\n\t    // Compile the template\r\n\t    var element = $compile('<ion-' + options.viewType + '>' + templateString + '</ion-' + options.viewType + '>')(scope);\r\n\t\r\n\t    options.$el = element;\r\n\t    options.el = element[0];\r\n\t    options.modalEl = options.el.querySelector('.' + options.viewType);\r\n\t    var modal = new ModalView(options);\r\n\t\r\n\t    modal.scope = scope;\r\n\t\r\n\t    // If this wasn't a defined scope, we can assign the viewType to the isolated scope\r\n\t    // we created\r\n\t    if (!options.scope) {\r\n\t      scope[ options.viewType ] = modal;\r\n\t    }\r\n\t\r\n\t    return modal;\r\n\t  };\r\n\t\r\n\t  var modalStack = [];\r\n\t  var stack = {\r\n\t    add: function(modal) {\r\n\t      modalStack.push(modal);\r\n\t    },\r\n\t    remove: function(modal) {\r\n\t      var index = modalStack.indexOf(modal);\r\n\t      if (index > -1 && index < modalStack.length) {\r\n\t        modalStack.splice(index, 1);\r\n\t      }\r\n\t    },\r\n\t    isHighest: function(modal) {\r\n\t      var index = modalStack.indexOf(modal);\r\n\t      return (index > -1 && index === modalStack.length - 1);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  return {\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name $ionicModal#fromTemplate\r\n\t     * @param {string} templateString The template string to use as the modal's\r\n\t     * content.\r\n\t     * @param {object} options Options to be passed {@link ionic.controller:ionicModal#initialize ionicModal#initialize} method.\r\n\t     * @returns {object} An instance of an {@link ionic.controller:ionicModal}\r\n\t     * controller.\r\n\t     */\r\n\t    fromTemplate: function(templateString, options) {\r\n\t      var modal = createModal(templateString, options || {});\r\n\t      return modal;\r\n\t    },\r\n\t    /**\r\n\t     * @ngdoc method\r\n\t     * @name $ionicModal#fromTemplateUrl\r\n\t     * @param {string} templateUrl The url to load the template from.\r\n\t     * @param {object} options Options to be passed {@link ionic.controller:ionicModal#initialize ionicModal#initialize} method.\r\n\t     * options object.\r\n\t     * @returns {promise} A promise that will be resolved with an instance of\r\n\t     * an {@link ionic.controller:ionicModal} controller.\r\n\t     */\r\n\t    fromTemplateUrl: function(url, options, _) {\r\n\t      var cb;\r\n\t      //Deprecated: allow a callback as second parameter. Now we return a promise.\r\n\t      if (angular.isFunction(options)) {\r\n\t        cb = options;\r\n\t        options = _;\r\n\t      }\r\n\t      return $ionicTemplateLoader.load(url).then(function(templateString) {\r\n\t        var modal = createModal(templateString, options || {});\r\n\t        cb && cb(modal);\r\n\t        return modal;\r\n\t      });\r\n\t    },\r\n\t\r\n\t    stack: stack\r\n\t  };\r\n\t}]);\r\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $ionicNavBarDelegate\n\t * @module ionic\n\t * @description\n\t * Delegate for controlling the {@link ionic.directive:ionNavBar} directive.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <body ng-controller=\"MyCtrl\">\n\t *   <ion-nav-bar>\n\t *     <button ng-click=\"setNavTitle('banana')\">\n\t *       Set title to banana!\n\t *     </button>\n\t *   </ion-nav-bar>\n\t * </body>\n\t * ```\n\t * ```js\n\t * function MyCtrl($scope, $ionicNavBarDelegate) {\n\t *   $scope.setNavTitle = function(title) {\n\t *     $ionicNavBarDelegate.title(title);\n\t *   }\n\t * }\n\t * ```\n\t */\n\tIonicModule\n\t.service('$ionicNavBarDelegate', ionic.DelegateService([\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavBarDelegate#align\n\t   * @description Aligns the title with the buttons in a given direction.\n\t   * @param {string=} direction The direction to the align the title text towards.\n\t   * Available: 'left', 'right', 'center'. Default: 'center'.\n\t   */\n\t  'align',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavBarDelegate#showBackButton\n\t   * @description\n\t   * Set/get whether the {@link ionic.directive:ionNavBackButton} is shown\n\t   * (if it exists and there is a previous view that can be navigated to).\n\t   * @param {boolean=} show Whether to show the back button.\n\t   * @returns {boolean} Whether the back button is shown.\n\t   */\n\t  'showBackButton',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavBarDelegate#showBar\n\t   * @description\n\t   * Set/get whether the {@link ionic.directive:ionNavBar} is shown.\n\t   * @param {boolean} show Whether to show the bar.\n\t   * @returns {boolean} Whether the bar is shown.\n\t   */\n\t  'showBar',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavBarDelegate#title\n\t   * @description\n\t   * Set the title for the {@link ionic.directive:ionNavBar}.\n\t   * @param {string} title The new title to show.\n\t   */\n\t  'title',\n\t\n\t  // DEPRECATED, as of v1.0.0-beta14 -------\n\t  'changeTitle',\n\t  'setTitle',\n\t  'getTitle',\n\t  'back',\n\t  'getPreviousTitle'\n\t  // END DEPRECATED -------\n\t]));\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t\n\tIonicModule\n\t.service('$ionicNavViewDelegate', ionic.DelegateService([\n\t  'clearCache'\n\t]));\n\t\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $ionicPlatform\n\t * @module ionic\n\t * @description\n\t * An angular abstraction of {@link ionic.utility:ionic.Platform}.\n\t *\n\t * Used to detect the current platform, as well as do things like override the\n\t * Android back button in PhoneGap/Cordova.\n\t */\n\tIonicModule\n\t.constant('IONIC_BACK_PRIORITY', {\n\t  view: 100,\n\t  sideMenu: 150,\n\t  modal: 200,\n\t  actionSheet: 300,\n\t  popup: 400,\n\t  loading: 500\n\t})\n\t.provider('$ionicPlatform', function() {\n\t  return {\n\t    $get: ['$q', '$ionicScrollDelegate', function($q, $ionicScrollDelegate) {\n\t      var self = {\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $ionicPlatform#onHardwareBackButton\n\t         * @description\n\t         * Some platforms have a hardware back button, so this is one way to\n\t         * bind to it.\n\t         * @param {function} callback the callback to trigger when this event occurs\n\t         */\n\t        onHardwareBackButton: function(cb) {\n\t          ionic.Platform.ready(function() {\n\t            document.addEventListener('backbutton', cb, false);\n\t          });\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $ionicPlatform#offHardwareBackButton\n\t         * @description\n\t         * Remove an event listener for the backbutton.\n\t         * @param {function} callback The listener function that was\n\t         * originally bound.\n\t         */\n\t        offHardwareBackButton: function(fn) {\n\t          ionic.Platform.ready(function() {\n\t            document.removeEventListener('backbutton', fn);\n\t          });\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $ionicPlatform#registerBackButtonAction\n\t         * @description\n\t         * Register a hardware back button action. Only one action will execute\n\t         * when the back button is clicked, so this method decides which of\n\t         * the registered back button actions has the highest priority.\n\t         *\n\t         * For example, if an actionsheet is showing, the back button should\n\t         * close the actionsheet, but it should not also go back a page view\n\t         * or close a modal which may be open.\n\t         *\n\t         * The priorities for the existing back button hooks are as follows:\n\t         *   Return to previous view = 100\n\t         *   Close side menu = 150\n\t         *   Dismiss modal = 200\n\t         *   Close action sheet = 300\n\t         *   Dismiss popup = 400\n\t         *   Dismiss loading overlay = 500\n\t         *\n\t         * Your back button action will override each of the above actions\n\t         * whose priority is less than the priority you provide. For example,\n\t         * an action assigned a priority of 101 will override the 'return to\n\t         * previous view' action, but not any of the other actions.\n\t         *\n\t         * @param {function} callback Called when the back button is pressed,\n\t         * if this listener is the highest priority.\n\t         * @param {number} priority Only the highest priority will execute.\n\t         * @param {*=} actionId The id to assign this action. Default: a\n\t         * random unique id.\n\t         * @returns {function} A function that, when called, will deregister\n\t         * this backButtonAction.\n\t         */\n\t        $backButtonActions: {},\n\t        registerBackButtonAction: function(fn, priority, actionId) {\n\t\n\t          if (!self._hasBackButtonHandler) {\n\t            // add a back button listener if one hasn't been setup yet\n\t            self.$backButtonActions = {};\n\t            self.onHardwareBackButton(self.hardwareBackButtonClick);\n\t            self._hasBackButtonHandler = true;\n\t          }\n\t\n\t          var action = {\n\t            id: (actionId ? actionId : ionic.Utils.nextUid()),\n\t            priority: (priority ? priority : 0),\n\t            fn: fn\n\t          };\n\t          self.$backButtonActions[action.id] = action;\n\t\n\t          // return a function to de-register this back button action\n\t          return function() {\n\t            delete self.$backButtonActions[action.id];\n\t          };\n\t        },\n\t\n\t        /**\n\t         * @private\n\t         */\n\t        hardwareBackButtonClick: function(e) {\n\t          // loop through all the registered back button actions\n\t          // and only run the last one of the highest priority\n\t          var priorityAction, actionId;\n\t          for (actionId in self.$backButtonActions) {\n\t            if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {\n\t              priorityAction = self.$backButtonActions[actionId];\n\t            }\n\t          }\n\t          if (priorityAction) {\n\t            priorityAction.fn(e);\n\t            return priorityAction;\n\t          }\n\t        },\n\t\n\t        is: function(type) {\n\t          return ionic.Platform.is(type);\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $ionicPlatform#on\n\t         * @description\n\t         * Add Cordova event listeners, such as `pause`, `resume`, `volumedownbutton`, `batterylow`,\n\t         * `offline`, etc. More information about available event types can be found in\n\t         * [Cordova's event documentation](https://cordova.apache.org/docs/en/edge/cordova_events_events.md.html#Events).\n\t         * @param {string} type Cordova [event type](https://cordova.apache.org/docs/en/edge/cordova_events_events.md.html#Events).\n\t         * @param {function} callback Called when the Cordova event is fired.\n\t         * @returns {function} Returns a deregistration function to remove the event listener.\n\t         */\n\t        on: function(type, cb) {\n\t          ionic.Platform.ready(function() {\n\t            document.addEventListener(type, cb, false);\n\t          });\n\t          return function() {\n\t            ionic.Platform.ready(function() {\n\t              document.removeEventListener(type, cb);\n\t            });\n\t          };\n\t        },\n\t\n\t        /**\n\t         * @ngdoc method\n\t         * @name $ionicPlatform#ready\n\t         * @description\n\t         * Trigger a callback once the device is ready,\n\t         * or immediately if the device is already ready.\n\t         * @param {function=} callback The function to call.\n\t         * @returns {promise} A promise which is resolved when the device is ready.\n\t         */\n\t        ready: function(cb) {\n\t          var q = $q.defer();\n\t\n\t          ionic.Platform.ready(function() {\n\t            q.resolve();\n\t            cb && cb();\n\t          });\n\t\n\t          return q.promise;\n\t        }\n\t      };\n\t\n\t      window.addEventListener('statusTap', function() {\n\t        $ionicScrollDelegate.scrollTop(true);\n\t      });\n\t\n\t      return self;\n\t    }]\n\t  };\n\t\n\t});\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicPopover\n\t * @module ionic\n\t * @description\n\t *\n\t * Related: {@link ionic.controller:ionicPopover ionicPopover controller}.\n\t *\n\t * The Popover is a view that floats above an apps content. Popovers provide an\n\t * easy way to present or gather information from the user and are\n\t * commonly used in the following situations:\n\t *\n\t * - Show more info about the current view\n\t * - Select a commonly used tool or configuration\n\t * - Present a list of actions to perform inside one of your views\n\t *\n\t * Put the content of the popover inside of an `<ion-popover-view>` element.\n\t *\n\t * @usage\n\t * ```html\n\t * <p>\n\t *   <button ng-click=\"openPopover($event)\">Open Popover</button>\n\t * </p>\n\t *\n\t * <script id=\"my-popover.html\" type=\"text/ng-template\">\n\t *   <ion-popover-view>\n\t *     <ion-header-bar>\n\t *       <h1 class=\"title\">My Popover Title</h1>\n\t *     </ion-header-bar>\n\t *     <ion-content>\n\t *       Hello!\n\t *     </ion-content>\n\t *   </ion-popover-view>\n\t * </script>\n\t * ```\n\t * ```js\n\t * angular.module('testApp', ['ionic'])\n\t * .controller('MyController', function($scope, $ionicPopover) {\n\t *\n\t *   // .fromTemplate() method\n\t *   var template = '<ion-popover-view><ion-header-bar> <h1 class=\"title\">My Popover Title</h1> </ion-header-bar> <ion-content> Hello! </ion-content></ion-popover-view>';\n\t *\n\t *   $scope.popover = $ionicPopover.fromTemplate(template, {\n\t *     scope: $scope\n\t *   });\n\t *\n\t *   // .fromTemplateUrl() method\n\t *   $ionicPopover.fromTemplateUrl('my-popover.html', {\n\t *     scope: $scope\n\t *   }).then(function(popover) {\n\t *     $scope.popover = popover;\n\t *   });\n\t *\n\t *\n\t *   $scope.openPopover = function($event) {\n\t *     $scope.popover.show($event);\n\t *   };\n\t *   $scope.closePopover = function() {\n\t *     $scope.popover.hide();\n\t *   };\n\t *   //Cleanup the popover when we're done with it!\n\t *   $scope.$on('$destroy', function() {\n\t *     $scope.popover.remove();\n\t *   });\n\t *   // Execute action on hide popover\n\t *   $scope.$on('popover.hidden', function() {\n\t *     // Execute action\n\t *   });\n\t *   // Execute action on remove popover\n\t *   $scope.$on('popover.removed', function() {\n\t *     // Execute action\n\t *   });\n\t * });\n\t * ```\n\t */\n\t\n\t\n\tIonicModule\n\t.factory('$ionicPopover', ['$ionicModal', '$ionicPosition', '$document', '$window',\n\tfunction($ionicModal, $ionicPosition, $document, $window) {\n\t\n\t  var POPOVER_BODY_PADDING = 6;\n\t\n\t  var POPOVER_OPTIONS = {\n\t    viewType: 'popover',\n\t    hideDelay: 1,\n\t    animation: 'none',\n\t    positionView: positionView\n\t  };\n\t\n\t  function positionView(target, popoverEle) {\n\t    var targetEle = jqLite(target.target || target);\n\t    var buttonOffset = $ionicPosition.offset(targetEle);\n\t    var popoverWidth = popoverEle.prop('offsetWidth');\n\t    var popoverHeight = popoverEle.prop('offsetHeight');\n\t    // Use innerWidth and innerHeight, because clientWidth and clientHeight\n\t    // doesn't work consistently for body on all platforms\n\t    var bodyWidth = $window.innerWidth;\n\t    var bodyHeight = $window.innerHeight;\n\t\n\t    var popoverCSS = {\n\t      left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2\n\t    };\n\t    var arrowEle = jqLite(popoverEle[0].querySelector('.popover-arrow'));\n\t\n\t    if (popoverCSS.left < POPOVER_BODY_PADDING) {\n\t      popoverCSS.left = POPOVER_BODY_PADDING;\n\t    } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {\n\t      popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;\n\t    }\n\t\n\t    // If the popover when popped down stretches past bottom of screen,\n\t    // make it pop up if there's room above\n\t    if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight &&\n\t        buttonOffset.top - popoverHeight > 0) {\n\t      popoverCSS.top = buttonOffset.top - popoverHeight;\n\t      popoverEle.addClass('popover-bottom');\n\t    } else {\n\t      popoverCSS.top = buttonOffset.top + buttonOffset.height;\n\t      popoverEle.removeClass('popover-bottom');\n\t    }\n\t\n\t    arrowEle.css({\n\t      left: buttonOffset.left + buttonOffset.width / 2 -\n\t        arrowEle.prop('offsetWidth') / 2 - popoverCSS.left + 'px'\n\t    });\n\t\n\t    popoverEle.css({\n\t      top: popoverCSS.top + 'px',\n\t      left: popoverCSS.left + 'px',\n\t      marginLeft: '0',\n\t      opacity: '1'\n\t    });\n\t\n\t  }\n\t\n\t  /**\n\t   * @ngdoc controller\n\t   * @name ionicPopover\n\t   * @module ionic\n\t   * @description\n\t   * Instantiated by the {@link ionic.service:$ionicPopover} service.\n\t   *\n\t   * Be sure to call [remove()](#remove) when you are done with each popover\n\t   * to clean it up and avoid memory leaks.\n\t   *\n\t   * Note: a popover will broadcast 'popover.shown', 'popover.hidden', and 'popover.removed' events from its originating\n\t   * scope, passing in itself as an event argument. Both the popover.removed and popover.hidden events are\n\t   * called when the popover is removed.\n\t   */\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name ionicPopover#initialize\n\t   * @description Creates a new popover controller instance.\n\t   * @param {object} options An options object with the following properties:\n\t   *  - `{object=}` `scope` The scope to be a child of.\n\t   *    Default: creates a child of $rootScope.\n\t   *  - `{boolean=}` `focusFirstInput` Whether to autofocus the first input of\n\t   *    the popover when shown.  Default: false.\n\t   *  - `{boolean=}` `backdropClickToClose` Whether to close the popover on clicking the backdrop.\n\t   *    Default: true.\n\t   *  - `{boolean=}` `hardwareBackButtonClose` Whether the popover can be closed using the hardware\n\t   *    back button on Android and similar devices.  Default: true.\n\t   */\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name ionicPopover#show\n\t   * @description Show this popover instance.\n\t   * @param {$event} $event The $event or target element which the popover should align\n\t   * itself next to.\n\t   * @returns {promise} A promise which is resolved when the popover is finished animating in.\n\t   */\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name ionicPopover#hide\n\t   * @description Hide this popover instance.\n\t   * @returns {promise} A promise which is resolved when the popover is finished animating out.\n\t   */\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name ionicPopover#remove\n\t   * @description Remove this popover instance from the DOM and clean up.\n\t   * @returns {promise} A promise which is resolved when the popover is finished animating out.\n\t   */\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name ionicPopover#isShown\n\t   * @returns boolean Whether this popover is currently shown.\n\t   */\n\t\n\t  return {\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicPopover#fromTemplate\n\t     * @param {string} templateString The template string to use as the popovers's\n\t     * content.\n\t     * @param {object} options Options to be passed to the initialize method.\n\t     * @returns {object} An instance of an {@link ionic.controller:ionicPopover}\n\t     * controller (ionicPopover is built on top of $ionicPopover).\n\t     */\n\t    fromTemplate: function(templateString, options) {\n\t      return $ionicModal.fromTemplate(templateString, ionic.Utils.extend({}, POPOVER_OPTIONS, options));\n\t    },\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicPopover#fromTemplateUrl\n\t     * @param {string} templateUrl The url to load the template from.\n\t     * @param {object} options Options to be passed to the initialize method.\n\t     * @returns {promise} A promise that will be resolved with an instance of\n\t     * an {@link ionic.controller:ionicPopover} controller (ionicPopover is built on top of $ionicPopover).\n\t     */\n\t    fromTemplateUrl: function(url, options) {\n\t      return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend({}, POPOVER_OPTIONS, options));\n\t    }\n\t  };\n\t\n\t}]);\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports) {\n\n\t\n\tvar POPUP_TPL =\n\t  '<div class=\"popup-container\" ng-class=\"cssClass\">' +\n\t    '<div class=\"popup\">' +\n\t      '<div class=\"popup-head\">' +\n\t        '<h3 class=\"popup-title\" ng-bind-html=\"title\"></h3>' +\n\t        '<h5 class=\"popup-sub-title\" ng-bind-html=\"subTitle\" ng-if=\"subTitle\"></h5>' +\n\t      '</div>' +\n\t      '<div class=\"popup-body\">' +\n\t      '</div>' +\n\t      '<div class=\"popup-buttons\" ng-show=\"buttons.length\">' +\n\t        '<button ng-repeat=\"button in buttons\" ng-click=\"$buttonTapped(button, $event)\" class=\"button\" ng-class=\"button.type || \\'button-default\\'\" ng-bind-html=\"button.text\"></button>' +\n\t      '</div>' +\n\t    '</div>' +\n\t  '</div>';\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $ionicPopup\n\t * @module ionic\n\t * @restrict E\n\t * @codepen zkmhJ\n\t * @description\n\t *\n\t * The Ionic Popup service allows programmatically creating and showing popup\n\t * windows that require the user to respond in order to continue.\n\t *\n\t * The popup system has support for more flexible versions of the built in `alert()`, `prompt()`,\n\t * and `confirm()` functions that users are used to, in addition to allowing popups with completely\n\t * custom content and look.\n\t *\n\t * An input can be given an `autofocus` attribute so it automatically receives focus when\n\t * the popup first shows. However, depending on certain use-cases this can cause issues with\n\t * the tap/click system, which is why Ionic prefers using the `autofocus` attribute as\n\t * an opt-in feature and not the default.\n\t *\n\t * @usage\n\t * A few basic examples, see below for details about all of the options available.\n\t *\n\t * ```js\n\t *angular.module('mySuperApp', ['ionic'])\n\t *.controller('PopupCtrl',function($scope, $ionicPopup, $timeout) {\n\t *\n\t * // Triggered on a button click, or some other target\n\t * $scope.showPopup = function() {\n\t *   $scope.data = {};\n\t *\n\t *   // An elaborate, custom popup\n\t *   var myPopup = $ionicPopup.show({\n\t *     template: '<input type=\"password\" ng-model=\"data.wifi\">',\n\t *     title: 'Enter Wi-Fi Password',\n\t *     subTitle: 'Please use normal things',\n\t *     scope: $scope,\n\t *     buttons: [\n\t *       { text: 'Cancel' },\n\t *       {\n\t *         text: '<b>Save</b>',\n\t *         type: 'button-positive',\n\t *         onTap: function(e) {\n\t *           if (!$scope.data.wifi) {\n\t *             //don't allow the user to close unless he enters wifi password\n\t *             e.preventDefault();\n\t *           } else {\n\t *             return $scope.data.wifi;\n\t *           }\n\t *         }\n\t *       }\n\t *     ]\n\t *   });\n\t *\n\t *   myPopup.then(function(res) {\n\t *     console.log('Tapped!', res);\n\t *   });\n\t *\n\t *   $timeout(function() {\n\t *      myPopup.close(); //close the popup after 3 seconds for some reason\n\t *   }, 3000);\n\t *  };\n\t *\n\t *  // A confirm dialog\n\t *  $scope.showConfirm = function() {\n\t *    var confirmPopup = $ionicPopup.confirm({\n\t *      title: 'Consume Ice Cream',\n\t *      template: 'Are you sure you want to eat this ice cream?'\n\t *    });\n\t *\n\t *    confirmPopup.then(function(res) {\n\t *      if(res) {\n\t *        console.log('You are sure');\n\t *      } else {\n\t *        console.log('You are not sure');\n\t *      }\n\t *    });\n\t *  };\n\t *\n\t *  // An alert dialog\n\t *  $scope.showAlert = function() {\n\t *    var alertPopup = $ionicPopup.alert({\n\t *      title: 'Don\\'t eat that!',\n\t *      template: 'It might taste good'\n\t *    });\n\t *\n\t *    alertPopup.then(function(res) {\n\t *      console.log('Thank you for not eating my delicious ice cream cone');\n\t *    });\n\t *  };\n\t *});\n\t *```\n\t */\n\t\n\tIonicModule\n\t.factory('$ionicPopup', [\n\t  '$ionicTemplateLoader',\n\t  '$ionicBackdrop',\n\t  '$q',\n\t  '$timeout',\n\t  '$rootScope',\n\t  '$ionicBody',\n\t  '$compile',\n\t  '$ionicPlatform',\n\t  '$ionicModal',\n\t  'IONIC_BACK_PRIORITY',\n\tfunction($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, $ionicModal, IONIC_BACK_PRIORITY) {\n\t  //TODO allow this to be configured\n\t  var config = {\n\t    stackPushDelay: 75\n\t  };\n\t  var popupStack = [];\n\t\n\t  var $ionicPopup = {\n\t    /**\n\t     * @ngdoc method\n\t     * @description\n\t     * Show a complex popup. This is the master show function for all popups.\n\t     *\n\t     * A complex popup has a `buttons` array, with each button having a `text` and `type`\n\t     * field, in addition to an `onTap` function.  The `onTap` function, called when\n\t     * the corresponding button on the popup is tapped, will by default close the popup\n\t     * and resolve the popup promise with its return value.  If you wish to prevent the\n\t     * default and keep the popup open on button tap, call `event.preventDefault()` on the\n\t     * passed in tap event.  Details below.\n\t     *\n\t     * @name $ionicPopup#show\n\t     * @param {object} options The options for the new popup, of the form:\n\t     *\n\t     * ```\n\t     * {\n\t     *   title: '', // String. The title of the popup.\n\t     *   cssClass: '', // String, The custom CSS class name\n\t     *   subTitle: '', // String (optional). The sub-title of the popup.\n\t     *   template: '', // String (optional). The html template to place in the popup body.\n\t     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup   body.\n\t     *   scope: null, // Scope (optional). A scope to link to the popup content.\n\t     *   buttons: [{ // Array[Object] (optional). Buttons to place in the popup footer.\n\t     *     text: 'Cancel',\n\t     *     type: 'button-default',\n\t     *     onTap: function(e) {\n\t     *       // e.preventDefault() will stop the popup from closing when tapped.\n\t     *       e.preventDefault();\n\t     *     }\n\t     *   }, {\n\t     *     text: 'OK',\n\t     *     type: 'button-positive',\n\t     *     onTap: function(e) {\n\t     *       // Returning a value will cause the promise to resolve with the given value.\n\t     *       return scope.data.response;\n\t     *     }\n\t     *   }]\n\t     * }\n\t     * ```\n\t     *\n\t     * @returns {object} A promise which is resolved when the popup is closed. Has an additional\n\t     * `close` function, which can be used to programmatically close the popup.\n\t     */\n\t    show: showPopup,\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicPopup#alert\n\t     * @description Show a simple alert popup with a message and one button that the user can\n\t     * tap to close the popup.\n\t     *\n\t     * @param {object} options The options for showing the alert, of the form:\n\t     *\n\t     * ```\n\t     * {\n\t     *   title: '', // String. The title of the popup.\n\t     *   cssClass: '', // String, The custom CSS class name\n\t     *   subTitle: '', // String (optional). The sub-title of the popup.\n\t     *   template: '', // String (optional). The html template to place in the popup body.\n\t     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup   body.\n\t     *   okText: '', // String (default: 'OK'). The text of the OK button.\n\t     *   okType: '', // String (default: 'button-positive'). The type of the OK button.\n\t     * }\n\t     * ```\n\t     *\n\t     * @returns {object} A promise which is resolved when the popup is closed. Has one additional\n\t     * function `close`, which can be called with any value to programmatically close the popup\n\t     * with the given value.\n\t     */\n\t    alert: showAlert,\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicPopup#confirm\n\t     * @description\n\t     * Show a simple confirm popup with a Cancel and OK button.\n\t     *\n\t     * Resolves the promise with true if the user presses the OK button, and false if the\n\t     * user presses the Cancel button.\n\t     *\n\t     * @param {object} options The options for showing the confirm popup, of the form:\n\t     *\n\t     * ```\n\t     * {\n\t     *   title: '', // String. The title of the popup.\n\t     *   cssClass: '', // String, The custom CSS class name\n\t     *   subTitle: '', // String (optional). The sub-title of the popup.\n\t     *   template: '', // String (optional). The html template to place in the popup body.\n\t     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup   body.\n\t     *   cancelText: '', // String (default: 'Cancel'). The text of the Cancel button.\n\t     *   cancelType: '', // String (default: 'button-default'). The type of the Cancel button.\n\t     *   okText: '', // String (default: 'OK'). The text of the OK button.\n\t     *   okType: '', // String (default: 'button-positive'). The type of the OK button.\n\t     * }\n\t     * ```\n\t     *\n\t     * @returns {object} A promise which is resolved when the popup is closed. Has one additional\n\t     * function `close`, which can be called with any value to programmatically close the popup\n\t     * with the given value.\n\t     */\n\t    confirm: showConfirm,\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicPopup#prompt\n\t     * @description Show a simple prompt popup, which has an input, OK button, and Cancel button.\n\t     * Resolves the promise with the value of the input if the user presses OK, and with undefined\n\t     * if the user presses Cancel.\n\t     *\n\t     * ```javascript\n\t     *  $ionicPopup.prompt({\n\t     *    title: 'Password Check',\n\t     *    template: 'Enter your secret password',\n\t     *    inputType: 'password',\n\t     *    inputPlaceholder: 'Your password'\n\t     *  }).then(function(res) {\n\t     *    console.log('Your password is', res);\n\t     *  });\n\t     * ```\n\t     * @param {object} options The options for showing the prompt popup, of the form:\n\t     *\n\t     * ```\n\t     * {\n\t     *   title: '', // String. The title of the popup.\n\t     *   cssClass: '', // String, The custom CSS class name\n\t     *   subTitle: '', // String (optional). The sub-title of the popup.\n\t     *   template: '', // String (optional). The html template to place in the popup body.\n\t     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup body.\n\t     *   inputType: // String (default: 'text'). The type of input to use\n\t     *   defaultText: // String (default: ''). The initial value placed into the input.\n\t     *   maxLength: // Integer (default: null). Specify a maxlength attribute for the input.\n\t     *   inputPlaceholder: // String (default: ''). A placeholder to use for the input.\n\t     *   cancelText: // String (default: 'Cancel'. The text of the Cancel button.\n\t     *   cancelType: // String (default: 'button-default'). The type of the Cancel button.\n\t     *   okText: // String (default: 'OK'). The text of the OK button.\n\t     *   okType: // String (default: 'button-positive'). The type of the OK button.\n\t     * }\n\t     * ```\n\t     *\n\t     * @returns {object} A promise which is resolved when the popup is closed. Has one additional\n\t     * function `close`, which can be called with any value to programmatically close the popup\n\t     * with the given value.\n\t     */\n\t    prompt: showPrompt,\n\t    /**\n\t     * @private for testing\n\t     */\n\t    _createPopup: createPopup,\n\t    _popupStack: popupStack\n\t  };\n\t\n\t  return $ionicPopup;\n\t\n\t  function createPopup(options) {\n\t    options = extend({\n\t      scope: null,\n\t      title: '',\n\t      buttons: []\n\t    }, options || {});\n\t\n\t    var self = {};\n\t    self.scope = (options.scope || $rootScope).$new();\n\t    self.element = jqLite(POPUP_TPL);\n\t    self.responseDeferred = $q.defer();\n\t\n\t    $ionicBody.get().appendChild(self.element[0]);\n\t    $compile(self.element)(self.scope);\n\t\n\t    extend(self.scope, {\n\t      title: options.title,\n\t      buttons: options.buttons,\n\t      subTitle: options.subTitle,\n\t      cssClass: options.cssClass,\n\t      $buttonTapped: function(button, event) {\n\t        var result = (button.onTap || noop).apply(self, [event]);\n\t        event = event.originalEvent || event; //jquery events\n\t\n\t        if (!event.defaultPrevented) {\n\t          self.responseDeferred.resolve(result);\n\t        }\n\t      }\n\t    });\n\t\n\t    $q.when(\n\t      options.templateUrl ?\n\t      $ionicTemplateLoader.load(options.templateUrl) :\n\t        (options.template || options.content || '')\n\t    ).then(function(template) {\n\t      var popupBody = jqLite(self.element[0].querySelector('.popup-body'));\n\t      if (template) {\n\t        popupBody.html(template);\n\t        $compile(popupBody.contents())(self.scope);\n\t      } else {\n\t        popupBody.remove();\n\t      }\n\t    });\n\t\n\t    self.show = function() {\n\t      if (self.isShown || self.removed) return;\n\t\n\t      $ionicModal.stack.add(self);\n\t      self.isShown = true;\n\t      ionic.requestAnimationFrame(function() {\n\t        //if hidden while waiting for raf, don't show\n\t        if (!self.isShown) return;\n\t\n\t        self.element.removeClass('popup-hidden');\n\t        self.element.addClass('popup-showing active');\n\t        focusInput(self.element);\n\t      });\n\t    };\n\t\n\t    self.hide = function(callback) {\n\t      callback = callback || noop;\n\t      if (!self.isShown) return callback();\n\t\n\t      $ionicModal.stack.remove(self);\n\t      self.isShown = false;\n\t      self.element.removeClass('active');\n\t      self.element.addClass('popup-hidden');\n\t      $timeout(callback, 250, false);\n\t    };\n\t\n\t    self.remove = function() {\n\t      if (self.removed) return;\n\t\n\t      self.hide(function() {\n\t        self.element.remove();\n\t        self.scope.$destroy();\n\t      });\n\t\n\t      self.removed = true;\n\t    };\n\t\n\t    return self;\n\t  }\n\t\n\t  function onHardwareBackButton() {\n\t    var last = popupStack[popupStack.length - 1];\n\t    last && last.responseDeferred.resolve();\n\t  }\n\t\n\t  function showPopup(options) {\n\t    var popup = $ionicPopup._createPopup(options);\n\t    var showDelay = 0;\n\t\n\t    if (popupStack.length > 0) {\n\t      showDelay = config.stackPushDelay;\n\t      $timeout(popupStack[popupStack.length - 1].hide, showDelay, false);\n\t    } else {\n\t      //Add popup-open & backdrop if this is first popup\n\t      $ionicBody.addClass('popup-open');\n\t      $ionicBackdrop.retain();\n\t      //only show the backdrop on the first popup\n\t      $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(\n\t        onHardwareBackButton,\n\t        IONIC_BACK_PRIORITY.popup\n\t      );\n\t    }\n\t\n\t    // Expose a 'close' method on the returned promise\n\t    popup.responseDeferred.promise.close = function popupClose(result) {\n\t      if (!popup.removed) popup.responseDeferred.resolve(result);\n\t    };\n\t    //DEPRECATED: notify the promise with an object with a close method\n\t    popup.responseDeferred.notify({ close: popup.responseDeferred.close });\n\t\n\t    doShow();\n\t\n\t    return popup.responseDeferred.promise;\n\t\n\t    function doShow() {\n\t      popupStack.push(popup);\n\t      $timeout(popup.show, showDelay, false);\n\t\n\t      popup.responseDeferred.promise.then(function(result) {\n\t        var index = popupStack.indexOf(popup);\n\t        if (index !== -1) {\n\t          popupStack.splice(index, 1);\n\t        }\n\t\n\t        popup.remove();\n\t\n\t        if (popupStack.length > 0) {\n\t          popupStack[popupStack.length - 1].show();\n\t        } else {\n\t          $ionicBackdrop.release();\n\t          //Remove popup-open & backdrop if this is last popup\n\t          $timeout(function() {\n\t            // wait to remove this due to a 300ms delay native\n\t            // click which would trigging whatever was underneath this\n\t            if (!popupStack.length) {\n\t              $ionicBody.removeClass('popup-open');\n\t            }\n\t          }, 400, false);\n\t          ($ionicPopup._backButtonActionDone || noop)();\n\t        }\n\t\n\t\n\t        return result;\n\t      });\n\t\n\t    }\n\t\n\t  }\n\t\n\t  function focusInput(element) {\n\t    var focusOn = element[0].querySelector('[autofocus]');\n\t    if (focusOn) {\n\t      focusOn.focus();\n\t    }\n\t  }\n\t\n\t  function showAlert(opts) {\n\t    return showPopup(extend({\n\t      buttons: [{\n\t        text: opts.okText || 'OK',\n\t        type: opts.okType || 'button-positive',\n\t        onTap: function() {\n\t          return true;\n\t        }\n\t      }]\n\t    }, opts || {}));\n\t  }\n\t\n\t  function showConfirm(opts) {\n\t    return showPopup(extend({\n\t      buttons: [{\n\t        text: opts.cancelText || 'Cancel',\n\t        type: opts.cancelType || 'button-default',\n\t        onTap: function() { return false; }\n\t      }, {\n\t        text: opts.okText || 'OK',\n\t        type: opts.okType || 'button-positive',\n\t        onTap: function() { return true; }\n\t      }]\n\t    }, opts || {}));\n\t  }\n\t\n\t  function showPrompt(opts) {\n\t    var scope = $rootScope.$new(true);\n\t    scope.data = {};\n\t    scope.data.fieldtype = opts.inputType ? opts.inputType : 'text';\n\t    scope.data.response = opts.defaultText ? opts.defaultText : '';\n\t    scope.data.placeholder = opts.inputPlaceholder ? opts.inputPlaceholder : '';\n\t    scope.data.maxlength = opts.maxLength ? parseInt(opts.maxLength) : '';\n\t    var text = '';\n\t    if (opts.template && /<[a-z][\\s\\S]*>/i.test(opts.template) === false) {\n\t      text = '<span>' + opts.template + '</span>';\n\t      delete opts.template;\n\t    }\n\t    return showPopup(extend({\n\t      template: text + '<input ng-model=\"data.response\" '\n\t        + 'type=\"{{ data.fieldtype }}\"'\n\t        + 'maxlength=\"{{ data.maxlength }}\"'\n\t        + 'placeholder=\"{{ data.placeholder }}\"'\n\t        + '>',\n\t      scope: scope,\n\t      buttons: [{\n\t        text: opts.cancelText || 'Cancel',\n\t        type: opts.cancelType || 'button-default',\n\t        onTap: function() {}\n\t      }, {\n\t        text: opts.okText || 'OK',\n\t        type: opts.okType || 'button-positive',\n\t        onTap: function() {\n\t          return scope.data.response || '';\n\t        }\n\t      }]\n\t    }, opts || {}));\n\t  }\n\t}]);\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicPosition\n\t * @module ionic\n\t * @description\n\t * A set of utility methods that can be use to retrieve position of DOM elements.\n\t * It is meant to be used where we need to absolute-position DOM elements in\n\t * relation to other, existing elements (this is the case for tooltips, popovers, etc.).\n\t *\n\t * Adapted from [AngularUI Bootstrap](https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js),\n\t * ([license](https://github.com/angular-ui/bootstrap/blob/master/LICENSE))\n\t */\n\tIonicModule\n\t.factory('$ionicPosition', ['$document', '$window', function($document, $window) {\n\t\n\t  function getStyle(el, cssprop) {\n\t    if (el.currentStyle) { //IE\n\t      return el.currentStyle[cssprop];\n\t    } else if ($window.getComputedStyle) {\n\t      return $window.getComputedStyle(el)[cssprop];\n\t    }\n\t    // finally try and get inline style\n\t    return el.style[cssprop];\n\t  }\n\t\n\t  /**\n\t   * Checks if a given element is statically positioned\n\t   * @param element - raw DOM element\n\t   */\n\t  function isStaticPositioned(element) {\n\t    return (getStyle(element, 'position') || 'static') === 'static';\n\t  }\n\t\n\t  /**\n\t   * returns the closest, non-statically positioned parentOffset of a given element\n\t   * @param element\n\t   */\n\t  var parentOffsetEl = function(element) {\n\t    var docDomEl = $document[0];\n\t    var offsetParent = element.offsetParent || docDomEl;\n\t    while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {\n\t      offsetParent = offsetParent.offsetParent;\n\t    }\n\t    return offsetParent || docDomEl;\n\t  };\n\t\n\t  return {\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicPosition#position\n\t     * @description Get the current coordinates of the element, relative to the offset parent.\n\t     * Read-only equivalent of [jQuery's position function](http://api.jquery.com/position/).\n\t     * @param {element} element The element to get the position of.\n\t     * @returns {object} Returns an object containing the properties top, left, width and height.\n\t     */\n\t    position: function(element) {\n\t      var elBCR = this.offset(element);\n\t      var offsetParentBCR = { top: 0, left: 0 };\n\t      var offsetParentEl = parentOffsetEl(element[0]);\n\t      if (offsetParentEl != $document[0]) {\n\t        offsetParentBCR = this.offset(jqLite(offsetParentEl));\n\t        offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n\t        offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n\t      }\n\t\n\t      var boundingClientRect = element[0].getBoundingClientRect();\n\t      return {\n\t        width: boundingClientRect.width || element.prop('offsetWidth'),\n\t        height: boundingClientRect.height || element.prop('offsetHeight'),\n\t        top: elBCR.top - offsetParentBCR.top,\n\t        left: elBCR.left - offsetParentBCR.left\n\t      };\n\t    },\n\t\n\t    /**\n\t     * @ngdoc method\n\t     * @name $ionicPosition#offset\n\t     * @description Get the current coordinates of the element, relative to the document.\n\t     * Read-only equivalent of [jQuery's offset function](http://api.jquery.com/offset/).\n\t     * @param {element} element The element to get the offset of.\n\t     * @returns {object} Returns an object containing the properties top, left, width and height.\n\t     */\n\t    offset: function(element) {\n\t      var boundingClientRect = element[0].getBoundingClientRect();\n\t      return {\n\t        width: boundingClientRect.width || element.prop('offsetWidth'),\n\t        height: boundingClientRect.height || element.prop('offsetHeight'),\n\t        top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n\t        left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n\t      };\n\t    }\n\t\n\t  };\n\t}]);\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $ionicScrollDelegate\n\t * @module ionic\n\t * @description\n\t * Delegate for controlling scrollViews (created by\n\t * {@link ionic.directive:ionContent} and\n\t * {@link ionic.directive:ionScroll} directives).\n\t *\n\t * Methods called directly on the $ionicScrollDelegate service will control all scroll\n\t * views.  Use the {@link ionic.service:$ionicScrollDelegate#$getByHandle $getByHandle}\n\t * method to control specific scrollViews.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <body ng-controller=\"MainCtrl\">\n\t *   <ion-content>\n\t *     <button ng-click=\"scrollTop()\">Scroll to Top!</button>\n\t *   </ion-content>\n\t * </body>\n\t * ```\n\t * ```js\n\t * function MainCtrl($scope, $ionicScrollDelegate) {\n\t *   $scope.scrollTop = function() {\n\t *     $ionicScrollDelegate.scrollTop();\n\t *   };\n\t * }\n\t * ```\n\t *\n\t * Example of advanced usage, with two scroll areas using `delegate-handle`\n\t * for fine control.\n\t *\n\t * ```html\n\t * <body ng-controller=\"MainCtrl\">\n\t *   <ion-content delegate-handle=\"mainScroll\">\n\t *     <button ng-click=\"scrollMainToTop()\">\n\t *       Scroll content to top!\n\t *     </button>\n\t *     <ion-scroll delegate-handle=\"small\" style=\"height: 100px;\">\n\t *       <button ng-click=\"scrollSmallToTop()\">\n\t *         Scroll small area to top!\n\t *       </button>\n\t *     </ion-scroll>\n\t *   </ion-content>\n\t * </body>\n\t * ```\n\t * ```js\n\t * function MainCtrl($scope, $ionicScrollDelegate) {\n\t *   $scope.scrollMainToTop = function() {\n\t *     $ionicScrollDelegate.$getByHandle('mainScroll').scrollTop();\n\t *   };\n\t *   $scope.scrollSmallToTop = function() {\n\t *     $ionicScrollDelegate.$getByHandle('small').scrollTop();\n\t *   };\n\t * }\n\t * ```\n\t */\n\tIonicModule\n\t.service('$ionicScrollDelegate', ionic.DelegateService([\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#resize\n\t   * @description Tell the scrollView to recalculate the size of its container.\n\t   */\n\t  'resize',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#scrollTop\n\t   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n\t   */\n\t  'scrollTop',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#scrollBottom\n\t   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n\t   */\n\t  'scrollBottom',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#scrollTo\n\t   * @param {number} left The x-value to scroll to.\n\t   * @param {number} top The y-value to scroll to.\n\t   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n\t   */\n\t  'scrollTo',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#scrollBy\n\t   * @param {number} left The x-offset to scroll by.\n\t   * @param {number} top The y-offset to scroll by.\n\t   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n\t   */\n\t  'scrollBy',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#zoomTo\n\t   * @param {number} level Level to zoom to.\n\t   * @param {boolean=} animate Whether to animate the zoom.\n\t   * @param {number=} originLeft Zoom in at given left coordinate.\n\t   * @param {number=} originTop Zoom in at given top coordinate.\n\t   */\n\t  'zoomTo',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#zoomBy\n\t   * @param {number} factor The factor to zoom by.\n\t   * @param {boolean=} animate Whether to animate the zoom.\n\t   * @param {number=} originLeft Zoom in at given left coordinate.\n\t   * @param {number=} originTop Zoom in at given top coordinate.\n\t   */\n\t  'zoomBy',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#getScrollPosition\n\t   * @returns {object} The scroll position of this view, with the following properties:\n\t   *  - `{number}` `left` The distance the user has scrolled from the left (starts at 0).\n\t   *  - `{number}` `top` The distance the user has scrolled from the top (starts at 0).\n\t   */\n\t  'getScrollPosition',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#anchorScroll\n\t   * @description Tell the scrollView to scroll to the element with an id\n\t   * matching window.location.hash.\n\t   *\n\t   * If no matching element is found, it will scroll to top.\n\t   *\n\t   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n\t   */\n\t  'anchorScroll',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#freezeScroll\n\t   * @description Does not allow this scroll view to scroll either x or y.\n\t   * @param {boolean=} shouldFreeze Should this scroll view be prevented from scrolling or not.\n\t   * @returns {boolean} If the scroll view is being prevented from scrolling or not.\n\t   */\n\t  'freezeScroll',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#freezeAllScrolls\n\t   * @description Does not allow any of the app's scroll views to scroll either x or y.\n\t   * @param {boolean=} shouldFreeze Should all app scrolls be prevented from scrolling or not.\n\t   */\n\t  'freezeAllScrolls',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#getScrollView\n\t   * @returns {object} The scrollView associated with this delegate.\n\t   */\n\t  'getScrollView'\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicScrollDelegate#$getByHandle\n\t   * @param {string} handle\n\t   * @returns `delegateInstance` A delegate instance that controls only the\n\t   * scrollViews with `delegate-handle` matching the given handle.\n\t   *\n\t   * Example: `$ionicScrollDelegate.$getByHandle('my-handle').scrollTop();`\n\t   */\n\t]));\n\t\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicSideMenuDelegate\n\t * @module ionic\n\t *\n\t * @description\n\t * Delegate for controlling the {@link ionic.directive:ionSideMenus} directive.\n\t *\n\t * Methods called directly on the $ionicSideMenuDelegate service will control all side\n\t * menus.  Use the {@link ionic.service:$ionicSideMenuDelegate#$getByHandle $getByHandle}\n\t * method to control specific ionSideMenus instances.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <body ng-controller=\"MainCtrl\">\n\t *   <ion-side-menus>\n\t *     <ion-side-menu-content>\n\t *       Content!\n\t *       <button ng-click=\"toggleLeftSideMenu()\">\n\t *         Toggle Left Side Menu\n\t *       </button>\n\t *     </ion-side-menu-content>\n\t *     <ion-side-menu side=\"left\">\n\t *       Left Menu!\n\t *     <ion-side-menu>\n\t *   </ion-side-menus>\n\t * </body>\n\t * ```\n\t * ```js\n\t * function MainCtrl($scope, $ionicSideMenuDelegate) {\n\t *   $scope.toggleLeftSideMenu = function() {\n\t *     $ionicSideMenuDelegate.toggleLeft();\n\t *   };\n\t * }\n\t * ```\n\t */\n\tIonicModule\n\t.service('$ionicSideMenuDelegate', ionic.DelegateService([\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#toggleLeft\n\t   * @description Toggle the left side menu (if it exists).\n\t   * @param {boolean=} isOpen Whether to open or close the menu.\n\t   * Default: Toggles the menu.\n\t   */\n\t  'toggleLeft',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#toggleRight\n\t   * @description Toggle the right side menu (if it exists).\n\t   * @param {boolean=} isOpen Whether to open or close the menu.\n\t   * Default: Toggles the menu.\n\t   */\n\t  'toggleRight',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#getOpenRatio\n\t   * @description Gets the ratio of open amount over menu width. For example, a\n\t   * menu of width 100 that is opened by 50 pixels is 50% opened, and would return\n\t   * a ratio of 0.5.\n\t   *\n\t   * @returns {float} 0 if nothing is open, between 0 and 1 if left menu is\n\t   * opened/opening, and between 0 and -1 if right menu is opened/opening.\n\t   */\n\t  'getOpenRatio',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#isOpen\n\t   * @returns {boolean} Whether either the left or right menu is currently opened.\n\t   */\n\t  'isOpen',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#isOpenLeft\n\t   * @returns {boolean} Whether the left menu is currently opened.\n\t   */\n\t  'isOpenLeft',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#isOpenRight\n\t   * @returns {boolean} Whether the right menu is currently opened.\n\t   */\n\t  'isOpenRight',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#canDragContent\n\t   * @param {boolean=} canDrag Set whether the content can or cannot be dragged to open\n\t   * side menus.\n\t   * @returns {boolean} Whether the content can be dragged to open side menus.\n\t   */\n\t  'canDragContent',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#edgeDragThreshold\n\t   * @param {boolean|number=} value Set whether the content drag can only start if it is below a certain threshold distance from the edge of the screen. Accepts three different values:\n\t   *  - If a non-zero number is given, that many pixels is used as the maximum allowed distance from the edge that starts dragging the side menu.\n\t   *  - If true is given, the default number of pixels (25) is used as the maximum allowed distance.\n\t   *  - If false or 0 is given, the edge drag threshold is disabled, and dragging from anywhere on the content is allowed.\n\t   * @returns {boolean} Whether the drag can start only from within the edge of screen threshold.\n\t   */\n\t  'edgeDragThreshold'\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSideMenuDelegate#$getByHandle\n\t   * @param {string} handle\n\t   * @returns `delegateInstance` A delegate instance that controls only the\n\t   * {@link ionic.directive:ionSideMenus} directives with `delegate-handle` matching\n\t   * the given handle.\n\t   *\n\t   * Example: `$ionicSideMenuDelegate.$getByHandle('my-handle').toggleLeft();`\n\t   */\n\t]));\n\t\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicSlideBoxDelegate\n\t * @module ionic\n\t * @description\n\t * Delegate that controls the {@link ionic.directive:ionSlideBox} directive.\n\t *\n\t * Methods called directly on the $ionicSlideBoxDelegate service will control all slide boxes.  Use the {@link ionic.service:$ionicSlideBoxDelegate#$getByHandle $getByHandle}\n\t * method to control specific slide box instances.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <ion-view>\n\t *   <ion-slide-box>\n\t *     <ion-slide>\n\t *       <div class=\"box blue\">\n\t *         <button ng-click=\"nextSlide()\">Next slide!</button>\n\t *       </div>\n\t *     </ion-slide>\n\t *     <ion-slide>\n\t *       <div class=\"box red\">\n\t *         Slide 2!\n\t *       </div>\n\t *     </ion-slide>\n\t *   </ion-slide-box>\n\t * </ion-view>\n\t * ```\n\t * ```js\n\t * function MyCtrl($scope, $ionicSlideBoxDelegate) {\n\t *   $scope.nextSlide = function() {\n\t *     $ionicSlideBoxDelegate.next();\n\t *   }\n\t * }\n\t * ```\n\t */\n\tIonicModule\n\t.service('$ionicSlideBoxDelegate', ionic.DelegateService([\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#update\n\t   * @description\n\t   * Update the slidebox (for example if using Angular with ng-repeat,\n\t   * resize it for the elements inside).\n\t   */\n\t  'update',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#slide\n\t   * @param {number} to The index to slide to.\n\t   * @param {number=} speed The number of milliseconds the change should take.\n\t   */\n\t  'slide',\n\t  'select',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#enableSlide\n\t   * @param {boolean=} shouldEnable Whether to enable sliding the slidebox.\n\t   * @returns {boolean} Whether sliding is enabled.\n\t   */\n\t  'enableSlide',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#previous\n\t   * @param {number=} speed The number of milliseconds the change should take.\n\t   * @description Go to the previous slide. Wraps around if at the beginning.\n\t   */\n\t  'previous',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#next\n\t   * @param {number=} speed The number of milliseconds the change should take.\n\t   * @description Go to the next slide. Wraps around if at the end.\n\t   */\n\t  'next',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#stop\n\t   * @description Stop sliding. The slideBox will not move again until\n\t   * explicitly told to do so.\n\t   */\n\t  'stop',\n\t  'autoPlay',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#start\n\t   * @description Start sliding again if the slideBox was stopped.\n\t   */\n\t  'start',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#currentIndex\n\t   * @returns number The index of the current slide.\n\t   */\n\t  'currentIndex',\n\t  'selected',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#slidesCount\n\t   * @returns number The number of slides there are currently.\n\t   */\n\t  'slidesCount',\n\t  'count',\n\t  'loop'\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicSlideBoxDelegate#$getByHandle\n\t   * @param {string} handle\n\t   * @returns `delegateInstance` A delegate instance that controls only the\n\t   * {@link ionic.directive:ionSlideBox} directives with `delegate-handle` matching\n\t   * the given handle.\n\t   *\n\t   * Example: `$ionicSlideBoxDelegate.$getByHandle('my-handle').stop();`\n\t   */\n\t]));\n\t\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicTabsDelegate\n\t * @module ionic\n\t *\n\t * @description\n\t * Delegate for controlling the {@link ionic.directive:ionTabs} directive.\n\t *\n\t * Methods called directly on the $ionicTabsDelegate service will control all ionTabs\n\t * directives. Use the {@link ionic.service:$ionicTabsDelegate#$getByHandle $getByHandle}\n\t * method to control specific ionTabs instances.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <body ng-controller=\"MyCtrl\">\n\t *   <ion-tabs>\n\t *\n\t *     <ion-tab title=\"Tab 1\">\n\t *       Hello tab 1!\n\t *       <button ng-click=\"selectTabWithIndex(1)\">Select tab 2!</button>\n\t *     </ion-tab>\n\t *     <ion-tab title=\"Tab 2\">Hello tab 2!</ion-tab>\n\t *\n\t *   </ion-tabs>\n\t * </body>\n\t * ```\n\t * ```js\n\t * function MyCtrl($scope, $ionicTabsDelegate) {\n\t *   $scope.selectTabWithIndex = function(index) {\n\t *     $ionicTabsDelegate.select(index);\n\t *   }\n\t * }\n\t * ```\n\t */\n\tIonicModule\n\t.service('$ionicTabsDelegate', ionic.DelegateService([\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicTabsDelegate#select\n\t   * @description Select the tab matching the given index.\n\t   *\n\t   * @param {number} index Index of the tab to select.\n\t   */\n\t  'select',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicTabsDelegate#selectedIndex\n\t   * @returns `number` The index of the selected tab, or -1.\n\t   */\n\t  'selectedIndex',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicTabsDelegate#showBar\n\t   * @description\n\t   * Set/get whether the {@link ionic.directive:ionTabs} is shown\n\t   * @param {boolean} show Whether to show the bar.\n\t   * @returns {boolean} Whether the bar is shown.\n\t   */\n\t  'showBar'\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicTabsDelegate#$getByHandle\n\t   * @param {string} handle\n\t   * @returns `delegateInstance` A delegate instance that controls only the\n\t   * {@link ionic.directive:ionTabs} directives with `delegate-handle` matching\n\t   * the given handle.\n\t   *\n\t   * Example: `$ionicTabsDelegate.$getByHandle('my-handle').select(0);`\n\t   */\n\t]));\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t// closure to keep things neat\n\t(function() {\n\t  var templatesToCache = [];\n\t\n\t/**\n\t * @ngdoc service\n\t * @name $ionicTemplateCache\n\t * @module ionic\n\t * @description A service that preemptively caches template files to eliminate transition flicker and boost performance.\n\t * @usage\n\t * State templates are cached automatically, but you can optionally cache other templates.\n\t *\n\t * ```js\n\t * $ionicTemplateCache('myNgIncludeTemplate.html');\n\t * ```\n\t *\n\t * Optionally disable all preemptive caching with the `$ionicConfigProvider` or individual states by setting `prefetchTemplate`\n\t * in the `$state` definition\n\t *\n\t * ```js\n\t *   angular.module('myApp', ['ionic'])\n\t *   .config(function($stateProvider, $ionicConfigProvider) {\n\t *\n\t *     // disable preemptive template caching globally\n\t *     $ionicConfigProvider.templates.prefetch(false);\n\t *\n\t *     // disable individual states\n\t *     $stateProvider\n\t *       .state('tabs', {\n\t *         url: \"/tab\",\n\t *         abstract: true,\n\t *         prefetchTemplate: false,\n\t *         templateUrl: \"tabs-templates/tabs.html\"\n\t *       })\n\t *       .state('tabs.home', {\n\t *         url: \"/home\",\n\t *         views: {\n\t *           'home-tab': {\n\t *             prefetchTemplate: false,\n\t *             templateUrl: \"tabs-templates/home.html\",\n\t *             controller: 'HomeTabCtrl'\n\t *           }\n\t *         }\n\t *       });\n\t *   });\n\t * ```\n\t */\n\tIonicModule\n\t.factory('$ionicTemplateCache', [\n\t'$http',\n\t'$templateCache',\n\t'$timeout',\n\tfunction($http, $templateCache, $timeout) {\n\t  var toCache = templatesToCache,\n\t      hasRun;\n\t\n\t  function $ionicTemplateCache(templates) {\n\t    if (typeof templates === 'undefined') {\n\t      return run();\n\t    }\n\t    if (isString(templates)) {\n\t      templates = [templates];\n\t    }\n\t    forEach(templates, function(template) {\n\t      toCache.push(template);\n\t    });\n\t    if (hasRun) {\n\t      run();\n\t    }\n\t  }\n\t\n\t  // run through methods - internal method\n\t  function run() {\n\t    var template;\n\t    $ionicTemplateCache._runCount++;\n\t\n\t    hasRun = true;\n\t    // ignore if race condition already zeroed out array\n\t    if (toCache.length === 0) return;\n\t\n\t    var i = 0;\n\t    while (i < 4 && (template = toCache.pop())) {\n\t      // note that inline templates are ignored by this request\n\t      if (isString(template)) $http.get(template, { cache: $templateCache });\n\t      i++;\n\t    }\n\t    // only preload 3 templates a second\n\t    if (toCache.length) {\n\t      $timeout(run, 1000);\n\t    }\n\t  }\n\t\n\t  // exposing for testing\n\t  $ionicTemplateCache._runCount = 0;\n\t  // default method\n\t  return $ionicTemplateCache;\n\t}])\n\t\n\t// Intercepts the $stateprovider.state() command to look for templateUrls that can be cached\n\t.config([\n\t'$stateProvider',\n\t'$ionicConfigProvider',\n\tfunction($stateProvider, $ionicConfigProvider) {\n\t  var stateProviderState = $stateProvider.state;\n\t  $stateProvider.state = function(stateName, definition) {\n\t    // don't even bother if it's disabled. note, another config may run after this, so it's not a catch-all\n\t    if (typeof definition === 'object') {\n\t      var enabled = definition.prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();\n\t      if (enabled && isString(definition.templateUrl)) templatesToCache.push(definition.templateUrl);\n\t      if (angular.isObject(definition.views)) {\n\t        for (var key in definition.views) {\n\t          enabled = definition.views[key].prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();\n\t          if (enabled && isString(definition.views[key].templateUrl)) templatesToCache.push(definition.views[key].templateUrl);\n\t        }\n\t      }\n\t    }\n\t    return stateProviderState.call($stateProvider, stateName, definition);\n\t  };\n\t}])\n\t\n\t// process the templateUrls collected by the $stateProvider, adding them to the cache\n\t.run(['$ionicTemplateCache', function($ionicTemplateCache) {\n\t  $ionicTemplateCache();\n\t}]);\n\t\n\t})();\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.factory('$ionicTemplateLoader', [\n\t  '$compile',\n\t  '$controller',\n\t  '$http',\n\t  '$q',\n\t  '$rootScope',\n\t  '$templateCache',\n\tfunction($compile, $controller, $http, $q, $rootScope, $templateCache) {\n\t\n\t  return {\n\t    load: fetchTemplate,\n\t    compile: loadAndCompile\n\t  };\n\t\n\t  function fetchTemplate(url) {\n\t    return $http.get(url, {cache: $templateCache})\n\t    .then(function(response) {\n\t      return response.data && response.data.trim();\n\t    });\n\t  }\n\t\n\t  function loadAndCompile(options) {\n\t    options = extend({\n\t      template: '',\n\t      templateUrl: '',\n\t      scope: null,\n\t      controller: null,\n\t      locals: {},\n\t      appendTo: null\n\t    }, options || {});\n\t\n\t    var templatePromise = options.templateUrl ?\n\t      this.load(options.templateUrl) :\n\t      $q.when(options.template);\n\t\n\t    return templatePromise.then(function(template) {\n\t      var controller;\n\t      var scope = options.scope || $rootScope.$new();\n\t\n\t      //Incase template doesn't have just one root element, do this\n\t      var element = jqLite('<div>').html(template).contents();\n\t\n\t      if (options.controller) {\n\t        controller = $controller(\n\t          options.controller,\n\t          extend(options.locals, {\n\t            $scope: scope\n\t          })\n\t        );\n\t        element.children().data('$ngControllerController', controller);\n\t      }\n\t      if (options.appendTo) {\n\t        jqLite(options.appendTo).append(element);\n\t      }\n\t\n\t      $compile(element)(scope);\n\t\n\t      return {\n\t        element: element,\n\t        scope: scope\n\t      };\n\t    });\n\t  }\n\t\n\t}]);\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @private\n\t * DEPRECATED, as of v1.0.0-beta14 -------\n\t */\n\tIonicModule\n\t.factory('$ionicViewService', ['$ionicHistory', '$log', function($ionicHistory, $log) {\n\t\n\t  function warn(oldMethod, newMethod) {\n\t    $log.warn('$ionicViewService' + oldMethod + ' is deprecated, please use $ionicHistory' + newMethod + ' instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/');\n\t  }\n\t\n\t  warn('', '');\n\t\n\t  var methodsMap = {\n\t    getCurrentView: 'currentView',\n\t    getBackView: 'backView',\n\t    getForwardView: 'forwardView',\n\t    getCurrentStateName: 'currentStateName',\n\t    nextViewOptions: 'nextViewOptions',\n\t    clearHistory: 'clearHistory'\n\t  };\n\t\n\t  forEach(methodsMap, function(newMethod, oldMethod) {\n\t    methodsMap[oldMethod] = function() {\n\t      warn('.' + oldMethod, '.' + newMethod);\n\t      return $ionicHistory[newMethod].apply(this, arguments);\n\t    };\n\t  });\n\t\n\t  return methodsMap;\n\t\n\t}]);\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @private\r\n\t * TODO document\r\n\t */\r\n\t\r\n\tIonicModule.factory('$ionicViewSwitcher', [\r\n\t  '$timeout',\r\n\t  '$document',\r\n\t  '$q',\r\n\t  '$ionicClickBlock',\r\n\t  '$ionicConfig',\r\n\t  '$ionicNavBarDelegate',\r\n\tfunction($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {\r\n\t\r\n\t  var TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\r\n\t  var DATA_NO_CACHE = '$noCache';\r\n\t  var DATA_DESTROY_ELE = '$destroyEle';\r\n\t  var DATA_ELE_IDENTIFIER = '$eleId';\r\n\t  var DATA_VIEW_ACCESSED = '$accessed';\r\n\t  var DATA_FALLBACK_TIMER = '$fallbackTimer';\r\n\t  var DATA_VIEW = '$viewData';\r\n\t  var NAV_VIEW_ATTR = 'nav-view';\r\n\t  var VIEW_STATUS_ACTIVE = 'active';\r\n\t  var VIEW_STATUS_CACHED = 'cached';\r\n\t  var VIEW_STATUS_STAGED = 'stage';\r\n\t\r\n\t  var transitionCounter = 0;\r\n\t  var nextTransition, nextDirection;\r\n\t  ionic.transition = ionic.transition || {};\r\n\t  ionic.transition.isActive = false;\r\n\t  var isActiveTimer;\r\n\t  var cachedAttr = ionic.DomUtil.cachedAttr;\r\n\t  var transitionPromises = [];\r\n\t  var defaultTimeout = 1100;\r\n\t\r\n\t  var ionicViewSwitcher = {\r\n\t\r\n\t    create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {\r\n\t      // get a reference to an entering/leaving element if they exist\r\n\t      // loop through to see if the view is already in the navViewElement\r\n\t      var enteringEle, leavingEle;\r\n\t      var transitionId = ++transitionCounter;\r\n\t      var alreadyInDom;\r\n\t\r\n\t      var switcher = {\r\n\t\r\n\t        init: function(registerData, callback) {\r\n\t          ionicViewSwitcher.isTransitioning(true);\r\n\t\r\n\t          switcher.loadViewElements(registerData);\r\n\t\r\n\t          switcher.render(registerData, function() {\r\n\t            callback && callback();\r\n\t          });\r\n\t        },\r\n\t\r\n\t        loadViewElements: function(registerData) {\r\n\t          var x, l, viewEle;\r\n\t          var viewElements = navViewCtrl.getViewElements();\r\n\t          var enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView);\r\n\t          var navViewActiveEleId = navViewCtrl.activeEleId();\r\n\t\r\n\t          for (x = 0, l = viewElements.length; x < l; x++) {\r\n\t            viewEle = viewElements.eq(x);\r\n\t\r\n\t            if (viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier) {\r\n\t              // we found an existing element in the DOM that should be entering the view\r\n\t              if (viewEle.data(DATA_NO_CACHE)) {\r\n\t                // the existing element should not be cached, don't use it\r\n\t                viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid());\r\n\t                viewEle.data(DATA_DESTROY_ELE, true);\r\n\t\r\n\t              } else {\r\n\t                enteringEle = viewEle;\r\n\t              }\r\n\t\r\n\t            } else if (isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId) {\r\n\t              leavingEle = viewEle;\r\n\t            }\r\n\t\r\n\t            if (enteringEle && leavingEle) break;\r\n\t          }\r\n\t\r\n\t          alreadyInDom = !!enteringEle;\r\n\t\r\n\t          if (!alreadyInDom) {\r\n\t            // still no existing element to use\r\n\t            // create it using existing template/scope/locals\r\n\t            enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals);\r\n\t\r\n\t            // existing elements in the DOM are looked up by their state name and state id\r\n\t            enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier);\r\n\t          }\r\n\t\r\n\t          if (renderEnd) {\r\n\t            navViewCtrl.activeEleId(enteringEleIdentifier);\r\n\t          }\r\n\t\r\n\t          registerData.ele = null;\r\n\t        },\r\n\t\r\n\t        render: function(registerData, callback) {\r\n\t          if (alreadyInDom) {\r\n\t            // it was already found in the DOM, just reconnect the scope\r\n\t            ionic.Utils.reconnectScope(enteringEle.scope());\r\n\t\r\n\t          } else {\r\n\t            // the entering element is not already in the DOM\r\n\t            // set that the entering element should be \"staged\" and its\r\n\t            // styles of where this element will go before it hits the DOM\r\n\t            navViewAttr(enteringEle, VIEW_STATUS_STAGED);\r\n\t\r\n\t            var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView);\r\n\t            var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;\r\n\t            transitionFn(enteringEle, null, enteringData.direction, true).run(0);\r\n\t\r\n\t            enteringEle.data(DATA_VIEW, {\r\n\t              viewId: enteringData.viewId,\r\n\t              historyId: enteringData.historyId,\r\n\t              stateName: enteringData.stateName,\r\n\t              stateParams: enteringData.stateParams\r\n\t            });\r\n\t\r\n\t            // if the current state has cache:false\r\n\t            // or the element has cache-view=\"false\" attribute\r\n\t            if (viewState(viewLocals).cache === false || viewState(viewLocals).cache === 'false' ||\r\n\t                enteringEle.attr('cache-view') == 'false' || $ionicConfig.views.maxCache() === 0) {\r\n\t              enteringEle.data(DATA_NO_CACHE, true);\r\n\t            }\r\n\t\r\n\t            // append the entering element to the DOM, create a new scope and run link\r\n\t            var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);\r\n\t\r\n\t            delete enteringData.direction;\r\n\t            delete enteringData.transition;\r\n\t            viewScope.$emit('$ionicView.loaded', enteringData);\r\n\t          }\r\n\t\r\n\t          // update that this view was just accessed\r\n\t          enteringEle.data(DATA_VIEW_ACCESSED, Date.now());\r\n\t\r\n\t          callback && callback();\r\n\t        },\r\n\t\r\n\t        transition: function(direction, enableBack, allowAnimate) {\r\n\t          var deferred;\r\n\t          var enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView);\r\n\t          var leavingData = extend(extend({}, enteringData), getViewData(leavingView));\r\n\t          enteringData.transitionId = leavingData.transitionId = transitionId;\r\n\t          enteringData.fromCache = !!alreadyInDom;\r\n\t          enteringData.enableBack = !!enableBack;\r\n\t          enteringData.renderStart = renderStart;\r\n\t          enteringData.renderEnd = renderEnd;\r\n\t\r\n\t          cachedAttr(enteringEle.parent(), 'nav-view-transition', enteringData.transition);\r\n\t          cachedAttr(enteringEle.parent(), 'nav-view-direction', enteringData.direction);\r\n\t\r\n\t          // cancel any previous transition complete fallbacks\r\n\t          $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));\r\n\t\r\n\t          // get the transition ready and see if it'll animate\r\n\t          var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;\r\n\t          var viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction,\r\n\t                                            enteringData.shouldAnimate && allowAnimate && renderEnd);\r\n\t\r\n\t          if (viewTransition.shouldAnimate) {\r\n\t            // attach transitionend events (and fallback timer)\r\n\t            enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd);\r\n\t            enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout));\r\n\t            $ionicClickBlock.show(defaultTimeout);\r\n\t          }\r\n\t\r\n\t          if (renderStart) {\r\n\t            // notify the views \"before\" the transition starts\r\n\t            switcher.emit('before', enteringData, leavingData);\r\n\t\r\n\t            // stage entering element, opacity 0, no transition duration\r\n\t            navViewAttr(enteringEle, VIEW_STATUS_STAGED);\r\n\t\r\n\t            // render the elements in the correct location for their starting point\r\n\t            viewTransition.run(0);\r\n\t          }\r\n\t\r\n\t          if (renderEnd) {\r\n\t            // create a promise so we can keep track of when all transitions finish\r\n\t            // only required if this transition should complete\r\n\t            deferred = $q.defer();\r\n\t            transitionPromises.push(deferred.promise);\r\n\t          }\r\n\t\r\n\t          if (renderStart && renderEnd) {\r\n\t            // CSS \"auto\" transitioned, not manually transitioned\r\n\t            // wait a frame so the styles apply before auto transitioning\r\n\t            $timeout(function() {\r\n\t              ionic.requestAnimationFrame(onReflow);\r\n\t            });\r\n\t          } else if (!renderEnd) {\r\n\t            // just the start of a manual transition\r\n\t            // but it will not render the end of the transition\r\n\t            navViewAttr(enteringEle, 'entering');\r\n\t            navViewAttr(leavingEle, 'leaving');\r\n\t\r\n\t            // return the transition run method so each step can be ran manually\r\n\t            return {\r\n\t              run: viewTransition.run,\r\n\t              cancel: function(shouldAnimate) {\r\n\t                if (shouldAnimate) {\r\n\t                  enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd);\r\n\t                  enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout));\r\n\t                  $ionicClickBlock.show(defaultTimeout);\r\n\t                } else {\r\n\t                  cancelTransition();\r\n\t                }\r\n\t                viewTransition.shouldAnimate = shouldAnimate;\r\n\t                viewTransition.run(0);\r\n\t                viewTransition = null;\r\n\t              }\r\n\t            };\r\n\t\r\n\t          } else if (renderEnd) {\r\n\t            // just the end of a manual transition\r\n\t            // happens after the manual transition has completed\r\n\t            // and a full history change has happened\r\n\t            onReflow();\r\n\t          }\r\n\t\r\n\t\r\n\t          function onReflow() {\r\n\t            // remove that we're staging the entering element so it can auto transition\r\n\t            navViewAttr(enteringEle, viewTransition.shouldAnimate ? 'entering' : VIEW_STATUS_ACTIVE);\r\n\t            navViewAttr(leavingEle, viewTransition.shouldAnimate ? 'leaving' : VIEW_STATUS_CACHED);\r\n\t\r\n\t            // start the auto transition and let the CSS take over\r\n\t            viewTransition.run(1);\r\n\t\r\n\t            // trigger auto transitions on the associated nav bars\r\n\t            $ionicNavBarDelegate._instances.forEach(function(instance) {\r\n\t              instance.triggerTransitionStart(transitionId);\r\n\t            });\r\n\t\r\n\t            if (!viewTransition.shouldAnimate) {\r\n\t              // no animated auto transition\r\n\t              transitionComplete();\r\n\t            }\r\n\t          }\r\n\t\r\n\t          // Make sure that transitionend events bubbling up from children won't fire\r\n\t          // transitionComplete. Will only go forward if ev.target == the element listening.\r\n\t          function completeOnTransitionEnd(ev) {\r\n\t            if (ev.target !== this) return;\r\n\t            transitionComplete();\r\n\t          }\r\n\t          function transitionComplete() {\r\n\t            if (transitionComplete.x) return;\r\n\t            transitionComplete.x = true;\r\n\t\r\n\t            enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd);\r\n\t            $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));\r\n\t            leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER));\r\n\t\r\n\t            // resolve that this one transition (there could be many w/ nested views)\r\n\t            deferred && deferred.resolve(navViewCtrl);\r\n\t\r\n\t            // the most recent transition added has completed and all the active\r\n\t            // transition promises should be added to the services array of promises\r\n\t            if (transitionId === transitionCounter) {\r\n\t              $q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd);\r\n\t\r\n\t              // emit that the views have finished transitioning\r\n\t              // each parent nav-view will update which views are active and cached\r\n\t              switcher.emit('after', enteringData, leavingData);\r\n\t              switcher.cleanup(enteringData);\r\n\t            }\r\n\t\r\n\t            // tell the nav bars that the transition has ended\r\n\t            $ionicNavBarDelegate._instances.forEach(function(instance) {\r\n\t              instance.triggerTransitionEnd();\r\n\t            });\r\n\t\r\n\t\r\n\t            // remove any references that could cause memory issues\r\n\t            nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null;\r\n\t          }\r\n\t\r\n\t          // Make sure that transitionend events bubbling up from children won't fire\r\n\t          // transitionComplete. Will only go forward if ev.target == the element listening.\r\n\t          function cancelOnTransitionEnd(ev) {\r\n\t            if (ev.target !== this) return;\r\n\t            cancelTransition();\r\n\t          }\r\n\t          function cancelTransition() {\r\n\t            navViewAttr(enteringEle, VIEW_STATUS_CACHED);\r\n\t            navViewAttr(leavingEle, VIEW_STATUS_ACTIVE);\r\n\t            enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd);\r\n\t            $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));\r\n\t            ionicViewSwitcher.transitionEnd([navViewCtrl]);\r\n\t          }\r\n\t\r\n\t        },\r\n\t\r\n\t        emit: function(step, enteringData, leavingData) {\r\n\t          var enteringScope = enteringEle.scope(),\r\n\t            leavingScope = leavingEle && leavingEle.scope();\r\n\t\r\n\t          if (step == 'after') {\r\n\t            if (enteringScope) {\r\n\t              enteringScope.$emit('$ionicView.enter', enteringData);\r\n\t            }\r\n\t\r\n\t            if (leavingScope) {\r\n\t              leavingScope.$emit('$ionicView.leave', leavingData);\r\n\t\r\n\t            } else if (enteringScope && leavingData && leavingData.viewId) {\r\n\t              enteringScope.$emit('$ionicNavView.leave', leavingData);\r\n\t            }\r\n\t          }\r\n\t\r\n\t          if (enteringScope) {\r\n\t            enteringScope.$emit('$ionicView.' + step + 'Enter', enteringData);\r\n\t          }\r\n\t\r\n\t          if (leavingScope) {\r\n\t            leavingScope.$emit('$ionicView.' + step + 'Leave', leavingData);\r\n\t\r\n\t          } else if (enteringScope && leavingData && leavingData.viewId) {\r\n\t            enteringScope.$emit('$ionicNavView.' + step + 'Leave', leavingData);\r\n\t          }\r\n\t        },\r\n\t\r\n\t        cleanup: function(transData) {\r\n\t          // check if any views should be removed\r\n\t          if (leavingEle && transData.direction == 'back' && !$ionicConfig.views.forwardCache()) {\r\n\t            // if they just navigated back we can destroy the forward view\r\n\t            // do not remove forward views if cacheForwardViews config is true\r\n\t            destroyViewEle(leavingEle);\r\n\t          }\r\n\t\r\n\t          var viewElements = navViewCtrl.getViewElements();\r\n\t          var viewElementsLength = viewElements.length;\r\n\t          var x, viewElement;\r\n\t          var removeOldestAccess = (viewElementsLength - 1) > $ionicConfig.views.maxCache();\r\n\t          var removableEle;\r\n\t          var oldestAccess = Date.now();\r\n\t\r\n\t          for (x = 0; x < viewElementsLength; x++) {\r\n\t            viewElement = viewElements.eq(x);\r\n\t\r\n\t            if (removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess) {\r\n\t              // remember what was the oldest element to be accessed so it can be destroyed\r\n\t              oldestAccess = viewElement.data(DATA_VIEW_ACCESSED);\r\n\t              removableEle = viewElements.eq(x);\r\n\t\r\n\t            } else if (viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE) {\r\n\t              destroyViewEle(viewElement);\r\n\t            }\r\n\t          }\r\n\t\r\n\t          destroyViewEle(removableEle);\r\n\t\r\n\t          if (enteringEle.data(DATA_NO_CACHE)) {\r\n\t            enteringEle.data(DATA_DESTROY_ELE, true);\r\n\t          }\r\n\t        },\r\n\t\r\n\t        enteringEle: function() { return enteringEle; },\r\n\t        leavingEle: function() { return leavingEle; }\r\n\t\r\n\t      };\r\n\t\r\n\t      return switcher;\r\n\t    },\r\n\t\r\n\t    transitionEnd: function(navViewCtrls) {\r\n\t      forEach(navViewCtrls, function(navViewCtrl) {\r\n\t        navViewCtrl.transitionEnd();\r\n\t      });\r\n\t\r\n\t      ionicViewSwitcher.isTransitioning(false);\r\n\t      $ionicClickBlock.hide();\r\n\t      transitionPromises = [];\r\n\t    },\r\n\t\r\n\t    nextTransition: function(val) {\r\n\t      nextTransition = val;\r\n\t    },\r\n\t\r\n\t    nextDirection: function(val) {\r\n\t      nextDirection = val;\r\n\t    },\r\n\t\r\n\t    isTransitioning: function(val) {\r\n\t      if (arguments.length) {\r\n\t        ionic.transition.isActive = !!val;\r\n\t        $timeout.cancel(isActiveTimer);\r\n\t        if (val) {\r\n\t          isActiveTimer = $timeout(function() {\r\n\t            ionicViewSwitcher.isTransitioning(false);\r\n\t          }, 999);\r\n\t        }\r\n\t      }\r\n\t      return ionic.transition.isActive;\r\n\t    },\r\n\t\r\n\t    createViewEle: function(viewLocals) {\r\n\t      var containerEle = $document[0].createElement('div');\r\n\t      if (viewLocals && viewLocals.$template) {\r\n\t        containerEle.innerHTML = viewLocals.$template;\r\n\t        if (containerEle.children.length === 1) {\r\n\t          containerEle.children[0].classList.add('pane');\r\n\t          return jqLite(containerEle.children[0]);\r\n\t        }\r\n\t      }\r\n\t      containerEle.className = \"pane\";\r\n\t      return jqLite(containerEle);\r\n\t    },\r\n\t\r\n\t    viewEleIsActive: function(viewEle, isActiveAttr) {\r\n\t      navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);\r\n\t    },\r\n\t\r\n\t    getTransitionData: getTransitionData,\r\n\t    navViewAttr: navViewAttr,\r\n\t    destroyViewEle: destroyViewEle\r\n\t\r\n\t  };\r\n\t\r\n\t  return ionicViewSwitcher;\r\n\t\r\n\t\r\n\t  function getViewElementIdentifier(locals, view) {\r\n\t    if (viewState(locals)['abstract']) return viewState(locals).name;\r\n\t    if (view) return view.stateId || view.viewId;\r\n\t    return ionic.Utils.nextUid();\r\n\t  }\r\n\t\r\n\t  function viewState(locals) {\r\n\t    return locals && locals.$$state && locals.$$state.self || {};\r\n\t  }\r\n\t\r\n\t  function getTransitionData(viewLocals, enteringEle, direction, view) {\r\n\t    // Priority\r\n\t    // 1) attribute directive on the button/link to this view\r\n\t    // 2) entering element's attribute\r\n\t    // 3) entering view's $state config property\r\n\t    // 4) view registration data\r\n\t    // 5) global config\r\n\t    // 6) fallback value\r\n\t\r\n\t    var state = viewState(viewLocals);\r\n\t    var viewTransition = nextTransition || cachedAttr(enteringEle, 'view-transition') || state.viewTransition || $ionicConfig.views.transition() || 'ios';\r\n\t    var navBarTransition = $ionicConfig.navBar.transition();\r\n\t    direction = nextDirection || cachedAttr(enteringEle, 'view-direction') || state.viewDirection || direction || 'none';\r\n\t\r\n\t    return extend(getViewData(view), {\r\n\t      transition: viewTransition,\r\n\t      navBarTransition: navBarTransition === 'view' ? viewTransition : navBarTransition,\r\n\t      direction: direction,\r\n\t      shouldAnimate: (viewTransition !== 'none' && direction !== 'none')\r\n\t    });\r\n\t  }\r\n\t\r\n\t  function getViewData(view) {\r\n\t    view = view || {};\r\n\t    return {\r\n\t      viewId: view.viewId,\r\n\t      historyId: view.historyId,\r\n\t      stateId: view.stateId,\r\n\t      stateName: view.stateName,\r\n\t      stateParams: view.stateParams\r\n\t    };\r\n\t  }\r\n\t\r\n\t  function navViewAttr(ele, value) {\r\n\t    if (arguments.length > 1) {\r\n\t      cachedAttr(ele, NAV_VIEW_ATTR, value);\r\n\t    } else {\r\n\t      return cachedAttr(ele, NAV_VIEW_ATTR);\r\n\t    }\r\n\t  }\r\n\t\r\n\t  function destroyViewEle(ele) {\r\n\t    // we found an element that should be removed\r\n\t    // destroy its scope, then remove the element\r\n\t    if (ele && ele.length) {\r\n\t      var viewScope = ele.scope();\r\n\t      if (viewScope) {\r\n\t        viewScope.$emit('$ionicView.unloaded', ele.data(DATA_VIEW));\r\n\t        viewScope.$destroy();\r\n\t      }\r\n\t      ele.remove();\r\n\t    }\r\n\t  }\r\n\t\r\n\t}]);\r\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t\n\t.controller('$ionicHeaderBar', [\n\t  '$scope',\n\t  '$element',\n\t  '$attrs',\n\t  '$q',\n\t  '$ionicConfig',\n\t  '$ionicHistory',\n\tfunction($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {\n\t  var TITLE = 'title';\n\t  var BACK_TEXT = 'back-text';\n\t  var BACK_BUTTON = 'back-button';\n\t  var DEFAULT_TITLE = 'default-title';\n\t  var PREVIOUS_TITLE = 'previous-title';\n\t  var HIDE = 'hide';\n\t\n\t  var self = this;\n\t  var titleText = '';\n\t  var previousTitleText = '';\n\t  var titleLeft = 0;\n\t  var titleRight = 0;\n\t  var titleCss = '';\n\t  var isBackEnabled = false;\n\t  var isBackShown = true;\n\t  var isNavBackShown = true;\n\t  var isBackElementShown = false;\n\t  var titleTextWidth = 0;\n\t\n\t\n\t  self.beforeEnter = function(viewData) {\n\t    $scope.$broadcast('$ionicView.beforeEnter', viewData);\n\t  };\n\t\n\t\n\t  self.title = function(newTitleText) {\n\t    if (arguments.length && newTitleText !== titleText) {\n\t      getEle(TITLE).innerHTML = newTitleText;\n\t      titleText = newTitleText;\n\t      titleTextWidth = 0;\n\t    }\n\t    return titleText;\n\t  };\n\t\n\t\n\t  self.enableBack = function(shouldEnable, disableReset) {\n\t    // whether or not the back button show be visible, according\n\t    // to the navigation and history\n\t    if (arguments.length) {\n\t      isBackEnabled = shouldEnable;\n\t      if (!disableReset) self.updateBackButton();\n\t    }\n\t    return isBackEnabled;\n\t  };\n\t\n\t\n\t  self.showBack = function(shouldShow, disableReset) {\n\t    // different from enableBack() because this will always have the back\n\t    // visually hidden if false, even if the history says it should show\n\t    if (arguments.length) {\n\t      isBackShown = shouldShow;\n\t      if (!disableReset) self.updateBackButton();\n\t    }\n\t    return isBackShown;\n\t  };\n\t\n\t\n\t  self.showNavBack = function(shouldShow) {\n\t    // different from showBack() because this is for the entire nav bar's\n\t    // setting for all of it's child headers. For internal use.\n\t    isNavBackShown = shouldShow;\n\t    self.updateBackButton();\n\t  };\n\t\n\t\n\t  self.updateBackButton = function() {\n\t    var ele;\n\t    if ((isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown) {\n\t      isBackElementShown = isBackShown && isNavBackShown && isBackEnabled;\n\t      ele = getEle(BACK_BUTTON);\n\t      ele && ele.classList[ isBackElementShown ? 'remove' : 'add' ](HIDE);\n\t    }\n\t\n\t    if (isBackEnabled) {\n\t      ele = ele || getEle(BACK_BUTTON);\n\t      if (ele) {\n\t        if (self.backButtonIcon !== $ionicConfig.backButton.icon()) {\n\t          ele = getEle(BACK_BUTTON + ' .icon');\n\t          if (ele) {\n\t            self.backButtonIcon = $ionicConfig.backButton.icon();\n\t            ele.className = 'icon ' + self.backButtonIcon;\n\t          }\n\t        }\n\t\n\t        if (self.backButtonText !== $ionicConfig.backButton.text()) {\n\t          ele = getEle(BACK_BUTTON + ' .back-text');\n\t          if (ele) {\n\t            ele.textContent = self.backButtonText = $ionicConfig.backButton.text();\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t\n\t  self.titleTextWidth = function() {\n\t    if (!titleTextWidth) {\n\t      var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));\n\t      titleTextWidth = Math.min(bounds && bounds.width || 30);\n\t    }\n\t    return titleTextWidth;\n\t  };\n\t\n\t\n\t  self.titleWidth = function() {\n\t    var titleWidth = self.titleTextWidth();\n\t    var offsetWidth = getEle(TITLE).offsetWidth;\n\t    if (offsetWidth < titleWidth) {\n\t      titleWidth = offsetWidth + (titleLeft - titleRight - 5);\n\t    }\n\t    return titleWidth;\n\t  };\n\t\n\t\n\t  self.titleTextX = function() {\n\t    return ($element[0].offsetWidth / 2) - (self.titleWidth() / 2);\n\t  };\n\t\n\t\n\t  self.titleLeftRight = function() {\n\t    return titleLeft - titleRight;\n\t  };\n\t\n\t\n\t  self.backButtonTextLeft = function() {\n\t    var offsetLeft = 0;\n\t    var ele = getEle(BACK_TEXT);\n\t    while (ele) {\n\t      offsetLeft += ele.offsetLeft;\n\t      ele = ele.parentElement;\n\t    }\n\t    return offsetLeft;\n\t  };\n\t\n\t\n\t  self.resetBackButton = function(viewData) {\n\t    if ($ionicConfig.backButton.previousTitleText()) {\n\t      var previousTitleEle = getEle(PREVIOUS_TITLE);\n\t      if (previousTitleEle) {\n\t        previousTitleEle.classList.remove(HIDE);\n\t\n\t        var view = (viewData && $ionicHistory.getViewById(viewData.viewId));\n\t        var newPreviousTitleText = $ionicHistory.backTitle(view);\n\t\n\t        if (newPreviousTitleText !== previousTitleText) {\n\t          previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText;\n\t        }\n\t      }\n\t      var defaultTitleEle = getEle(DEFAULT_TITLE);\n\t      if (defaultTitleEle) {\n\t        defaultTitleEle.classList.remove(HIDE);\n\t      }\n\t    }\n\t  };\n\t\n\t\n\t  self.align = function(textAlign) {\n\t    var titleEle = getEle(TITLE);\n\t\n\t    textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();\n\t\n\t    var widths = self.calcWidths(textAlign, false);\n\t\n\t    if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {\n\t      var previousTitleWidths = self.calcWidths(textAlign, true);\n\t\n\t      var availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;\n\t\n\t      if (self.titleTextWidth() <= availableTitleWidth) {\n\t        widths = previousTitleWidths;\n\t      }\n\t    }\n\t\n\t    return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);\n\t  };\n\t\n\t\n\t  self.calcWidths = function(textAlign, isPreviousTitle) {\n\t    var titleEle = getEle(TITLE);\n\t    var backBtnEle = getEle(BACK_BUTTON);\n\t    var x, y, z, b, c, d, childSize, bounds;\n\t    var childNodes = $element[0].childNodes;\n\t    var buttonsLeft = 0;\n\t    var buttonsRight = 0;\n\t    var isCountRightOfTitle;\n\t    var updateTitleLeft = 0;\n\t    var updateTitleRight = 0;\n\t    var updateCss = '';\n\t    var backButtonWidth = 0;\n\t\n\t    // Compute how wide the left children are\n\t    // Skip all titles (there may still be two titles, one leaving the dom)\n\t    // Once we encounter a titleEle, realize we are now counting the right-buttons, not left\n\t    for (x = 0; x < childNodes.length; x++) {\n\t      c = childNodes[x];\n\t\n\t      childSize = 0;\n\t      if (c.nodeType == 1) {\n\t        // element node\n\t        if (c === titleEle) {\n\t          isCountRightOfTitle = true;\n\t          continue;\n\t        }\n\t\n\t        if (c.classList.contains(HIDE)) {\n\t          continue;\n\t        }\n\t\n\t        if (isBackShown && c === backBtnEle) {\n\t\n\t          for (y = 0; y < c.childNodes.length; y++) {\n\t            b = c.childNodes[y];\n\t\n\t            if (b.nodeType == 1) {\n\t\n\t              if (b.classList.contains(BACK_TEXT)) {\n\t                for (z = 0; z < b.children.length; z++) {\n\t                  d = b.children[z];\n\t\n\t                  if (isPreviousTitle) {\n\t                    if (d.classList.contains(DEFAULT_TITLE)) continue;\n\t                    backButtonWidth += d.offsetWidth;\n\t                  } else {\n\t                    if (d.classList.contains(PREVIOUS_TITLE)) continue;\n\t                    backButtonWidth += d.offsetWidth;\n\t                  }\n\t                }\n\t\n\t              } else {\n\t                backButtonWidth += b.offsetWidth;\n\t              }\n\t\n\t            } else if (b.nodeType == 3 && b.nodeValue.trim()) {\n\t              bounds = ionic.DomUtil.getTextBounds(b);\n\t              backButtonWidth += bounds && bounds.width || 0;\n\t            }\n\t\n\t          }\n\t          childSize = backButtonWidth || c.offsetWidth;\n\t\n\t        } else {\n\t          // not the title, not the back button, not a hidden element\n\t          childSize = c.offsetWidth;\n\t        }\n\t\n\t      } else if (c.nodeType == 3 && c.nodeValue.trim()) {\n\t        // text node\n\t        bounds = ionic.DomUtil.getTextBounds(c);\n\t        childSize = bounds && bounds.width || 0;\n\t      }\n\t\n\t      if (isCountRightOfTitle) {\n\t        buttonsRight += childSize;\n\t      } else {\n\t        buttonsLeft += childSize;\n\t      }\n\t    }\n\t\n\t    // Size and align the header titleEle based on the sizes of the left and\n\t    // right children, and the desired alignment mode\n\t    if (textAlign == 'left') {\n\t      updateCss = 'title-left';\n\t      if (buttonsLeft) {\n\t        updateTitleLeft = buttonsLeft + 15;\n\t      }\n\t      if (buttonsRight) {\n\t        updateTitleRight = buttonsRight + 15;\n\t      }\n\t\n\t    } else if (textAlign == 'right') {\n\t      updateCss = 'title-right';\n\t      if (buttonsLeft) {\n\t        updateTitleLeft = buttonsLeft + 15;\n\t      }\n\t      if (buttonsRight) {\n\t        updateTitleRight = buttonsRight + 15;\n\t      }\n\t\n\t    } else {\n\t      // center the default\n\t      var margin = Math.max(buttonsLeft, buttonsRight) + 10;\n\t      if (margin > 10) {\n\t        updateTitleLeft = updateTitleRight = margin;\n\t      }\n\t    }\n\t\n\t    return {\n\t      backButtonWidth: backButtonWidth,\n\t      buttonsLeft: buttonsLeft,\n\t      buttonsRight: buttonsRight,\n\t      titleLeft: updateTitleLeft,\n\t      titleRight: updateTitleRight,\n\t      showPrevTitle: isPreviousTitle,\n\t      css: updateCss\n\t    };\n\t  };\n\t\n\t\n\t  self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {\n\t    var deferred = $q.defer();\n\t\n\t    // only make DOM updates when there are actual changes\n\t    if (titleEle) {\n\t      if (updateTitleLeft !== titleLeft) {\n\t        titleEle.style.left = updateTitleLeft ? updateTitleLeft + 'px' : '';\n\t        titleLeft = updateTitleLeft;\n\t      }\n\t      if (updateTitleRight !== titleRight) {\n\t        titleEle.style.right = updateTitleRight ? updateTitleRight + 'px' : '';\n\t        titleRight = updateTitleRight;\n\t      }\n\t\n\t      if (updateCss !== titleCss) {\n\t        updateCss && titleEle.classList.add(updateCss);\n\t        titleCss && titleEle.classList.remove(titleCss);\n\t        titleCss = updateCss;\n\t      }\n\t    }\n\t\n\t    if ($ionicConfig.backButton.previousTitleText()) {\n\t      var prevTitle = getEle(PREVIOUS_TITLE);\n\t      var defaultTitle = getEle(DEFAULT_TITLE);\n\t\n\t      prevTitle && prevTitle.classList[ showPreviousTitle ? 'remove' : 'add'](HIDE);\n\t      defaultTitle && defaultTitle.classList[ showPreviousTitle ? 'add' : 'remove'](HIDE);\n\t    }\n\t\n\t    ionic.requestAnimationFrame(function() {\n\t      if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {\n\t        var minRight = buttonsRight + 5;\n\t        var testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;\n\t        updateTitleRight = testRight < minRight ? minRight : testRight;\n\t        if (updateTitleRight !== titleRight) {\n\t          titleEle.style.right = updateTitleRight + 'px';\n\t          titleRight = updateTitleRight;\n\t        }\n\t      }\n\t      deferred.resolve();\n\t    });\n\t\n\t    return deferred.promise;\n\t  };\n\t\n\t\n\t  self.setCss = function(elementClassname, css) {\n\t    ionic.DomUtil.cachedStyles(getEle(elementClassname), css);\n\t  };\n\t\n\t\n\t  var eleCache = {};\n\t  function getEle(className) {\n\t    if (!eleCache[className]) {\n\t      eleCache[className] = $element[0].querySelector('.' + className);\n\t    }\n\t    return eleCache[className];\n\t  }\n\t\n\t\n\t  $scope.$on('$destroy', function() {\n\t    for (var n in eleCache) eleCache[n] = null;\n\t  });\n\t\n\t}]);\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.controller('$ionInfiniteScroll', [\n\t  '$scope',\n\t  '$attrs',\n\t  '$element',\n\t  '$timeout',\n\tfunction($scope, $attrs, $element, $timeout) {\n\t  var self = this;\n\t  self.isLoading = false;\n\t\n\t  $scope.icon = function() {\n\t    return isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d';\n\t  };\n\t\n\t  $scope.spinner = function() {\n\t    return isDefined($attrs.spinner) ? $attrs.spinner : '';\n\t  };\n\t\n\t  $scope.$on('scroll.infiniteScrollComplete', function() {\n\t    finishInfiniteScroll();\n\t  });\n\t\n\t  $scope.$on('$destroy', function() {\n\t    if (self.scrollCtrl && self.scrollCtrl.$element) self.scrollCtrl.$element.off('scroll', self.checkBounds);\n\t    if (self.scrollEl && self.scrollEl.removeEventListener) {\n\t      self.scrollEl.removeEventListener('scroll', self.checkBounds);\n\t    }\n\t  });\n\t\n\t  // debounce checking infinite scroll events\n\t  self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300);\n\t\n\t  function onInfinite() {\n\t    ionic.requestAnimationFrame(function() {\n\t      $element[0].classList.add('active');\n\t    });\n\t    self.isLoading = true;\n\t    $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '');\n\t  }\n\t\n\t  function finishInfiniteScroll() {\n\t    ionic.requestAnimationFrame(function() {\n\t      $element[0].classList.remove('active');\n\t    });\n\t    $timeout(function() {\n\t      if (self.jsScrolling) self.scrollView.resize();\n\t      // only check bounds again immediately if the page isn't cached (scroll el has height)\n\t      if ((self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0) ||\n\t      !self.jsScrolling) {\n\t        self.checkBounds();\n\t      }\n\t    }, 30, false);\n\t    self.isLoading = false;\n\t  }\n\t\n\t  // check if we've scrolled far enough to trigger an infinite scroll\n\t  function checkInfiniteBounds() {\n\t    if (self.isLoading) return;\n\t    var maxScroll = {};\n\t\n\t    if (self.jsScrolling) {\n\t      maxScroll = self.getJSMaxScroll();\n\t      var scrollValues = self.scrollView.getValues();\n\t      if ((maxScroll.left !== -1 && scrollValues.left >= maxScroll.left) ||\n\t        (maxScroll.top !== -1 && scrollValues.top >= maxScroll.top)) {\n\t        onInfinite();\n\t      }\n\t    } else {\n\t      maxScroll = self.getNativeMaxScroll();\n\t      if ((\n\t        maxScroll.left !== -1 &&\n\t        self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth\n\t        ) || (\n\t        maxScroll.top !== -1 &&\n\t        self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight\n\t        )) {\n\t        onInfinite();\n\t      }\n\t    }\n\t  }\n\t\n\t  // determine the threshold at which we should fire an infinite scroll\n\t  // note: this gets processed every scroll event, can it be cached?\n\t  self.getJSMaxScroll = function() {\n\t    var maxValues = self.scrollView.getScrollMax();\n\t    return {\n\t      left: self.scrollView.options.scrollingX ?\n\t        calculateMaxValue(maxValues.left) :\n\t        -1,\n\t      top: self.scrollView.options.scrollingY ?\n\t        calculateMaxValue(maxValues.top) :\n\t        -1\n\t    };\n\t  };\n\t\n\t  self.getNativeMaxScroll = function() {\n\t    var maxValues = {\n\t      left: self.scrollEl.scrollWidth,\n\t      top: self.scrollEl.scrollHeight\n\t    };\n\t    var computedStyle = window.getComputedStyle(self.scrollEl) || {};\n\t    return {\n\t      left: maxValues.left &&\n\t        (computedStyle.overflowX === 'scroll' ||\n\t        computedStyle.overflowX === 'auto' ||\n\t        self.scrollEl.style['overflow-x'] === 'scroll') ?\n\t        calculateMaxValue(maxValues.left) : -1,\n\t      top: maxValues.top &&\n\t        (computedStyle.overflowY === 'scroll' ||\n\t        computedStyle.overflowY === 'auto' ||\n\t        self.scrollEl.style['overflow-y'] === 'scroll' ) ?\n\t        calculateMaxValue(maxValues.top) : -1\n\t    };\n\t  };\n\t\n\t  // determine pixel refresh distance based on % or value\n\t  function calculateMaxValue(maximum) {\n\t    var distance = ($attrs.distance || '2.5%').trim();\n\t    var isPercent = distance.indexOf('%') !== -1;\n\t    return isPercent ?\n\t    maximum * (1 - parseFloat(distance) / 100) :\n\t    maximum - parseFloat(distance);\n\t  }\n\t\n\t  //for testing\n\t  self.__finishInfiniteScroll = finishInfiniteScroll;\n\t\n\t}]);\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc service\n\t * @name $ionicListDelegate\n\t * @module ionic\n\t *\n\t * @description\n\t * Delegate for controlling the {@link ionic.directive:ionList} directive.\n\t *\n\t * Methods called directly on the $ionicListDelegate service will control all lists.\n\t * Use the {@link ionic.service:$ionicListDelegate#$getByHandle $getByHandle}\n\t * method to control specific ionList instances.\n\t *\n\t * @usage\n\t * ```html\n\t * {% raw %}\n\t * <ion-content ng-controller=\"MyCtrl\">\n\t *   <button class=\"button\" ng-click=\"showDeleteButtons()\"></button>\n\t *   <ion-list>\n\t *     <ion-item ng-repeat=\"i in items\">\n\t *       Hello, {{i}}!\n\t *       <ion-delete-button class=\"ion-minus-circled\"></ion-delete-button>\n\t *     </ion-item>\n\t *   </ion-list>\n\t * </ion-content>\n\t * {% endraw %}\n\t * ```\n\t\n\t * ```js\n\t * function MyCtrl($scope, $ionicListDelegate) {\n\t *   $scope.showDeleteButtons = function() {\n\t *     $ionicListDelegate.showDelete(true);\n\t *   };\n\t * }\n\t * ```\n\t */\n\tIonicModule.service('$ionicListDelegate', ionic.DelegateService([\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicListDelegate#showReorder\n\t   * @param {boolean=} showReorder Set whether or not this list is showing its reorder buttons.\n\t   * @returns {boolean} Whether the reorder buttons are shown.\n\t   */\n\t  'showReorder',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicListDelegate#showDelete\n\t   * @param {boolean=} showDelete Set whether or not this list is showing its delete buttons.\n\t   * @returns {boolean} Whether the delete buttons are shown.\n\t   */\n\t  'showDelete',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicListDelegate#canSwipeItems\n\t   * @param {boolean=} canSwipeItems Set whether or not this list is able to swipe to show\n\t   * option buttons.\n\t   * @returns {boolean} Whether the list is able to swipe to show option buttons.\n\t   */\n\t  'canSwipeItems',\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicListDelegate#closeOptionButtons\n\t   * @description Closes any option buttons on the list that are swiped open.\n\t   */\n\t  'closeOptionButtons'\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicListDelegate#$getByHandle\n\t   * @param {string} handle\n\t   * @returns `delegateInstance` A delegate instance that controls only the\n\t   * {@link ionic.directive:ionList} directives with `delegate-handle` matching\n\t   * the given handle.\n\t   *\n\t   * Example: `$ionicListDelegate.$getByHandle('my-handle').showReorder(true);`\n\t   */\n\t]))\n\t\n\t.controller('$ionicList', [\n\t  '$scope',\n\t  '$attrs',\n\t  '$ionicListDelegate',\n\t  '$ionicHistory',\n\tfunction($scope, $attrs, $ionicListDelegate, $ionicHistory) {\n\t  var self = this;\n\t  var isSwipeable = true;\n\t  var isReorderShown = false;\n\t  var isDeleteShown = false;\n\t\n\t  var deregisterInstance = $ionicListDelegate._registerInstance(\n\t    self, $attrs.delegateHandle, function() {\n\t      return $ionicHistory.isActiveScope($scope);\n\t    }\n\t  );\n\t  $scope.$on('$destroy', deregisterInstance);\n\t\n\t  self.showReorder = function(show) {\n\t    if (arguments.length) {\n\t      isReorderShown = !!show;\n\t    }\n\t    return isReorderShown;\n\t  };\n\t\n\t  self.showDelete = function(show) {\n\t    if (arguments.length) {\n\t      isDeleteShown = !!show;\n\t    }\n\t    return isDeleteShown;\n\t  };\n\t\n\t  self.canSwipeItems = function(can) {\n\t    if (arguments.length) {\n\t      isSwipeable = !!can;\n\t    }\n\t    return isSwipeable;\n\t  };\n\t\n\t  self.closeOptionButtons = function() {\n\t    self.listView && self.listView.clearDragEffects();\n\t  };\n\t}]);\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t\n\t.controller('$ionicNavBar', [\n\t  '$scope',\n\t  '$element',\n\t  '$attrs',\n\t  '$compile',\n\t  '$timeout',\n\t  '$ionicNavBarDelegate',\n\t  '$ionicConfig',\n\t  '$ionicHistory',\n\tfunction($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {\n\t\n\t  var CSS_HIDE = 'hide';\n\t  var DATA_NAV_BAR_CTRL = '$ionNavBarController';\n\t  var PRIMARY_BUTTONS = 'primaryButtons';\n\t  var SECONDARY_BUTTONS = 'secondaryButtons';\n\t  var BACK_BUTTON = 'backButton';\n\t  var ITEM_TYPES = 'primaryButtons secondaryButtons leftButtons rightButtons title'.split(' ');\n\t\n\t  var self = this;\n\t  var headerBars = [];\n\t  var navElementHtml = {};\n\t  var isVisible = true;\n\t  var queuedTransitionStart, queuedTransitionEnd, latestTransitionId;\n\t\n\t  $element.parent().data(DATA_NAV_BAR_CTRL, self);\n\t\n\t  var delegateHandle = $attrs.delegateHandle || 'navBar' + ionic.Utils.nextUid();\n\t\n\t  var deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);\n\t\n\t\n\t  self.init = function() {\n\t    $element.addClass('nav-bar-container');\n\t    ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', $ionicConfig.views.transition());\n\t\n\t    // create two nav bar blocks which will trade out which one is shown\n\t    self.createHeaderBar(false);\n\t    self.createHeaderBar(true);\n\t\n\t    $scope.$emit('ionNavBar.init', delegateHandle);\n\t  };\n\t\n\t\n\t  self.createHeaderBar = function(isActive) {\n\t    var containerEle = jqLite('<div class=\"nav-bar-block\">');\n\t    ionic.DomUtil.cachedAttr(containerEle, 'nav-bar', isActive ? 'active' : 'cached');\n\t\n\t    var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle();\n\t    var headerBarEle = jqLite('<ion-header-bar>').addClass($attrs['class']).attr('align-title', alignTitle);\n\t    if (isDefined($attrs.noTapScroll)) headerBarEle.attr('no-tap-scroll', $attrs.noTapScroll);\n\t    var titleEle = jqLite('<div class=\"title title-' + alignTitle + '\">');\n\t    var navEle = {};\n\t    var lastViewItemEle = {};\n\t    var leftButtonsEle, rightButtonsEle;\n\t\n\t    navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON);\n\t    navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]);\n\t\n\t    // append title in the header, this is the rock to where buttons append\n\t    headerBarEle.append(titleEle);\n\t\n\t    forEach(ITEM_TYPES, function(itemType) {\n\t      // create default button elements\n\t      navEle[itemType] = createNavElement(itemType);\n\t      // append and position buttons\n\t      positionItem(navEle[itemType], itemType);\n\t    });\n\t\n\t    // add header-item to the root children\n\t    for (var x = 0; x < headerBarEle[0].children.length; x++) {\n\t      headerBarEle[0].children[x].classList.add('header-item');\n\t    }\n\t\n\t    // compile header and append to the DOM\n\t    containerEle.append(headerBarEle);\n\t    $element.append($compile(containerEle)($scope.$new()));\n\t\n\t    var headerBarCtrl = headerBarEle.data('$ionHeaderBarController');\n\t    headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon();\n\t    headerBarCtrl.backButtonText = $ionicConfig.backButton.text();\n\t\n\t    var headerBarInstance = {\n\t      isActive: isActive,\n\t      title: function(newTitleText) {\n\t        headerBarCtrl.title(newTitleText);\n\t      },\n\t      setItem: function(navBarItemEle, itemType) {\n\t        // first make sure any exiting nav bar item has been removed\n\t        headerBarInstance.removeItem(itemType);\n\t\n\t        if (navBarItemEle) {\n\t          if (itemType === 'title') {\n\t            // clear out the text based title\n\t            headerBarInstance.title(\"\");\n\t          }\n\t\n\t          // there's a custom nav bar item\n\t          positionItem(navBarItemEle, itemType);\n\t\n\t          if (navEle[itemType]) {\n\t            // make sure the default on this itemType is hidden\n\t            navEle[itemType].addClass(CSS_HIDE);\n\t          }\n\t          lastViewItemEle[itemType] = navBarItemEle;\n\t\n\t        } else if (navEle[itemType]) {\n\t          // there's a default button for this side and no view button\n\t          navEle[itemType].removeClass(CSS_HIDE);\n\t        }\n\t      },\n\t      removeItem: function(itemType) {\n\t        if (lastViewItemEle[itemType]) {\n\t          lastViewItemEle[itemType].scope().$destroy();\n\t          lastViewItemEle[itemType].remove();\n\t          lastViewItemEle[itemType] = null;\n\t        }\n\t      },\n\t      containerEle: function() {\n\t        return containerEle;\n\t      },\n\t      headerBarEle: function() {\n\t        return headerBarEle;\n\t      },\n\t      afterLeave: function() {\n\t        forEach(ITEM_TYPES, function(itemType) {\n\t          headerBarInstance.removeItem(itemType);\n\t        });\n\t        headerBarCtrl.resetBackButton();\n\t      },\n\t      controller: function() {\n\t        return headerBarCtrl;\n\t      },\n\t      destroy: function() {\n\t        forEach(ITEM_TYPES, function(itemType) {\n\t          headerBarInstance.removeItem(itemType);\n\t        });\n\t        containerEle.scope().$destroy();\n\t        for (var n in navEle) {\n\t          if (navEle[n]) {\n\t            navEle[n].removeData();\n\t            navEle[n] = null;\n\t          }\n\t        }\n\t        leftButtonsEle && leftButtonsEle.removeData();\n\t        rightButtonsEle && rightButtonsEle.removeData();\n\t        titleEle.removeData();\n\t        headerBarEle.removeData();\n\t        containerEle.remove();\n\t        containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;\n\t      }\n\t    };\n\t\n\t    function positionItem(ele, itemType) {\n\t      if (!ele) return;\n\t\n\t      if (itemType === 'title') {\n\t        // title element\n\t        titleEle.append(ele);\n\t\n\t      } else if (itemType == 'rightButtons' ||\n\t                (itemType == SECONDARY_BUTTONS && $ionicConfig.navBar.positionSecondaryButtons() != 'left') ||\n\t                (itemType == PRIMARY_BUTTONS && $ionicConfig.navBar.positionPrimaryButtons() == 'right')) {\n\t        // right side\n\t        if (!rightButtonsEle) {\n\t          rightButtonsEle = jqLite('<div class=\"buttons buttons-right\">');\n\t          headerBarEle.append(rightButtonsEle);\n\t        }\n\t        if (itemType == SECONDARY_BUTTONS) {\n\t          rightButtonsEle.append(ele);\n\t        } else {\n\t          rightButtonsEle.prepend(ele);\n\t        }\n\t\n\t      } else {\n\t        // left side\n\t        if (!leftButtonsEle) {\n\t          leftButtonsEle = jqLite('<div class=\"buttons buttons-left\">');\n\t          if (navEle[BACK_BUTTON]) {\n\t            navEle[BACK_BUTTON].after(leftButtonsEle);\n\t          } else {\n\t            headerBarEle.prepend(leftButtonsEle);\n\t          }\n\t        }\n\t        if (itemType == SECONDARY_BUTTONS) {\n\t          leftButtonsEle.append(ele);\n\t        } else {\n\t          leftButtonsEle.prepend(ele);\n\t        }\n\t      }\n\t\n\t    }\n\t\n\t    headerBars.push(headerBarInstance);\n\t\n\t    return headerBarInstance;\n\t  };\n\t\n\t\n\t  self.navElement = function(type, html) {\n\t    if (isDefined(html)) {\n\t      navElementHtml[type] = html;\n\t    }\n\t    return navElementHtml[type];\n\t  };\n\t\n\t\n\t  self.update = function(viewData) {\n\t    var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;\n\t    viewData.transition = $ionicConfig.views.transition();\n\t\n\t    if (!showNavBar) {\n\t      viewData.direction = 'none';\n\t    }\n\t\n\t    self.enable(showNavBar);\n\t    var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar();\n\t    var leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null;\n\t    var enteringHeaderCtrl = enteringHeaderBar.controller();\n\t\n\t    // update if the entering header should show the back button or not\n\t    enteringHeaderCtrl.enableBack(viewData.enableBack, true);\n\t    enteringHeaderCtrl.showBack(viewData.showBack, true);\n\t    enteringHeaderCtrl.updateBackButton();\n\t\n\t    // update the entering header bar's title\n\t    self.title(viewData.title, enteringHeaderBar);\n\t\n\t    self.showBar(showNavBar);\n\t\n\t    // update the nav bar items, depending if the view has their own or not\n\t    if (viewData.navBarItems) {\n\t      forEach(ITEM_TYPES, function(itemType) {\n\t        enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);\n\t      });\n\t    }\n\t\n\t    // begin transition of entering and leaving header bars\n\t    self.transition(enteringHeaderBar, leavingHeaderBar, viewData);\n\t\n\t    self.isInitialized = true;\n\t    navSwipeAttr('');\n\t  };\n\t\n\t\n\t  self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {\n\t    var enteringHeaderBarCtrl = enteringHeaderBar.controller();\n\t    var transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none;\n\t    var transitionId = viewData.transitionId;\n\t\n\t    enteringHeaderBarCtrl.beforeEnter(viewData);\n\t\n\t    var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);\n\t\n\t    ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', viewData.navBarTransition);\n\t    ionic.DomUtil.cachedAttr($element, 'nav-bar-direction', viewData.direction);\n\t\n\t    if (navBarTransition.shouldAnimate && viewData.renderEnd) {\n\t      navBarAttr(enteringHeaderBar, 'stage');\n\t    } else {\n\t      navBarAttr(enteringHeaderBar, 'entering');\n\t      navBarAttr(leavingHeaderBar, 'leaving');\n\t    }\n\t\n\t    enteringHeaderBarCtrl.resetBackButton(viewData);\n\t\n\t    navBarTransition.run(0);\n\t\n\t    self.activeTransition = {\n\t      run: function(step) {\n\t        navBarTransition.shouldAnimate = false;\n\t        navBarTransition.direction = 'back';\n\t        navBarTransition.run(step);\n\t      },\n\t      cancel: function(shouldAnimate, speed, cancelData) {\n\t        navSwipeAttr(speed);\n\t        navBarAttr(leavingHeaderBar, 'active');\n\t        navBarAttr(enteringHeaderBar, 'cached');\n\t        navBarTransition.shouldAnimate = shouldAnimate;\n\t        navBarTransition.run(0);\n\t        self.activeTransition = navBarTransition = null;\n\t\n\t        var runApply;\n\t        if (cancelData.showBar !== self.showBar()) {\n\t          self.showBar(cancelData.showBar);\n\t        }\n\t        if (cancelData.showBackButton !== self.showBackButton()) {\n\t          self.showBackButton(cancelData.showBackButton);\n\t        }\n\t        if (runApply) {\n\t          $scope.$apply();\n\t        }\n\t      },\n\t      complete: function(shouldAnimate, speed) {\n\t        navSwipeAttr(speed);\n\t        navBarTransition.shouldAnimate = shouldAnimate;\n\t        navBarTransition.run(1);\n\t        queuedTransitionEnd = transitionEnd;\n\t      }\n\t    };\n\t\n\t    $timeout(enteringHeaderBarCtrl.align, 16);\n\t\n\t    queuedTransitionStart = function() {\n\t      if (latestTransitionId !== transitionId) return;\n\t\n\t      navBarAttr(enteringHeaderBar, 'entering');\n\t      navBarAttr(leavingHeaderBar, 'leaving');\n\t\n\t      navBarTransition.run(1);\n\t\n\t      queuedTransitionEnd = function() {\n\t        if (latestTransitionId == transitionId || !navBarTransition.shouldAnimate) {\n\t          transitionEnd();\n\t        }\n\t      };\n\t\n\t      queuedTransitionStart = null;\n\t    };\n\t\n\t    function transitionEnd() {\n\t      for (var x = 0; x < headerBars.length; x++) {\n\t        headerBars[x].isActive = false;\n\t      }\n\t      enteringHeaderBar.isActive = true;\n\t\n\t      navBarAttr(enteringHeaderBar, 'active');\n\t      navBarAttr(leavingHeaderBar, 'cached');\n\t\n\t      self.activeTransition = navBarTransition = queuedTransitionEnd = null;\n\t    }\n\t\n\t    queuedTransitionStart();\n\t  };\n\t\n\t\n\t  self.triggerTransitionStart = function(triggerTransitionId) {\n\t    latestTransitionId = triggerTransitionId;\n\t    queuedTransitionStart && queuedTransitionStart();\n\t  };\n\t\n\t\n\t  self.triggerTransitionEnd = function() {\n\t    queuedTransitionEnd && queuedTransitionEnd();\n\t  };\n\t\n\t\n\t  self.showBar = function(shouldShow) {\n\t    if (arguments.length) {\n\t      self.visibleBar(shouldShow);\n\t      $scope.$parent.$hasHeader = !!shouldShow;\n\t    }\n\t    return !!$scope.$parent.$hasHeader;\n\t  };\n\t\n\t\n\t  self.visibleBar = function(shouldShow) {\n\t    if (shouldShow && !isVisible) {\n\t      $element.removeClass(CSS_HIDE);\n\t      self.align();\n\t    } else if (!shouldShow && isVisible) {\n\t      $element.addClass(CSS_HIDE);\n\t    }\n\t    isVisible = shouldShow;\n\t  };\n\t\n\t\n\t  self.enable = function(val) {\n\t    // set primary to show first\n\t    self.visibleBar(val);\n\t\n\t    // set non primary to hide second\n\t    for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {\n\t      if ($ionicNavBarDelegate._instances[x] !== self) $ionicNavBarDelegate._instances[x].visibleBar(false);\n\t    }\n\t  };\n\t\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavBar#showBackButton\n\t   * @description Show/hide the nav bar back button when there is a\n\t   * back view. If the back button is not possible, for example, the\n\t   * first view in the stack, then this will not force the back button\n\t   * to show.\n\t   */\n\t  self.showBackButton = function(shouldShow) {\n\t    if (arguments.length) {\n\t      for (var x = 0; x < headerBars.length; x++) {\n\t        headerBars[x].controller().showNavBack(!!shouldShow);\n\t      }\n\t      $scope.$isBackButtonShown = !!shouldShow;\n\t    }\n\t    return $scope.$isBackButtonShown;\n\t  };\n\t\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavBar#showActiveBackButton\n\t   * @description Show/hide only the active header bar's back button.\n\t   */\n\t  self.showActiveBackButton = function(shouldShow) {\n\t    var headerBar = getOnScreenHeaderBar();\n\t    if (headerBar) {\n\t      if (arguments.length) {\n\t        return headerBar.controller().showBack(shouldShow);\n\t      }\n\t      return headerBar.controller().showBack();\n\t    }\n\t  };\n\t\n\t\n\t  self.title = function(newTitleText, headerBar) {\n\t    if (isDefined(newTitleText)) {\n\t      newTitleText = newTitleText || '';\n\t      headerBar = headerBar || getOnScreenHeaderBar();\n\t      headerBar && headerBar.title(newTitleText);\n\t      $scope.$title = newTitleText;\n\t      $ionicHistory.currentTitle(newTitleText);\n\t    }\n\t    return $scope.$title;\n\t  };\n\t\n\t\n\t  self.align = function(val, headerBar) {\n\t    headerBar = headerBar || getOnScreenHeaderBar();\n\t    headerBar && headerBar.controller().align(val);\n\t  };\n\t\n\t\n\t  self.hasTabsTop = function(isTabsTop) {\n\t    $element[isTabsTop ? 'addClass' : 'removeClass']('nav-bar-tabs-top');\n\t  };\n\t\n\t  self.hasBarSubheader = function(isBarSubheader) {\n\t    $element[isBarSubheader ? 'addClass' : 'removeClass']('nav-bar-has-subheader');\n\t  };\n\t\n\t  // DEPRECATED, as of v1.0.0-beta14 -------\n\t  self.changeTitle = function(val) {\n\t    deprecatedWarning('changeTitle(val)', 'title(val)');\n\t    self.title(val);\n\t  };\n\t  self.setTitle = function(val) {\n\t    deprecatedWarning('setTitle(val)', 'title(val)');\n\t    self.title(val);\n\t  };\n\t  self.getTitle = function() {\n\t    deprecatedWarning('getTitle()', 'title()');\n\t    return self.title();\n\t  };\n\t  self.back = function() {\n\t    deprecatedWarning('back()', '$ionicHistory.goBack()');\n\t    $ionicHistory.goBack();\n\t  };\n\t  self.getPreviousTitle = function() {\n\t    deprecatedWarning('getPreviousTitle()', '$ionicHistory.backTitle()');\n\t    $ionicHistory.goBack();\n\t  };\n\t  function deprecatedWarning(oldMethod, newMethod) {\n\t    var warn = console.warn || console.log;\n\t    warn && warn.call(console, 'navBarController.' + oldMethod + ' is deprecated, please use ' + newMethod + ' instead');\n\t  }\n\t  // END DEPRECATED -------\n\t\n\t\n\t  function createNavElement(type) {\n\t    if (navElementHtml[type]) {\n\t      return jqLite(navElementHtml[type]);\n\t    }\n\t  }\n\t\n\t\n\t  function getOnScreenHeaderBar() {\n\t    for (var x = 0; x < headerBars.length; x++) {\n\t      if (headerBars[x].isActive) return headerBars[x];\n\t    }\n\t  }\n\t\n\t\n\t  function getOffScreenHeaderBar() {\n\t    for (var x = 0; x < headerBars.length; x++) {\n\t      if (!headerBars[x].isActive) return headerBars[x];\n\t    }\n\t  }\n\t\n\t\n\t  function navBarAttr(ctrl, val) {\n\t    ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), 'nav-bar', val);\n\t  }\n\t\n\t  function navSwipeAttr(val) {\n\t    ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);\n\t  }\n\t\n\t\n\t  $scope.$on('$destroy', function() {\n\t    $scope.$parent.$hasHeader = false;\n\t    $element.parent().removeData(DATA_NAV_BAR_CTRL);\n\t    for (var x = 0; x < headerBars.length; x++) {\n\t      headerBars[x].destroy();\n\t    }\n\t    $element.remove();\n\t    $element = headerBars = null;\n\t    deregisterInstance();\n\t  });\n\t\n\t}]);\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.controller('$ionicNavView', [\n\t  '$scope',\n\t  '$element',\n\t  '$attrs',\n\t  '$compile',\n\t  '$controller',\n\t  '$ionicNavBarDelegate',\n\t  '$ionicNavViewDelegate',\n\t  '$ionicHistory',\n\t  '$ionicViewSwitcher',\n\t  '$ionicConfig',\n\t  '$ionicScrollDelegate',\n\tfunction($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate) {\n\t\n\t  var DATA_ELE_IDENTIFIER = '$eleId';\n\t  var DATA_DESTROY_ELE = '$destroyEle';\n\t  var DATA_NO_CACHE = '$noCache';\n\t  var VIEW_STATUS_ACTIVE = 'active';\n\t  var VIEW_STATUS_CACHED = 'cached';\n\t\n\t  var self = this;\n\t  var direction;\n\t  var isPrimary = false;\n\t  var navBarDelegate;\n\t  var activeEleId;\n\t  var navViewAttr = $ionicViewSwitcher.navViewAttr;\n\t  var disableRenderStartViewId, disableAnimation;\n\t\n\t  self.scope = $scope;\n\t  self.element = $element;\n\t\n\t  self.init = function() {\n\t    var navViewName = $attrs.name || '';\n\t\n\t    // Find the details of the parent view directive (if any) and use it\n\t    // to derive our own qualified view name, then hang our own details\n\t    // off the DOM so child directives can find it.\n\t    var parent = $element.parent().inheritedData('$uiView');\n\t    var parentViewName = ((parent && parent.state) ? parent.state.name : '');\n\t    if (navViewName.indexOf('@') < 0) navViewName = navViewName + '@' + parentViewName;\n\t\n\t    var viewData = { name: navViewName, state: null };\n\t    $element.data('$uiView', viewData);\n\t\n\t    var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);\n\t    $scope.$on('$destroy', function() {\n\t      deregisterInstance();\n\t\n\t      // ensure no scrolls have been left frozen\n\t      if (self.isSwipeFreeze) {\n\t        $ionicScrollDelegate.freezeAllScrolls(false);\n\t      }\n\t    });\n\t\n\t    $scope.$on('$ionicHistory.deselect', self.cacheCleanup);\n\t    $scope.$on('$ionicTabs.top', onTabsTop);\n\t    $scope.$on('$ionicSubheader', onBarSubheader);\n\t\n\t    $scope.$on('$ionicTabs.beforeLeave', onTabsLeave);\n\t    $scope.$on('$ionicTabs.afterLeave', onTabsLeave);\n\t    $scope.$on('$ionicTabs.leave', onTabsLeave);\n\t\n\t    ionic.Platform.ready(function() {\n\t      if (ionic.Platform.isWebView() && $ionicConfig.views.swipeBackEnabled()) {\n\t        self.initSwipeBack();\n\t      }\n\t    });\n\t\n\t    return viewData;\n\t  };\n\t\n\t\n\t  self.register = function(viewLocals) {\n\t    var leavingView = extend({}, $ionicHistory.currentView());\n\t\n\t    // register that a view is coming in and get info on how it should transition\n\t    var registerData = $ionicHistory.register($scope, viewLocals);\n\t\n\t    // update which direction\n\t    self.update(registerData);\n\t\n\t    // begin rendering and transitioning\n\t    var enteringView = $ionicHistory.getViewById(registerData.viewId) || {};\n\t\n\t    var renderStart = (disableRenderStartViewId !== registerData.viewId);\n\t    self.render(registerData, viewLocals, enteringView, leavingView, renderStart, true);\n\t  };\n\t\n\t\n\t  self.update = function(registerData) {\n\t    // always reset that this is the primary navView\n\t    isPrimary = true;\n\t\n\t    // remember what direction this navView should use\n\t    // this may get updated later by a child navView\n\t    direction = registerData.direction;\n\t\n\t    var parentNavViewCtrl = $element.parent().inheritedData('$ionNavViewController');\n\t    if (parentNavViewCtrl) {\n\t      // this navView is nested inside another one\n\t      // update the parent to use this direction and not\n\t      // the other it originally was set to\n\t\n\t      // inform the parent navView that it is not the primary navView\n\t      parentNavViewCtrl.isPrimary(false);\n\t\n\t      if (direction === 'enter' || direction === 'exit') {\n\t        // they're entering/exiting a history\n\t        // find parent navViewController\n\t        parentNavViewCtrl.direction(direction);\n\t\n\t        if (direction === 'enter') {\n\t          // reset the direction so this navView doesn't animate\n\t          // because it's parent will\n\t          direction = 'none';\n\t        }\n\t      }\n\t    }\n\t  };\n\t\n\t\n\t  self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {\n\t    // register the view and figure out where it lives in the various\n\t    // histories and nav stacks, along with how views should enter/leave\n\t    var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);\n\t\n\t    // init the rendering of views for this navView directive\n\t    switcher.init(registerData, function() {\n\t      // the view is now compiled, in the dom and linked, now lets transition the views.\n\t      // this uses a callback incase THIS nav-view has a nested nav-view, and after the NESTED\n\t      // nav-view links, the NESTED nav-view would update which direction THIS nav-view should use\n\t\n\t      // kick off the transition of views\n\t      switcher.transition(self.direction(), registerData.enableBack, !disableAnimation);\n\t\n\t      // reset private vars for next time\n\t      disableRenderStartViewId = disableAnimation = null;\n\t    });\n\t\n\t  };\n\t\n\t\n\t  self.beforeEnter = function(transitionData) {\n\t    if (isPrimary) {\n\t      // only update this nav-view's nav-bar if this is the primary nav-view\n\t      navBarDelegate = transitionData.navBarDelegate;\n\t      var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t      associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData);\n\t      navSwipeAttr('');\n\t    }\n\t  };\n\t\n\t\n\t  self.activeEleId = function(eleId) {\n\t    if (arguments.length) {\n\t      activeEleId = eleId;\n\t    }\n\t    return activeEleId;\n\t  };\n\t\n\t\n\t  self.transitionEnd = function() {\n\t    var viewElements = $element.children();\n\t    var x, l, viewElement;\n\t\n\t    for (x = 0, l = viewElements.length; x < l; x++) {\n\t      viewElement = viewElements.eq(x);\n\t\n\t      if (viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId) {\n\t        // this is the active element\n\t        navViewAttr(viewElement, VIEW_STATUS_ACTIVE);\n\t\n\t      } else if (navViewAttr(viewElement) === 'leaving' || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) {\n\t        // this is a leaving element or was the former active element, or is an cached element\n\t        if (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE)) {\n\t          // this element shouldn't stay cached\n\t          $ionicViewSwitcher.destroyViewEle(viewElement);\n\t\n\t        } else {\n\t          // keep in the DOM, mark as cached\n\t          navViewAttr(viewElement, VIEW_STATUS_CACHED);\n\t\n\t          // disconnect the leaving scope\n\t          ionic.Utils.disconnectScope(viewElement.scope());\n\t        }\n\t      }\n\t    }\n\t\n\t    navSwipeAttr('');\n\t\n\t    // ensure no scrolls have been left frozen\n\t    if (self.isSwipeFreeze) {\n\t      $ionicScrollDelegate.freezeAllScrolls(false);\n\t    }\n\t  };\n\t\n\t\n\t  function onTabsLeave(ev, data) {\n\t    var viewElements = $element.children();\n\t    var viewElement, viewScope;\n\t\n\t    for (var x = 0, l = viewElements.length; x < l; x++) {\n\t      viewElement = viewElements.eq(x);\n\t      if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {\n\t        viewScope = viewElement.scope();\n\t        viewScope && viewScope.$emit(ev.name.replace('Tabs', 'View'), data);\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t\n\t  self.cacheCleanup = function() {\n\t    var viewElements = $element.children();\n\t    for (var x = 0, l = viewElements.length; x < l; x++) {\n\t      if (viewElements.eq(x).data(DATA_DESTROY_ELE)) {\n\t        $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));\n\t      }\n\t    }\n\t  };\n\t\n\t\n\t  self.clearCache = function(stateIds) {\n\t    var viewElements = $element.children();\n\t    var viewElement, viewScope, x, l, y, eleIdentifier;\n\t\n\t    for (x = 0, l = viewElements.length; x < l; x++) {\n\t      viewElement = viewElements.eq(x);\n\t\n\t      if (stateIds) {\n\t        eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER);\n\t\n\t        for (y = 0; y < stateIds.length; y++) {\n\t          if (eleIdentifier === stateIds[y]) {\n\t            $ionicViewSwitcher.destroyViewEle(viewElement);\n\t          }\n\t        }\n\t        continue;\n\t      }\n\t\n\t      if (navViewAttr(viewElement) == VIEW_STATUS_CACHED) {\n\t        $ionicViewSwitcher.destroyViewEle(viewElement);\n\t\n\t      } else if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {\n\t        viewScope = viewElement.scope();\n\t        viewScope && viewScope.$broadcast('$ionicView.clearCache');\n\t      }\n\t\n\t    }\n\t  };\n\t\n\t\n\t  self.getViewElements = function() {\n\t    return $element.children();\n\t  };\n\t\n\t\n\t  self.appendViewElement = function(viewEle, viewLocals) {\n\t    // compile the entering element and get the link function\n\t    var linkFn = $compile(viewEle);\n\t\n\t    $element.append(viewEle);\n\t\n\t    var viewScope = $scope.$new();\n\t\n\t    if (viewLocals && viewLocals.$$controller) {\n\t      viewLocals.$scope = viewScope;\n\t      var controller = $controller(viewLocals.$$controller, viewLocals);\n\t      if (viewLocals.$$controllerAs) {\n\t        viewScope[viewLocals.$$controllerAs] = controller;\n\t      }\n\t      $element.children().data('$ngControllerController', controller);\n\t    }\n\t\n\t    linkFn(viewScope);\n\t\n\t    return viewScope;\n\t  };\n\t\n\t\n\t  self.title = function(val) {\n\t    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t    associatedNavBarCtrl && associatedNavBarCtrl.title(val);\n\t  };\n\t\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavView#enableBackButton\n\t   * @description Enable/disable if the back button can be shown or not. For\n\t   * example, the very first view in the navigation stack would not have a\n\t   * back view, so the back button would be disabled.\n\t   */\n\t  self.enableBackButton = function(shouldEnable) {\n\t    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t    associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);\n\t  };\n\t\n\t\n\t  /**\n\t   * @ngdoc method\n\t   * @name $ionicNavView#showBackButton\n\t   * @description Show/hide the nav bar active back button. If the back button\n\t   * is not possible this will not force the back button to show. The\n\t   * `enableBackButton()` method handles if a back button is even possible or not.\n\t   */\n\t  self.showBackButton = function(shouldShow) {\n\t    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t    if (associatedNavBarCtrl) {\n\t      if (arguments.length) {\n\t        return associatedNavBarCtrl.showActiveBackButton(shouldShow);\n\t      }\n\t      return associatedNavBarCtrl.showActiveBackButton();\n\t    }\n\t    return true;\n\t  };\n\t\n\t\n\t  self.showBar = function(val) {\n\t    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t    if (associatedNavBarCtrl) {\n\t      if (arguments.length) {\n\t        return associatedNavBarCtrl.showBar(val);\n\t      }\n\t      return associatedNavBarCtrl.showBar();\n\t    }\n\t    return true;\n\t  };\n\t\n\t\n\t  self.isPrimary = function(val) {\n\t    if (arguments.length) {\n\t      isPrimary = val;\n\t    }\n\t    return isPrimary;\n\t  };\n\t\n\t\n\t  self.direction = function(val) {\n\t    if (arguments.length) {\n\t      direction = val;\n\t    }\n\t    return direction;\n\t  };\n\t\n\t\n\t  self.initSwipeBack = function() {\n\t    var swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth();\n\t    var viewTransition, associatedNavBarCtrl, backView;\n\t    var deregDragStart, deregDrag, deregRelease;\n\t    var windowWidth, startDragX, dragPoints;\n\t    var cancelData = {};\n\t\n\t    function onDragStart(ev) {\n\t      if (!isPrimary) return;\n\t\n\t      startDragX = getDragX(ev);\n\t      if (startDragX > swipeBackHitWidth) return;\n\t\n\t      backView = $ionicHistory.backView();\n\t\n\t      var currentView = $ionicHistory.currentView();\n\t\n\t      if (!backView || backView.historyId !== currentView.historyId || currentView.canSwipeBack === false) return;\n\t\n\t      if (!windowWidth) windowWidth = window.innerWidth;\n\t\n\t      self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(true);\n\t\n\t      var registerData = {\n\t        direction: 'back'\n\t      };\n\t\n\t      dragPoints = [];\n\t\n\t      cancelData = {\n\t        showBar: self.showBar(),\n\t        showBackButton: self.showBackButton()\n\t      };\n\t\n\t      var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, true, false);\n\t      switcher.loadViewElements(registerData);\n\t      switcher.render(registerData);\n\t\n\t      viewTransition = switcher.transition('back', $ionicHistory.enabledBack(backView), true);\n\t\n\t      associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t\n\t      deregDrag = ionic.onGesture('drag', onDrag, $element[0]);\n\t      deregRelease = ionic.onGesture('release', onRelease, $element[0]);\n\t    }\n\t\n\t    function onDrag(ev) {\n\t      if (isPrimary && viewTransition) {\n\t        var dragX = getDragX(ev);\n\t\n\t        dragPoints.push({\n\t          t: Date.now(),\n\t          x: dragX\n\t        });\n\t\n\t        if (dragX >= windowWidth - 15) {\n\t          onRelease(ev);\n\t\n\t        } else {\n\t          var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);\n\t          viewTransition.run(step);\n\t          associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);\n\t        }\n\t\n\t      }\n\t    }\n\t\n\t    function onRelease(ev) {\n\t      if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {\n\t\n\t        var now = Date.now();\n\t        var releaseX = getDragX(ev);\n\t        var startDrag = dragPoints[dragPoints.length - 1];\n\t\n\t        for (var x = dragPoints.length - 2; x >= 0; x--) {\n\t          if (now - startDrag.t > 200) {\n\t            break;\n\t          }\n\t          startDrag = dragPoints[x];\n\t        }\n\t\n\t        var isSwipingRight = (releaseX >= dragPoints[dragPoints.length - 2].x);\n\t        var releaseSwipeCompletion = getSwipeCompletion(releaseX);\n\t        var velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);\n\t\n\t        // private variables because ui-router has no way to pass custom data using $state.go\n\t        disableRenderStartViewId = backView.viewId;\n\t        disableAnimation = (releaseSwipeCompletion < 0.03 || releaseSwipeCompletion > 0.97);\n\t\n\t        if (isSwipingRight && (releaseSwipeCompletion > 0.5 || velocity > 0.1)) {\n\t          // complete view transition on release\n\t          var speed = (velocity > 0.5 || velocity < 0.05 || releaseX > windowWidth - 45) ? 'fast' : 'slow';\n\t          navSwipeAttr(disableAnimation ? '' : speed);\n\t          backView.go();\n\t          associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);\n\t\n\t        } else {\n\t          // cancel view transition on release\n\t          navSwipeAttr(disableAnimation ? '' : 'fast');\n\t          disableRenderStartViewId = null;\n\t          viewTransition.cancel(!disableAnimation);\n\t          associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, 'fast', cancelData);\n\t          disableAnimation = null;\n\t        }\n\t\n\t      }\n\t\n\t      ionic.offGesture(deregDrag, 'drag', onDrag);\n\t      ionic.offGesture(deregRelease, 'release', onRelease);\n\t\n\t      windowWidth = viewTransition = dragPoints = null;\n\t\n\t      self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(false);\n\t    }\n\t\n\t    function getDragX(ev) {\n\t      return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;\n\t    }\n\t\n\t    function getSwipeCompletion(dragX) {\n\t      return (dragX - startDragX) / windowWidth;\n\t    }\n\t\n\t    deregDragStart = ionic.onGesture('dragstart', onDragStart, $element[0]);\n\t\n\t    $scope.$on('$destroy', function() {\n\t      ionic.offGesture(deregDragStart, 'dragstart', onDragStart);\n\t      ionic.offGesture(deregDrag, 'drag', onDrag);\n\t      ionic.offGesture(deregRelease, 'release', onRelease);\n\t      self.element = viewTransition = associatedNavBarCtrl = null;\n\t    });\n\t  };\n\t\n\t\n\t  function navSwipeAttr(val) {\n\t    ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);\n\t  }\n\t\n\t\n\t  function onTabsTop(ev, isTabsTop) {\n\t    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t    associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);\n\t  }\n\t\n\t  function onBarSubheader(ev, isBarSubheader) {\n\t    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\t    associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);\n\t  }\n\t\n\t  function getAssociatedNavBarCtrl() {\n\t    if (navBarDelegate) {\n\t      for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {\n\t        if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) {\n\t          return $ionicNavBarDelegate._instances[x];\n\t        }\n\t      }\n\t    }\n\t    return $element.inheritedData('$ionNavBarController');\n\t  }\n\t\n\t}]);\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\tIonicModule\r\n\t.controller('$ionicRefresher', [\r\n\t  '$scope',\r\n\t  '$attrs',\r\n\t  '$element',\r\n\t  '$ionicBind',\r\n\t  '$timeout',\r\n\t  function($scope, $attrs, $element, $ionicBind, $timeout) {\r\n\t    var self = this,\r\n\t        isDragging = false,\r\n\t        isOverscrolling = false,\r\n\t        dragOffset = 0,\r\n\t        lastOverscroll = 0,\r\n\t        ptrThreshold = 60,\r\n\t        activated = false,\r\n\t        scrollTime = 500,\r\n\t        startY = null,\r\n\t        deltaY = null,\r\n\t        canOverscroll = true,\r\n\t        scrollParent,\r\n\t        scrollChild;\r\n\t\r\n\t    if (!isDefined($attrs.pullingIcon)) {\r\n\t      $attrs.$set('pullingIcon', 'ion-android-arrow-down');\r\n\t    }\r\n\t\r\n\t    $scope.showSpinner = !isDefined($attrs.refreshingIcon) && $attrs.spinner != 'none';\r\n\t\r\n\t    $scope.showIcon = isDefined($attrs.refreshingIcon);\r\n\t\r\n\t    $ionicBind($scope, $attrs, {\r\n\t      pullingIcon: '@',\r\n\t      pullingText: '@',\r\n\t      refreshingIcon: '@',\r\n\t      refreshingText: '@',\r\n\t      spinner: '@',\r\n\t      disablePullingRotation: '@',\r\n\t      $onRefresh: '&onRefresh',\r\n\t      $onPulling: '&onPulling'\r\n\t    });\r\n\t\r\n\t    function handleMousedown(e) {\r\n\t      e.touches = e.touches || [{\r\n\t        screenX: e.screenX,\r\n\t        screenY: e.screenY\r\n\t      }];\r\n\t      // Mouse needs this\r\n\t      startY = Math.floor(e.touches[0].screenY);\r\n\t    }\r\n\t\r\n\t    function handleTouchstart(e) {\r\n\t      e.touches = e.touches || [{\r\n\t        screenX: e.screenX,\r\n\t        screenY: e.screenY\r\n\t      }];\r\n\t\r\n\t      startY = e.touches[0].screenY;\r\n\t    }\r\n\t\r\n\t    function handleTouchend() {\r\n\t      // reset Y\r\n\t      startY = null;\r\n\t      // if this wasn't an overscroll, get out immediately\r\n\t      if (!canOverscroll && !isDragging) {\r\n\t        return;\r\n\t      }\r\n\t      // the user has overscrolled but went back to native scrolling\r\n\t      if (!isDragging) {\r\n\t        dragOffset = 0;\r\n\t        isOverscrolling = false;\r\n\t        setScrollLock(false);\r\n\t      } else {\r\n\t        isDragging = false;\r\n\t        dragOffset = 0;\r\n\t\r\n\t        // the user has scroll far enough to trigger a refresh\r\n\t        if (lastOverscroll > ptrThreshold) {\r\n\t          start();\r\n\t          scrollTo(ptrThreshold, scrollTime);\r\n\t\r\n\t        // the user has overscrolled but not far enough to trigger a refresh\r\n\t        } else {\r\n\t          scrollTo(0, scrollTime, deactivate);\r\n\t          isOverscrolling = false;\r\n\t        }\r\n\t      }\r\n\t    }\r\n\t\r\n\t    function handleTouchmove(e) {\r\n\t      e.touches = e.touches || [{\r\n\t        screenX: e.screenX,\r\n\t        screenY: e.screenY\r\n\t      }];\r\n\t\r\n\t      // Force mouse events to have had a down event first\r\n\t      if (!startY && e.type == 'mousemove') {\r\n\t        return;\r\n\t      }\r\n\t\r\n\t      // if multitouch or regular scroll event, get out immediately\r\n\t      if (!canOverscroll || e.touches.length > 1) {\r\n\t        return;\r\n\t      }\r\n\t      //if this is a new drag, keep track of where we start\r\n\t      if (startY === null) {\r\n\t        startY = e.touches[0].screenY;\r\n\t      }\r\n\t\r\n\t      deltaY = e.touches[0].screenY - startY;\r\n\t\r\n\t      // how far have we dragged so far?\r\n\t      // kitkat fix for touchcancel events http://updates.html5rocks.com/2014/05/A-More-Compatible-Smoother-Touch\r\n\t      // Only do this if we're not on crosswalk\r\n\t      if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && !ionic.Platform.isCrosswalk() && scrollParent.scrollTop === 0 && deltaY > 0) {\r\n\t        isDragging = true;\r\n\t        e.preventDefault();\r\n\t      }\r\n\t\r\n\t\r\n\t      // if we've dragged up and back down in to native scroll territory\r\n\t      if (deltaY - dragOffset <= 0 || scrollParent.scrollTop !== 0) {\r\n\t\r\n\t        if (isOverscrolling) {\r\n\t          isOverscrolling = false;\r\n\t          setScrollLock(false);\r\n\t        }\r\n\t\r\n\t        if (isDragging) {\r\n\t          nativescroll(scrollParent, deltaY - dragOffset * -1);\r\n\t        }\r\n\t\r\n\t        // if we're not at overscroll 0 yet, 0 out\r\n\t        if (lastOverscroll !== 0) {\r\n\t          overscroll(0);\r\n\t        }\r\n\t        return;\r\n\t\r\n\t      } else if (deltaY > 0 && scrollParent.scrollTop === 0 && !isOverscrolling) {\r\n\t        // starting overscroll, but drag started below scrollTop 0, so we need to offset the position\r\n\t        dragOffset = deltaY;\r\n\t      }\r\n\t\r\n\t      // prevent native scroll events while overscrolling\r\n\t      e.preventDefault();\r\n\t\r\n\t      // if not overscrolling yet, initiate overscrolling\r\n\t      if (!isOverscrolling) {\r\n\t        isOverscrolling = true;\r\n\t        setScrollLock(true);\r\n\t      }\r\n\t\r\n\t      isDragging = true;\r\n\t      // overscroll according to the user's drag so far\r\n\t      overscroll((deltaY - dragOffset) / 3);\r\n\t\r\n\t      // update the icon accordingly\r\n\t      if (!activated && lastOverscroll > ptrThreshold) {\r\n\t        activated = true;\r\n\t        ionic.requestAnimationFrame(activate);\r\n\t\r\n\t      } else if (activated && lastOverscroll < ptrThreshold) {\r\n\t        activated = false;\r\n\t        ionic.requestAnimationFrame(deactivate);\r\n\t      }\r\n\t    }\r\n\t\r\n\t    function handleScroll(e) {\r\n\t      // canOverscrol is used to greatly simplify the drag handler during normal scrolling\r\n\t      canOverscroll = (e.target.scrollTop === 0) || isDragging;\r\n\t    }\r\n\t\r\n\t    function overscroll(val) {\r\n\t      scrollChild.style[ionic.CSS.TRANSFORM] = 'translateY(' + val + 'px)';\r\n\t      lastOverscroll = val;\r\n\t    }\r\n\t\r\n\t    function nativescroll(target, newScrollTop) {\r\n\t      // creates a scroll event that bubbles, can be cancelled, and with its view\r\n\t      // and detail property initialized to window and 1, respectively\r\n\t      target.scrollTop = newScrollTop;\r\n\t      var e = document.createEvent(\"UIEvents\");\r\n\t      e.initUIEvent(\"scroll\", true, true, window, 1);\r\n\t      target.dispatchEvent(e);\r\n\t    }\r\n\t\r\n\t    function setScrollLock(enabled) {\r\n\t      // set the scrollbar to be position:fixed in preparation to overscroll\r\n\t      // or remove it so the app can be natively scrolled\r\n\t      if (enabled) {\r\n\t        ionic.requestAnimationFrame(function() {\r\n\t          scrollChild.classList.add('overscroll');\r\n\t          show();\r\n\t        });\r\n\t\r\n\t      } else {\r\n\t        ionic.requestAnimationFrame(function() {\r\n\t          scrollChild.classList.remove('overscroll');\r\n\t          hide();\r\n\t          deactivate();\r\n\t        });\r\n\t      }\r\n\t    }\r\n\t\r\n\t    $scope.$on('scroll.refreshComplete', function() {\r\n\t      // prevent the complete from firing before the scroll has started\r\n\t      $timeout(function() {\r\n\t\r\n\t        ionic.requestAnimationFrame(tail);\r\n\t\r\n\t        // scroll back to home during tail animation\r\n\t        scrollTo(0, scrollTime, deactivate);\r\n\t\r\n\t        // return to native scrolling after tail animation has time to finish\r\n\t        $timeout(function() {\r\n\t\r\n\t          if (isOverscrolling) {\r\n\t            isOverscrolling = false;\r\n\t            setScrollLock(false);\r\n\t          }\r\n\t\r\n\t        }, scrollTime);\r\n\t\r\n\t      }, scrollTime);\r\n\t    });\r\n\t\r\n\t    function scrollTo(Y, duration, callback) {\r\n\t      // scroll animation loop w/ easing\r\n\t      // credit https://gist.github.com/dezinezync/5487119\r\n\t      var start = Date.now(),\r\n\t          from = lastOverscroll;\r\n\t\r\n\t      if (from === Y) {\r\n\t        callback();\r\n\t        return; /* Prevent scrolling to the Y point if already there */\r\n\t      }\r\n\t\r\n\t      // decelerating to zero velocity\r\n\t      function easeOutCubic(t) {\r\n\t        return (--t) * t * t + 1;\r\n\t      }\r\n\t\r\n\t      // scroll loop\r\n\t      function scroll() {\r\n\t        var currentTime = Date.now(),\r\n\t          time = Math.min(1, ((currentTime - start) / duration)),\r\n\t          // where .5 would be 50% of time on a linear scale easedT gives a\r\n\t          // fraction based on the easing method\r\n\t          easedT = easeOutCubic(time);\r\n\t\r\n\t        overscroll(Math.floor((easedT * (Y - from)) + from));\r\n\t\r\n\t        if (time < 1) {\r\n\t          ionic.requestAnimationFrame(scroll);\r\n\t\r\n\t        } else {\r\n\t\r\n\t          if (Y < 5 && Y > -5) {\r\n\t            isOverscrolling = false;\r\n\t            setScrollLock(false);\r\n\t          }\r\n\t\r\n\t          callback && callback();\r\n\t        }\r\n\t      }\r\n\t\r\n\t      // start scroll loop\r\n\t      ionic.requestAnimationFrame(scroll);\r\n\t    }\r\n\t\r\n\t\r\n\t    var touchStartEvent, touchMoveEvent, touchEndEvent;\r\n\t    if (window.navigator.pointerEnabled) {\r\n\t      touchStartEvent = 'pointerdown';\r\n\t      touchMoveEvent = 'pointermove';\r\n\t      touchEndEvent = 'pointerup';\r\n\t    } else if (window.navigator.msPointerEnabled) {\r\n\t      touchStartEvent = 'MSPointerDown';\r\n\t      touchMoveEvent = 'MSPointerMove';\r\n\t      touchEndEvent = 'MSPointerUp';\r\n\t    } else {\r\n\t      touchStartEvent = 'touchstart';\r\n\t      touchMoveEvent = 'touchmove';\r\n\t      touchEndEvent = 'touchend';\r\n\t    }\r\n\t\r\n\t    self.init = function() {\r\n\t      scrollParent = $element.parent().parent()[0];\r\n\t      scrollChild = $element.parent()[0];\r\n\t\r\n\t      if (!scrollParent || !scrollParent.classList.contains('ionic-scroll') ||\r\n\t        !scrollChild || !scrollChild.classList.contains('scroll')) {\r\n\t        throw new Error('Refresher must be immediate child of ion-content or ion-scroll');\r\n\t      }\r\n\t\r\n\t\r\n\t      ionic.on(touchStartEvent, handleTouchstart, scrollChild);\r\n\t      ionic.on(touchMoveEvent, handleTouchmove, scrollChild);\r\n\t      ionic.on(touchEndEvent, handleTouchend, scrollChild);\r\n\t      ionic.on('mousedown', handleMousedown, scrollChild);\r\n\t      ionic.on('mousemove', handleTouchmove, scrollChild);\r\n\t      ionic.on('mouseup', handleTouchend, scrollChild);\r\n\t      ionic.on('scroll', handleScroll, scrollParent);\r\n\t\r\n\t      // cleanup when done\r\n\t      $scope.$on('$destroy', destroy);\r\n\t    };\r\n\t\r\n\t    function destroy() {\r\n\t      ionic.off(touchStartEvent, handleTouchstart, scrollChild);\r\n\t      ionic.off(touchMoveEvent, handleTouchmove, scrollChild);\r\n\t      ionic.off(touchEndEvent, handleTouchend, scrollChild);\r\n\t      ionic.off('mousedown', handleMousedown, scrollChild);\r\n\t      ionic.off('mousemove', handleTouchmove, scrollChild);\r\n\t      ionic.off('mouseup', handleTouchend, scrollChild);\r\n\t      ionic.off('scroll', handleScroll, scrollParent);\r\n\t      scrollParent = null;\r\n\t      scrollChild = null;\r\n\t    }\r\n\t\r\n\t    // DOM manipulation and broadcast methods shared by JS and Native Scrolling\r\n\t    // getter used by JS Scrolling\r\n\t    self.getRefresherDomMethods = function() {\r\n\t      return {\r\n\t        activate: activate,\r\n\t        deactivate: deactivate,\r\n\t        start: start,\r\n\t        show: show,\r\n\t        hide: hide,\r\n\t        tail: tail\r\n\t      };\r\n\t    };\r\n\t\r\n\t    function activate() {\r\n\t      $element[0].classList.add('active');\r\n\t      $scope.$onPulling();\r\n\t    }\r\n\t\r\n\t    function deactivate() {\r\n\t      // give tail 150ms to finish\r\n\t      $timeout(function() {\r\n\t        // deactivateCallback\r\n\t        $element.removeClass('active refreshing refreshing-tail');\r\n\t        if (activated) activated = false;\r\n\t      }, 150);\r\n\t    }\r\n\t\r\n\t    function start() {\r\n\t      // startCallback\r\n\t      $element[0].classList.add('refreshing');\r\n\t      var q = $scope.$onRefresh();\r\n\t\r\n\t      if (q && q.then) {\r\n\t        q['finally'](function() {\r\n\t          $scope.$broadcast('scroll.refreshComplete');\r\n\t        });\r\n\t      }\r\n\t    }\r\n\t\r\n\t    function show() {\r\n\t      // showCallback\r\n\t      $element[0].classList.remove('invisible');\r\n\t    }\r\n\t\r\n\t    function hide() {\r\n\t      // showCallback\r\n\t      $element[0].classList.add('invisible');\r\n\t    }\r\n\t\r\n\t    function tail() {\r\n\t      // tailCallback\r\n\t      $element[0].classList.add('refreshing-tail');\r\n\t    }\r\n\t\r\n\t    // for testing\r\n\t    self.__handleTouchmove = handleTouchmove;\r\n\t    self.__getScrollChild = function() { return scrollChild; };\r\n\t    self.__getScrollParent = function() { return scrollParent; };\r\n\t  }\r\n\t]);\r\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @private\r\n\t */\r\n\tIonicModule\r\n\t\r\n\t.controller('$ionicScroll', [\r\n\t  '$scope',\r\n\t  'scrollViewOptions',\r\n\t  '$timeout',\r\n\t  '$window',\r\n\t  '$location',\r\n\t  '$document',\r\n\t  '$ionicScrollDelegate',\r\n\t  '$ionicHistory',\r\n\tfunction($scope,\r\n\t         scrollViewOptions,\r\n\t         $timeout,\r\n\t         $window,\r\n\t         $location,\r\n\t         $document,\r\n\t         $ionicScrollDelegate,\r\n\t         $ionicHistory) {\r\n\t\r\n\t  var self = this;\r\n\t  // for testing\r\n\t  self.__timeout = $timeout;\r\n\t\r\n\t  self._scrollViewOptions = scrollViewOptions; //for testing\r\n\t  self.isNative = function() {\r\n\t    return !!scrollViewOptions.nativeScrolling;\r\n\t  };\r\n\t\r\n\t  var element = self.element = scrollViewOptions.el;\r\n\t  var $element = self.$element = jqLite(element);\r\n\t  var scrollView;\r\n\t  if (self.isNative()) {\r\n\t    scrollView = self.scrollView = new ionic.views.ScrollNative(scrollViewOptions);\r\n\t  } else {\r\n\t    scrollView = self.scrollView = new ionic.views.Scroll(scrollViewOptions);\r\n\t  }\r\n\t\r\n\t\r\n\t  //Attach self to element as a controller so other directives can require this controller\r\n\t  //through `require: '$ionicScroll'\r\n\t  //Also attach to parent so that sibling elements can require this\r\n\t  ($element.parent().length ? $element.parent() : $element)\r\n\t    .data('$$ionicScrollController', self);\r\n\t\r\n\t  var deregisterInstance = $ionicScrollDelegate._registerInstance(\r\n\t    self, scrollViewOptions.delegateHandle, function() {\r\n\t      return $ionicHistory.isActiveScope($scope);\r\n\t    }\r\n\t  );\r\n\t\r\n\t  if (!isDefined(scrollViewOptions.bouncing)) {\r\n\t    ionic.Platform.ready(function() {\r\n\t      if (scrollView && scrollView.options) {\r\n\t        scrollView.options.bouncing = true;\r\n\t        if (ionic.Platform.isAndroid()) {\r\n\t          // No bouncing by default on Android\r\n\t          scrollView.options.bouncing = false;\r\n\t          // Faster scroll decel\r\n\t          scrollView.options.deceleration = 0.95;\r\n\t        }\r\n\t      }\r\n\t    });\r\n\t  }\r\n\t\r\n\t  var resize = angular.bind(scrollView, scrollView.resize);\r\n\t  angular.element($window).on('resize', resize);\r\n\t\r\n\t  var scrollFunc = function(e) {\r\n\t    var detail = (e.originalEvent || e).detail || {};\r\n\t    $scope.$onScroll && $scope.$onScroll({\r\n\t      event: e,\r\n\t      scrollTop: detail.scrollTop || 0,\r\n\t      scrollLeft: detail.scrollLeft || 0\r\n\t    });\r\n\t  };\r\n\t\r\n\t  $element.on('scroll', scrollFunc);\r\n\t\r\n\t  $scope.$on('$destroy', function() {\r\n\t    deregisterInstance();\r\n\t    scrollView && scrollView.__cleanup && scrollView.__cleanup();\r\n\t    angular.element($window).off('resize', resize);\r\n\t    $element.off('scroll', scrollFunc);\r\n\t    scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = scrollViewOptions.el = self._scrollViewOptions.el = $element = self.$element = element = null;\r\n\t  });\r\n\t\r\n\t  $timeout(function() {\r\n\t    scrollView && scrollView.run && scrollView.run();\r\n\t  });\r\n\t\r\n\t  self.getScrollView = function() {\r\n\t    return scrollView;\r\n\t  };\r\n\t\r\n\t  self.getScrollPosition = function() {\r\n\t    return scrollView.getValues();\r\n\t  };\r\n\t\r\n\t  self.resize = function() {\r\n\t    return $timeout(resize, 0, false).then(function() {\r\n\t      $element && $element.triggerHandler('scroll-resize');\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.scrollTop = function(shouldAnimate) {\r\n\t    self.resize().then(function() {\r\n\t      if (!scrollView) {\r\n\t        return;\r\n\t      }\r\n\t      scrollView.scrollTo(0, 0, !!shouldAnimate);\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.scrollBottom = function(shouldAnimate) {\r\n\t    self.resize().then(function() {\r\n\t      if (!scrollView) {\r\n\t        return;\r\n\t      }\r\n\t      var max = scrollView.getScrollMax();\r\n\t      scrollView.scrollTo(max.left, max.top, !!shouldAnimate);\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.scrollTo = function(left, top, shouldAnimate) {\r\n\t    self.resize().then(function() {\r\n\t      if (!scrollView) {\r\n\t        return;\r\n\t      }\r\n\t      scrollView.scrollTo(left, top, !!shouldAnimate);\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {\r\n\t    self.resize().then(function() {\r\n\t      if (!scrollView) {\r\n\t        return;\r\n\t      }\r\n\t      scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {\r\n\t    self.resize().then(function() {\r\n\t      if (!scrollView) {\r\n\t        return;\r\n\t      }\r\n\t      scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.scrollBy = function(left, top, shouldAnimate) {\r\n\t    self.resize().then(function() {\r\n\t      if (!scrollView) {\r\n\t        return;\r\n\t      }\r\n\t      scrollView.scrollBy(left, top, !!shouldAnimate);\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.anchorScroll = function(shouldAnimate) {\r\n\t    self.resize().then(function() {\r\n\t      if (!scrollView) {\r\n\t        return;\r\n\t      }\r\n\t      var hash = $location.hash();\r\n\t      var elm = hash && $document[0].getElementById(hash);\r\n\t      if (!(hash && elm)) {\r\n\t        scrollView.scrollTo(0, 0, !!shouldAnimate);\r\n\t        return;\r\n\t      }\r\n\t      var curElm = elm;\r\n\t      var scrollLeft = 0, scrollTop = 0;\r\n\t      do {\r\n\t        if (curElm !== null) scrollLeft += curElm.offsetLeft;\r\n\t        if (curElm !== null) scrollTop += curElm.offsetTop;\r\n\t        curElm = curElm.offsetParent;\r\n\t      } while (curElm.attributes != self.element.attributes && curElm.offsetParent);\r\n\t      scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);\r\n\t    });\r\n\t  };\r\n\t\r\n\t  self.freezeScroll = scrollView.freeze;\r\n\t  self.freezeScrollShut = scrollView.freezeShut;\r\n\t\r\n\t  self.freezeAllScrolls = function(shouldFreeze) {\r\n\t    for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) {\r\n\t      $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);\r\n\t    }\r\n\t  };\r\n\t\r\n\t\r\n\t  /**\r\n\t   * @private\r\n\t   */\r\n\t  self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {\r\n\t    self.refresher = refresherElement;\r\n\t    var refresherHeight = self.refresher.clientHeight || 60;\r\n\t    scrollView.activatePullToRefresh(\r\n\t      refresherHeight,\r\n\t      refresherMethods\r\n\t    );\r\n\t  };\r\n\t\r\n\t}]);\r\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\tIonicModule\r\n\t.controller('$ionicSideMenus', [\r\n\t  '$scope',\r\n\t  '$attrs',\r\n\t  '$ionicSideMenuDelegate',\r\n\t  '$ionicPlatform',\r\n\t  '$ionicBody',\r\n\t  '$ionicHistory',\r\n\t  '$ionicScrollDelegate',\r\n\t  'IONIC_BACK_PRIORITY',\r\n\t  '$rootScope',\r\n\tfunction($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY, $rootScope) {\r\n\t  var self = this;\r\n\t  var rightShowing, leftShowing, isDragging;\r\n\t  var startX, lastX, offsetX, isAsideExposed;\r\n\t  var enableMenuWithBackViews = true;\r\n\t\r\n\t  self.$scope = $scope;\r\n\t\r\n\t  self.initialize = function(options) {\r\n\t    self.left = options.left;\r\n\t    self.right = options.right;\r\n\t    self.setContent(options.content);\r\n\t    self.dragThresholdX = options.dragThresholdX || 10;\r\n\t    $ionicHistory.registerHistory(self.$scope);\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Set the content view controller if not passed in the constructor options.\r\n\t   *\r\n\t   * @param {object} content\r\n\t   */\r\n\t  self.setContent = function(content) {\r\n\t    if (content) {\r\n\t      self.content = content;\r\n\t\r\n\t      self.content.onDrag = function(e) {\r\n\t        self._handleDrag(e);\r\n\t      };\r\n\t\r\n\t      self.content.endDrag = function(e) {\r\n\t        self._endDrag(e);\r\n\t      };\r\n\t    }\r\n\t  };\r\n\t\r\n\t  self.isOpenLeft = function() {\r\n\t    return self.getOpenAmount() > 0;\r\n\t  };\r\n\t\r\n\t  self.isOpenRight = function() {\r\n\t    return self.getOpenAmount() < 0;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Toggle the left menu to open 100%\r\n\t   */\r\n\t  self.toggleLeft = function(shouldOpen) {\r\n\t    if (isAsideExposed || !self.left.isEnabled) return;\r\n\t    var openAmount = self.getOpenAmount();\r\n\t    if (arguments.length === 0) {\r\n\t      shouldOpen = openAmount <= 0;\r\n\t    }\r\n\t    self.content.enableAnimation();\r\n\t    if (!shouldOpen) {\r\n\t      self.openPercentage(0);\r\n\t      $rootScope.$emit('$ionicSideMenuClose', 'left');\r\n\t    } else {\r\n\t      self.openPercentage(100);\r\n\t      $rootScope.$emit('$ionicSideMenuOpen', 'left');\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Toggle the right menu to open 100%\r\n\t   */\r\n\t  self.toggleRight = function(shouldOpen) {\r\n\t    if (isAsideExposed || !self.right.isEnabled) return;\r\n\t    var openAmount = self.getOpenAmount();\r\n\t    if (arguments.length === 0) {\r\n\t      shouldOpen = openAmount >= 0;\r\n\t    }\r\n\t    self.content.enableAnimation();\r\n\t    if (!shouldOpen) {\r\n\t      self.openPercentage(0);\r\n\t      $rootScope.$emit('$ionicSideMenuClose', 'right');\r\n\t    } else {\r\n\t      self.openPercentage(-100);\r\n\t      $rootScope.$emit('$ionicSideMenuOpen', 'right');\r\n\t    }\r\n\t  };\r\n\t\r\n\t  self.toggle = function(side) {\r\n\t    if (side == 'right') {\r\n\t      self.toggleRight();\r\n\t    } else {\r\n\t      self.toggleLeft();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Close all menus.\r\n\t   */\r\n\t  self.close = function() {\r\n\t    self.openPercentage(0);\r\n\t    $rootScope.$emit('$ionicSideMenuClose', 'left');\r\n\t    $rootScope.$emit('$ionicSideMenuClose', 'right');\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * @return {float} The amount the side menu is open, either positive or negative for left (positive), or right (negative)\r\n\t   */\r\n\t  self.getOpenAmount = function() {\r\n\t    return self.content && self.content.getTranslateX() || 0;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * @return {float} The ratio of open amount over menu width. For example, a\r\n\t   * menu of width 100 open 50 pixels would be open 50% or a ratio of 0.5. Value is negative\r\n\t   * for right menu.\r\n\t   */\r\n\t  self.getOpenRatio = function() {\r\n\t    var amount = self.getOpenAmount();\r\n\t    if (amount >= 0) {\r\n\t      return amount / self.left.width;\r\n\t    }\r\n\t    return amount / self.right.width;\r\n\t  };\r\n\t\r\n\t  self.isOpen = function() {\r\n\t    return self.getOpenAmount() !== 0;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * @return {float} The percentage of open amount over menu width. For example, a\r\n\t   * menu of width 100 open 50 pixels would be open 50%. Value is negative\r\n\t   * for right menu.\r\n\t   */\r\n\t  self.getOpenPercentage = function() {\r\n\t    return self.getOpenRatio() * 100;\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Open the menu with a given percentage amount.\r\n\t   * @param {float} percentage The percentage (positive or negative for left/right) to open the menu.\r\n\t   */\r\n\t  self.openPercentage = function(percentage) {\r\n\t    var p = percentage / 100;\r\n\t\r\n\t    if (self.left && percentage >= 0) {\r\n\t      self.openAmount(self.left.width * p);\r\n\t    } else if (self.right && percentage < 0) {\r\n\t      self.openAmount(self.right.width * p);\r\n\t    }\r\n\t\r\n\t    // add the CSS class \"menu-open\" if the percentage does not\r\n\t    // equal 0, otherwise remove the class from the body element\r\n\t    $ionicBody.enableClass((percentage !== 0), 'menu-open');\r\n\t\r\n\t    self.content.setCanScroll(percentage == 0);\r\n\t  };\r\n\t\r\n\t  /*\r\n\t  function freezeAllScrolls(shouldFreeze) {\r\n\t    if (shouldFreeze && !self.isScrollFreeze) {\r\n\t      $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);\r\n\t\r\n\t    } else if (!shouldFreeze && self.isScrollFreeze) {\r\n\t      $ionicScrollDelegate.freezeAllScrolls(false);\r\n\t    }\r\n\t    self.isScrollFreeze = shouldFreeze;\r\n\t  }\r\n\t  */\r\n\t\r\n\t  /**\r\n\t   * Open the menu the given pixel amount.\r\n\t   * @param {float} amount the pixel amount to open the menu. Positive value for left menu,\r\n\t   * negative value for right menu (only one menu will be visible at a time).\r\n\t   */\r\n\t  self.openAmount = function(amount) {\r\n\t    var maxLeft = self.left && self.left.width || 0;\r\n\t    var maxRight = self.right && self.right.width || 0;\r\n\t\r\n\t    // Check if we can move to that side, depending if the left/right panel is enabled\r\n\t    if (!(self.left && self.left.isEnabled) && amount > 0) {\r\n\t      self.content.setTranslateX(0);\r\n\t      return;\r\n\t    }\r\n\t\r\n\t    if (!(self.right && self.right.isEnabled) && amount < 0) {\r\n\t      self.content.setTranslateX(0);\r\n\t      return;\r\n\t    }\r\n\t\r\n\t    if (leftShowing && amount > maxLeft) {\r\n\t      self.content.setTranslateX(maxLeft);\r\n\t      return;\r\n\t    }\r\n\t\r\n\t    if (rightShowing && amount < -maxRight) {\r\n\t      self.content.setTranslateX(-maxRight);\r\n\t      return;\r\n\t    }\r\n\t\r\n\t    self.content.setTranslateX(amount);\r\n\t\r\n\t    if (amount >= 0) {\r\n\t      leftShowing = true;\r\n\t      rightShowing = false;\r\n\t\r\n\t      if (amount > 0) {\r\n\t        // Push the z-index of the right menu down\r\n\t        self.right && self.right.pushDown && self.right.pushDown();\r\n\t        // Bring the z-index of the left menu up\r\n\t        self.left && self.left.bringUp && self.left.bringUp();\r\n\t      }\r\n\t    } else {\r\n\t      rightShowing = true;\r\n\t      leftShowing = false;\r\n\t\r\n\t      // Bring the z-index of the right menu up\r\n\t      self.right && self.right.bringUp && self.right.bringUp();\r\n\t      // Push the z-index of the left menu down\r\n\t      self.left && self.left.pushDown && self.left.pushDown();\r\n\t    }\r\n\t  };\r\n\t\r\n\t  /**\r\n\t   * Given an event object, find the final resting position of this side\r\n\t   * menu. For example, if the user \"throws\" the content to the right and\r\n\t   * releases the touch, the left menu should snap open (animated, of course).\r\n\t   *\r\n\t   * @param {Event} e the gesture event to use for snapping\r\n\t   */\r\n\t  self.snapToRest = function(e) {\r\n\t    // We want to animate at the end of this\r\n\t    self.content.enableAnimation();\r\n\t    isDragging = false;\r\n\t\r\n\t    // Check how much the panel is open after the drag, and\r\n\t    // what the drag velocity is\r\n\t    var ratio = self.getOpenRatio();\r\n\t\r\n\t    if (ratio === 0) {\r\n\t      // Just to be safe\r\n\t      self.openPercentage(0);\r\n\t      return;\r\n\t    }\r\n\t\r\n\t    var velocityThreshold = 0.3;\r\n\t    var velocityX = e.gesture.velocityX;\r\n\t    var direction = e.gesture.direction;\r\n\t\r\n\t    // Going right, less than half, too slow (snap back)\r\n\t    if (ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {\r\n\t      self.openPercentage(0);\r\n\t    }\r\n\t\r\n\t    // Going left, more than half, too slow (snap back)\r\n\t    else if (ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {\r\n\t      self.openPercentage(100);\r\n\t    }\r\n\t\r\n\t    // Going left, less than half, too slow (snap back)\r\n\t    else if (ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {\r\n\t      self.openPercentage(0);\r\n\t    }\r\n\t\r\n\t    // Going right, more than half, too slow (snap back)\r\n\t    else if (ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {\r\n\t      self.openPercentage(-100);\r\n\t    }\r\n\t\r\n\t    // Going right, more than half, or quickly (snap open)\r\n\t    else if (direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {\r\n\t      self.openPercentage(100);\r\n\t    }\r\n\t\r\n\t    // Going left, more than half, or quickly (span open)\r\n\t    else if (direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {\r\n\t      self.openPercentage(-100);\r\n\t    }\r\n\t\r\n\t    // Snap back for safety\r\n\t    else {\r\n\t      self.openPercentage(0);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  self.enableMenuWithBackViews = function(val) {\r\n\t    if (arguments.length) {\r\n\t      enableMenuWithBackViews = !!val;\r\n\t    }\r\n\t    return enableMenuWithBackViews;\r\n\t  };\r\n\t\r\n\t  self.isAsideExposed = function() {\r\n\t    return !!isAsideExposed;\r\n\t  };\r\n\t\r\n\t  self.exposeAside = function(shouldExposeAside) {\r\n\t    if (!(self.left && self.left.isEnabled) && !(self.right && self.right.isEnabled)) return;\r\n\t    self.close();\r\n\t\r\n\t    isAsideExposed = shouldExposeAside;\r\n\t    if ((self.left && self.left.isEnabled) && (self.right && self.right.isEnabled)) {\r\n\t      self.content.setMarginLeftAndRight(isAsideExposed ? self.left.width : 0, isAsideExposed ? self.right.width : 0);\r\n\t    } else if (self.left && self.left.isEnabled) {\r\n\t      // set the left marget width if it should be exposed\r\n\t      // otherwise set false so there's no left margin\r\n\t      self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);\r\n\t    } else if (self.right && self.right.isEnabled) {\r\n\t      self.content.setMarginRight(isAsideExposed ? self.right.width : 0);\r\n\t    }\r\n\t    self.$scope.$emit('$ionicExposeAside', isAsideExposed);\r\n\t  };\r\n\t\r\n\t  self.activeAsideResizing = function(isResizing) {\r\n\t    $ionicBody.enableClass(isResizing, 'aside-resizing');\r\n\t  };\r\n\t\r\n\t  // End a drag with the given event\r\n\t  self._endDrag = function(e) {\r\n\t    if (isAsideExposed) return;\r\n\t\r\n\t    if (isDragging) {\r\n\t      self.snapToRest(e);\r\n\t    }\r\n\t    startX = null;\r\n\t    lastX = null;\r\n\t    offsetX = null;\r\n\t  };\r\n\t\r\n\t  // Handle a drag event\r\n\t  self._handleDrag = function(e) {\r\n\t    if (isAsideExposed || !$scope.dragContent) return;\r\n\t\r\n\t    // If we don't have start coords, grab and store them\r\n\t    if (!startX) {\r\n\t      startX = e.gesture.touches[0].pageX;\r\n\t      lastX = startX;\r\n\t    } else {\r\n\t      // Grab the current tap coords\r\n\t      lastX = e.gesture.touches[0].pageX;\r\n\t    }\r\n\t\r\n\t    // Calculate difference from the tap points\r\n\t    if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {\r\n\t      // if the difference is greater than threshold, start dragging using the current\r\n\t      // point as the starting point\r\n\t      startX = lastX;\r\n\t\r\n\t      isDragging = true;\r\n\t      // Initialize dragging\r\n\t      self.content.disableAnimation();\r\n\t      offsetX = self.getOpenAmount();\r\n\t    }\r\n\t\r\n\t    if (isDragging) {\r\n\t      self.openAmount(offsetX + (lastX - startX));\r\n\t      //self.content.setCanScroll(false);\r\n\t    }\r\n\t  };\r\n\t\r\n\t  self.canDragContent = function(canDrag) {\r\n\t    if (arguments.length) {\r\n\t      $scope.dragContent = !!canDrag;\r\n\t    }\r\n\t    return $scope.dragContent;\r\n\t  };\r\n\t\r\n\t  self.edgeThreshold = 25;\r\n\t  self.edgeThresholdEnabled = false;\r\n\t  self.edgeDragThreshold = function(value) {\r\n\t    if (arguments.length) {\r\n\t      if (isNumber(value) && value > 0) {\r\n\t        self.edgeThreshold = value;\r\n\t        self.edgeThresholdEnabled = true;\r\n\t      } else {\r\n\t        self.edgeThresholdEnabled = !!value;\r\n\t      }\r\n\t    }\r\n\t    return self.edgeThresholdEnabled;\r\n\t  };\r\n\t\r\n\t  self.isDraggableTarget = function(e) {\r\n\t    //Only restrict edge when sidemenu is closed and restriction is enabled\r\n\t    var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();\r\n\t    var startX = e.gesture.startEvent && e.gesture.startEvent.center &&\r\n\t      e.gesture.startEvent.center.pageX;\r\n\t\r\n\t    var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag ||\r\n\t      startX <= self.edgeThreshold ||\r\n\t      startX >= self.content.element.offsetWidth - self.edgeThreshold;\r\n\t\r\n\t    var backView = $ionicHistory.backView();\r\n\t    var menuEnabled = enableMenuWithBackViews ? true : !backView;\r\n\t    if (!menuEnabled) {\r\n\t      var currentView = $ionicHistory.currentView() || {};\r\n\t      return (dragIsWithinBounds && (backView.historyId !== currentView.historyId));\r\n\t    }\r\n\t\r\n\t    return ($scope.dragContent || self.isOpen()) &&\r\n\t      dragIsWithinBounds &&\r\n\t      !e.gesture.srcEvent.defaultPrevented &&\r\n\t      menuEnabled &&\r\n\t      !e.target.tagName.match(/input|textarea|select|object|embed/i) &&\r\n\t      !e.target.isContentEditable &&\r\n\t      !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll') == 'true');\r\n\t  };\r\n\t\r\n\t  $scope.sideMenuContentTranslateX = 0;\r\n\t\r\n\t  var deregisterBackButtonAction = noop;\r\n\t  var closeSideMenu = angular.bind(self, self.close);\r\n\t\r\n\t  $scope.$watch(function() {\r\n\t    return self.getOpenAmount() !== 0;\r\n\t  }, function(isOpen) {\r\n\t    deregisterBackButtonAction();\r\n\t    if (isOpen) {\r\n\t      deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(\r\n\t        closeSideMenu,\r\n\t        IONIC_BACK_PRIORITY.sideMenu\r\n\t      );\r\n\t    }\r\n\t  });\r\n\t\r\n\t  var deregisterInstance = $ionicSideMenuDelegate._registerInstance(\r\n\t    self, $attrs.delegateHandle, function() {\r\n\t      return $ionicHistory.isActiveScope($scope);\r\n\t    }\r\n\t  );\r\n\t\r\n\t  $scope.$on('$destroy', function() {\r\n\t    deregisterInstance();\r\n\t    deregisterBackButtonAction();\r\n\t    self.$scope = null;\r\n\t    if (self.content) {\r\n\t      self.content.setCanScroll(true);\r\n\t      self.content.element = null;\r\n\t      self.content = null;\r\n\t    }\r\n\t  });\r\n\t\r\n\t  self.initialize({\r\n\t    left: {\r\n\t      width: 275\r\n\t    },\r\n\t    right: {\r\n\t      width: 275\r\n\t    }\r\n\t  });\r\n\t\r\n\t}]);\r\n\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t(function(ionic) {\n\t\n\t  var TRANSLATE32 = 'translate(32,32)';\n\t  var STROKE_OPACITY = 'stroke-opacity';\n\t  var ROUND = 'round';\n\t  var INDEFINITE = 'indefinite';\n\t  var DURATION = '750ms';\n\t  var NONE = 'none';\n\t  var SHORTCUTS = {\n\t    a: 'animate',\n\t    an: 'attributeName',\n\t    at: 'animateTransform',\n\t    c: 'circle',\n\t    da: 'stroke-dasharray',\n\t    os: 'stroke-dashoffset',\n\t    f: 'fill',\n\t    lc: 'stroke-linecap',\n\t    rc: 'repeatCount',\n\t    sw: 'stroke-width',\n\t    t: 'transform',\n\t    v: 'values'\n\t  };\n\t\n\t  var SPIN_ANIMATION = {\n\t    v: '0,32,32;360,32,32',\n\t    an: 'transform',\n\t    type: 'rotate',\n\t    rc: INDEFINITE,\n\t    dur: DURATION\n\t  };\n\t\n\t  function createSvgElement(tagName, data, parent, spinnerName) {\n\t    var ele = document.createElement(SHORTCUTS[tagName] || tagName);\n\t    var k, x, y;\n\t\n\t    for (k in data) {\n\t\n\t      if (angular.isArray(data[k])) {\n\t        for (x = 0; x < data[k].length; x++) {\n\t          if (data[k][x].fn) {\n\t            for (y = 0; y < data[k][x].t; y++) {\n\t              createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName);\n\t            }\n\t          } else {\n\t            createSvgElement(k, data[k][x], ele, spinnerName);\n\t          }\n\t        }\n\t\n\t      } else {\n\t        setSvgAttribute(ele, k, data[k]);\n\t      }\n\t    }\n\t\n\t    parent.appendChild(ele);\n\t  }\n\t\n\t  function setSvgAttribute(ele, k, v) {\n\t    ele.setAttribute(SHORTCUTS[k] || k, v);\n\t  }\n\t\n\t  function animationValues(strValues, i) {\n\t    var values = strValues.split(';');\n\t    var back = values.slice(i);\n\t    var front = values.slice(0, values.length - back.length);\n\t    values = back.concat(front).reverse();\n\t    return values.join(';') + ';' + values[0];\n\t  }\n\t\n\t  var IOS_SPINNER = {\n\t    sw: 4,\n\t    lc: ROUND,\n\t    line: [{\n\t      fn: function(i, spinnerName) {\n\t        return {\n\t          y1: spinnerName == 'ios' ? 17 : 12,\n\t          y2: spinnerName == 'ios' ? 29 : 20,\n\t          t: TRANSLATE32 + ' rotate(' + (30 * i + (i < 6 ? 180 : -180)) + ')',\n\t          a: [{\n\t            fn: function() {\n\t              return {\n\t                an: STROKE_OPACITY,\n\t                dur: DURATION,\n\t                v: animationValues('0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1', i),\n\t                rc: INDEFINITE\n\t              };\n\t            },\n\t            t: 1\n\t          }]\n\t        };\n\t      },\n\t      t: 12\n\t    }]\n\t  };\n\t\n\t  var spinners = {\n\t\n\t    android: {\n\t      c: [{\n\t        sw: 6,\n\t        da: 128,\n\t        os: 82,\n\t        r: 26,\n\t        cx: 32,\n\t        cy: 32,\n\t        f: NONE\n\t      }]\n\t    },\n\t\n\t    ios: IOS_SPINNER,\n\t\n\t    'ios-small': IOS_SPINNER,\n\t\n\t    bubbles: {\n\t      sw: 0,\n\t      c: [{\n\t        fn: function(i) {\n\t          return {\n\t            cx: 24 * Math.cos(2 * Math.PI * i / 8),\n\t            cy: 24 * Math.sin(2 * Math.PI * i / 8),\n\t            t: TRANSLATE32,\n\t            a: [{\n\t              fn: function() {\n\t                return {\n\t                  an: 'r',\n\t                  dur: DURATION,\n\t                  v: animationValues('1;2;3;4;5;6;7;8', i),\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }]\n\t          };\n\t        },\n\t        t: 8\n\t      }]\n\t    },\n\t\n\t    circles: {\n\t\n\t      c: [{\n\t        fn: function(i) {\n\t          return {\n\t            r: 5,\n\t            cx: 24 * Math.cos(2 * Math.PI * i / 8),\n\t            cy: 24 * Math.sin(2 * Math.PI * i / 8),\n\t            t: TRANSLATE32,\n\t            sw: 0,\n\t            a: [{\n\t              fn: function() {\n\t                return {\n\t                  an: 'fill-opacity',\n\t                  dur: DURATION,\n\t                  v: animationValues('.3;.3;.3;.4;.7;.85;.9;1', i),\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }]\n\t          };\n\t        },\n\t        t: 8\n\t      }]\n\t    },\n\t\n\t    crescent: {\n\t      c: [{\n\t        sw: 4,\n\t        da: 128,\n\t        os: 82,\n\t        r: 26,\n\t        cx: 32,\n\t        cy: 32,\n\t        f: NONE,\n\t        at: [SPIN_ANIMATION]\n\t      }]\n\t    },\n\t\n\t    dots: {\n\t\n\t      c: [{\n\t        fn: function(i) {\n\t          return {\n\t            cx: 16 + (16 * i),\n\t            cy: 32,\n\t            sw: 0,\n\t            a: [{\n\t              fn: function() {\n\t                return {\n\t                  an: 'fill-opacity',\n\t                  dur: DURATION,\n\t                  v: animationValues('.5;.6;.8;1;.8;.6;.5', i),\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }, {\n\t              fn: function() {\n\t                return {\n\t                  an: 'r',\n\t                  dur: DURATION,\n\t                  v: animationValues('4;5;6;5;4;3;3', i),\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }]\n\t          };\n\t        },\n\t        t: 3\n\t      }]\n\t    },\n\t\n\t    lines: {\n\t      sw: 7,\n\t      lc: ROUND,\n\t      line: [{\n\t        fn: function(i) {\n\t          return {\n\t            x1: 10 + (i * 14),\n\t            x2: 10 + (i * 14),\n\t            a: [{\n\t              fn: function() {\n\t                return {\n\t                  an: 'y1',\n\t                  dur: DURATION,\n\t                  v: animationValues('16;18;28;18;16', i),\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }, {\n\t              fn: function() {\n\t                return {\n\t                  an: 'y2',\n\t                  dur: DURATION,\n\t                  v: animationValues('48;44;36;46;48', i),\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }, {\n\t              fn: function() {\n\t                return {\n\t                  an: STROKE_OPACITY,\n\t                  dur: DURATION,\n\t                  v: animationValues('1;.8;.5;.4;1', i),\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }]\n\t          };\n\t        },\n\t        t: 4\n\t      }]\n\t    },\n\t\n\t    ripple: {\n\t      f: NONE,\n\t      'fill-rule': 'evenodd',\n\t      sw: 3,\n\t      circle: [{\n\t        fn: function(i) {\n\t          return {\n\t            cx: 32,\n\t            cy: 32,\n\t            a: [{\n\t              fn: function() {\n\t                return {\n\t                  an: 'r',\n\t                  begin: (i * -1) + 's',\n\t                  dur: '2s',\n\t                  v: '0;24',\n\t                  keyTimes: '0;1',\n\t                  keySplines: '0.1,0.2,0.3,1',\n\t                  calcMode: 'spline',\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }, {\n\t              fn: function() {\n\t                return {\n\t                  an: STROKE_OPACITY,\n\t                  begin: (i * -1) + 's',\n\t                  dur: '2s',\n\t                  v: '.2;1;.2;0',\n\t                  rc: INDEFINITE\n\t                };\n\t              },\n\t              t: 1\n\t            }]\n\t          };\n\t        },\n\t        t: 2\n\t      }]\n\t    },\n\t\n\t    spiral: {\n\t      defs: [{\n\t        linearGradient: [{\n\t          id: 'sGD',\n\t          gradientUnits: 'userSpaceOnUse',\n\t          x1: 55, y1: 46, x2: 2, y2: 46,\n\t          stop: [{\n\t            offset: 0.1,\n\t            class: 'stop1'\n\t          }, {\n\t            offset: 1,\n\t            class: 'stop2'\n\t          }]\n\t        }]\n\t      }],\n\t      g: [{\n\t        sw: 4,\n\t        lc: ROUND,\n\t        f: NONE,\n\t        path: [{\n\t          stroke: 'url(#sGD)',\n\t          d: 'M4,32 c0,15,12,28,28,28c8,0,16-4,21-9'\n\t        }, {\n\t          d: 'M60,32 C60,16,47.464,4,32,4S4,16,4,32'\n\t        }],\n\t        at: [SPIN_ANIMATION]\n\t      }]\n\t    }\n\t\n\t  };\n\t\n\t  var animations = {\n\t\n\t    android: function(ele) {\n\t      var self = this;\n\t\n\t      this.stop = false;\n\t\n\t      var rIndex = 0;\n\t      var rotateCircle = 0;\n\t      var startTime;\n\t      var svgEle = ele.querySelector('g');\n\t      var circleEle = ele.querySelector('circle');\n\t\n\t      function run() {\n\t        if (self.stop) return;\n\t\n\t        var v = easeInOutCubic(Date.now() - startTime, 650);\n\t        var scaleX = 1;\n\t        var translateX = 0;\n\t        var dasharray = (188 - (58 * v));\n\t        var dashoffset = (182 - (182 * v));\n\t\n\t        if (rIndex % 2) {\n\t          scaleX = -1;\n\t          translateX = -64;\n\t          dasharray = (128 - (-58 * v));\n\t          dashoffset = (182 * v);\n\t        }\n\t\n\t        var rotateLine = [0, -101, -90, -11, -180, 79, -270, -191][rIndex];\n\t\n\t        setSvgAttribute(circleEle, 'da', Math.max(Math.min(dasharray, 188), 128));\n\t        setSvgAttribute(circleEle, 'os', Math.max(Math.min(dashoffset, 182), 0));\n\t        setSvgAttribute(circleEle, 't', 'scale(' + scaleX + ',1) translate(' + translateX + ',0) rotate(' + rotateLine + ',32,32)');\n\t\n\t        rotateCircle += 4.1;\n\t        if (rotateCircle > 359) rotateCircle = 0;\n\t        setSvgAttribute(svgEle, 't', 'rotate(' + rotateCircle + ',32,32)');\n\t\n\t        if (v >= 1) {\n\t          rIndex++;\n\t          if (rIndex > 7) rIndex = 0;\n\t          startTime = Date.now();\n\t        }\n\t\n\t        ionic.requestAnimationFrame(run);\n\t      }\n\t\n\t      return function() {\n\t        startTime = Date.now();\n\t        run();\n\t        return self;\n\t      };\n\t\n\t    }\n\t\n\t  };\n\t\n\t  function easeInOutCubic(t, c) {\n\t    t /= c / 2;\n\t    if (t < 1) return 1 / 2 * t * t * t;\n\t    t -= 2;\n\t    return 1 / 2 * (t * t * t + 2);\n\t  }\n\t\n\t\n\t  IonicModule\n\t  .controller('$ionicSpinner', [\n\t    '$element',\n\t    '$attrs',\n\t    '$ionicConfig',\n\t  function($element, $attrs, $ionicConfig) {\n\t    var spinnerName, anim;\n\t\n\t    this.init = function() {\n\t      spinnerName = $attrs.icon || $ionicConfig.spinner.icon();\n\t\n\t      var container = document.createElement('div');\n\t      createSvgElement('svg', {\n\t        viewBox: '0 0 64 64',\n\t        g: [spinners[spinnerName]]\n\t      }, container, spinnerName);\n\t\n\t      // Specifically for animations to work,\n\t      // Android 4.3 and below requires the element to be\n\t      // added as an html string, rather than dynmically\n\t      // building up the svg element and appending it.\n\t      $element.html(container.innerHTML);\n\t\n\t      this.start();\n\t\n\t      return spinnerName;\n\t    };\n\t\n\t    this.start = function() {\n\t      animations[spinnerName] && (anim = animations[spinnerName]($element[0])());\n\t    };\n\t\n\t    this.stop = function() {\n\t      animations[spinnerName] && (anim.stop = true);\n\t    };\n\t\n\t  }]);\n\t\n\t})(ionic);\n\n\n/***/ },\n/* 39 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.controller('$ionicTab', [\n\t  '$scope',\n\t  '$ionicHistory',\n\t  '$attrs',\n\t  '$location',\n\t  '$state',\n\tfunction($scope, $ionicHistory, $attrs, $location, $state) {\n\t  this.$scope = $scope;\n\t\n\t  //All of these exposed for testing\n\t  this.hrefMatchesState = function() {\n\t    return $attrs.href && $location.path().indexOf(\n\t      $attrs.href.replace(/^#/, '').replace(/\\/$/, '')\n\t    ) === 0;\n\t  };\n\t  this.srefMatchesState = function() {\n\t    return $attrs.uiSref && $state.includes($attrs.uiSref.split('(')[0]);\n\t  };\n\t  this.navNameMatchesState = function() {\n\t    return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);\n\t  };\n\t\n\t  this.tabMatchesState = function() {\n\t    return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();\n\t  };\n\t}]);\n\n\n/***/ },\n/* 40 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.controller('$ionicTabs', [\n\t  '$scope',\n\t  '$element',\n\t  '$ionicHistory',\n\tfunction($scope, $element, $ionicHistory) {\n\t  var self = this;\n\t  var selectedTab = null;\n\t  var previousSelectedTab = null;\n\t  var selectedTabIndex;\n\t  var isVisible = true;\n\t  self.tabs = [];\n\t\n\t  self.selectedIndex = function() {\n\t    return self.tabs.indexOf(selectedTab);\n\t  };\n\t  self.selectedTab = function() {\n\t    return selectedTab;\n\t  };\n\t  self.previousSelectedTab = function() {\n\t    return previousSelectedTab;\n\t  };\n\t\n\t  self.add = function(tab) {\n\t    $ionicHistory.registerHistory(tab);\n\t    self.tabs.push(tab);\n\t  };\n\t\n\t  self.remove = function(tab) {\n\t    var tabIndex = self.tabs.indexOf(tab);\n\t    if (tabIndex === -1) {\n\t      return;\n\t    }\n\t    //Use a field like '$tabSelected' so developers won't accidentally set it in controllers etc\n\t    if (tab.$tabSelected) {\n\t      self.deselect(tab);\n\t      //Try to select a new tab if we're removing a tab\n\t      if (self.tabs.length === 1) {\n\t        //Do nothing if there are no other tabs to select\n\t      } else {\n\t        //Select previous tab if it's the last tab, else select next tab\n\t        var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;\n\t        self.select(self.tabs[newTabIndex]);\n\t      }\n\t    }\n\t    self.tabs.splice(tabIndex, 1);\n\t  };\n\t\n\t  self.deselect = function(tab) {\n\t    if (tab.$tabSelected) {\n\t      previousSelectedTab = selectedTab;\n\t      selectedTab = selectedTabIndex = null;\n\t      tab.$tabSelected = false;\n\t      (tab.onDeselect || noop)();\n\t      tab.$broadcast && tab.$broadcast('$ionicHistory.deselect');\n\t    }\n\t  };\n\t\n\t  self.select = function(tab, shouldEmitEvent) {\n\t    var tabIndex;\n\t    if (isNumber(tab)) {\n\t      tabIndex = tab;\n\t      if (tabIndex >= self.tabs.length) return;\n\t      tab = self.tabs[tabIndex];\n\t    } else {\n\t      tabIndex = self.tabs.indexOf(tab);\n\t    }\n\t\n\t    if (arguments.length === 1) {\n\t      shouldEmitEvent = !!(tab.navViewName || tab.uiSref);\n\t    }\n\t\n\t    if (selectedTab && selectedTab.$historyId == tab.$historyId) {\n\t      if (shouldEmitEvent) {\n\t        $ionicHistory.goToHistoryRoot(tab.$historyId);\n\t      }\n\t\n\t    } else if (selectedTabIndex !== tabIndex) {\n\t      forEach(self.tabs, function(tab) {\n\t        self.deselect(tab);\n\t      });\n\t\n\t      selectedTab = tab;\n\t      selectedTabIndex = tabIndex;\n\t\n\t      if (self.$scope && self.$scope.$parent) {\n\t        self.$scope.$parent.$activeHistoryId = tab.$historyId;\n\t      }\n\t\n\t      //Use a funny name like $tabSelected so the developer doesn't overwrite the var in a child scope\n\t      tab.$tabSelected = true;\n\t      (tab.onSelect || noop)();\n\t\n\t      if (shouldEmitEvent) {\n\t        $scope.$emit('$ionicHistory.change', {\n\t          type: 'tab',\n\t          tabIndex: tabIndex,\n\t          historyId: tab.$historyId,\n\t          navViewName: tab.navViewName,\n\t          hasNavView: !!tab.navViewName,\n\t          title: tab.title,\n\t          url: tab.href,\n\t          uiSref: tab.uiSref\n\t        });\n\t      }\n\t    }\n\t  };\n\t\n\t  self.hasActiveScope = function() {\n\t    for (var x = 0; x < self.tabs.length; x++) {\n\t      if ($ionicHistory.isActiveScope(self.tabs[x])) {\n\t        return true;\n\t      }\n\t    }\n\t    return false;\n\t  };\n\t\n\t  self.showBar = function(show) {\n\t    if (arguments.length) {\n\t      if (show) {\n\t        $element.removeClass('tabs-item-hide');\n\t      } else {\n\t        $element.addClass('tabs-item-hide');\n\t      }\n\t      isVisible = !!show;\n\t    }\n\t    return isVisible;\n\t  };\n\t}]);\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.controller('$ionicView', [\n\t  '$scope',\n\t  '$element',\n\t  '$attrs',\n\t  '$compile',\n\t  '$rootScope',\n\tfunction($scope, $element, $attrs, $compile, $rootScope) {\n\t  var self = this;\n\t  var navElementHtml = {};\n\t  var navViewCtrl;\n\t  var navBarDelegateHandle;\n\t  var hasViewHeaderBar;\n\t  var deregisters = [];\n\t  var viewTitle;\n\t\n\t  var deregIonNavBarInit = $scope.$on('ionNavBar.init', function(ev, delegateHandle) {\n\t    // this view has its own ion-nav-bar, remember the navBarDelegateHandle for this view\n\t    ev.stopPropagation();\n\t    navBarDelegateHandle = delegateHandle;\n\t  });\n\t\n\t\n\t  self.init = function() {\n\t    deregIonNavBarInit();\n\t\n\t    var modalCtrl = $element.inheritedData('$ionModalController');\n\t    navViewCtrl = $element.inheritedData('$ionNavViewController');\n\t\n\t    // don't bother if inside a modal or there's no parent navView\n\t    if (!navViewCtrl || modalCtrl) return;\n\t\n\t    // add listeners for when this view changes\n\t    $scope.$on('$ionicView.beforeEnter', self.beforeEnter);\n\t    $scope.$on('$ionicView.afterEnter', afterEnter);\n\t    $scope.$on('$ionicView.beforeLeave', deregisterFns);\n\t  };\n\t\n\t  self.beforeEnter = function(ev, transData) {\n\t    // this event was emitted, starting at intial ion-view, then bubbles up\n\t    // only the first ion-view should do something with it, parent ion-views should ignore\n\t    if (transData && !transData.viewNotified) {\n\t      transData.viewNotified = true;\n\t\n\t      if (!$rootScope.$$phase) $scope.$digest();\n\t      viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;\n\t\n\t      var navBarItems = {};\n\t      for (var n in navElementHtml) {\n\t        navBarItems[n] = generateNavBarItem(navElementHtml[n]);\n\t      }\n\t\n\t      navViewCtrl.beforeEnter(extend(transData, {\n\t        title: viewTitle,\n\t        showBack: !attrTrue('hideBackButton'),\n\t        navBarItems: navBarItems,\n\t        navBarDelegate: navBarDelegateHandle || null,\n\t        showNavBar: !attrTrue('hideNavBar'),\n\t        hasHeaderBar: !!hasViewHeaderBar\n\t      }));\n\t\n\t      // make sure any existing observers are cleaned up\n\t      deregisterFns();\n\t    }\n\t  };\n\t\n\t\n\t  function afterEnter() {\n\t    // only listen for title updates after it has entered\n\t    // but also deregister the observe before it leaves\n\t    var viewTitleAttr = isDefined($attrs.viewTitle) && 'viewTitle' || isDefined($attrs.title) && 'title';\n\t    if (viewTitleAttr) {\n\t      titleUpdate($attrs[viewTitleAttr]);\n\t      deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate));\n\t    }\n\t\n\t    if (isDefined($attrs.hideBackButton)) {\n\t      deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {\n\t        navViewCtrl.showBackButton(!val);\n\t      }));\n\t    }\n\t\n\t    if (isDefined($attrs.hideNavBar)) {\n\t      deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {\n\t        navViewCtrl.showBar(!val);\n\t      }));\n\t    }\n\t  }\n\t\n\t\n\t  function titleUpdate(newTitle) {\n\t    if (isDefined(newTitle) && newTitle !== viewTitle) {\n\t      viewTitle = newTitle;\n\t      navViewCtrl.title(viewTitle);\n\t    }\n\t  }\n\t\n\t\n\t  function deregisterFns() {\n\t    // remove all existing $attrs.$observe's\n\t    for (var x = 0; x < deregisters.length; x++) {\n\t      deregisters[x]();\n\t    }\n\t    deregisters = [];\n\t  }\n\t\n\t\n\t  function generateNavBarItem(html) {\n\t    if (html) {\n\t      // every time a view enters we need to recreate its view buttons if they exist\n\t      return $compile(html)($scope.$new());\n\t    }\n\t  }\n\t\n\t\n\t  function attrTrue(key) {\n\t    return !!$scope.$eval($attrs[key]);\n\t  }\n\t\n\t\n\t  self.navElement = function(type, html) {\n\t    navElementHtml[type] = html;\n\t  };\n\t\n\t}]);\n\n\n/***/ },\n/* 42 */\n/***/ function(module, exports) {\n\n\t/*\n\t * We don't document the ionActionSheet directive, we instead document\n\t * the $ionicActionSheet service\n\t */\n\tIonicModule\n\t.directive('ionActionSheet', ['$document', function($document) {\n\t  return {\n\t    restrict: 'E',\n\t    scope: true,\n\t    replace: true,\n\t    link: function($scope, $element) {\n\t\n\t      var keyUp = function(e) {\n\t        if (e.which == 27) {\n\t          $scope.cancel();\n\t          $scope.$apply();\n\t        }\n\t      };\n\t\n\t      var backdropClick = function(e) {\n\t        if (e.target == $element[0]) {\n\t          $scope.cancel();\n\t          $scope.$apply();\n\t        }\n\t      };\n\t      $scope.$on('$destroy', function() {\n\t        $element.remove();\n\t        $document.unbind('keyup', keyUp);\n\t      });\n\t\n\t      $document.bind('keyup', keyUp);\n\t      $element.bind('click', backdropClick);\n\t    },\n\t    template: '<div class=\"action-sheet-backdrop\">' +\n\t                '<div class=\"action-sheet-wrapper\">' +\n\t                  '<div class=\"action-sheet\" ng-class=\"{\\'action-sheet-has-icons\\': $actionSheetHasIcon}\">' +\n\t                    '<div class=\"action-sheet-group action-sheet-options\">' +\n\t                      '<div class=\"action-sheet-title\" ng-if=\"titleText\" ng-bind-html=\"titleText\"></div>' +\n\t                      '<button class=\"button action-sheet-option\" ng-click=\"buttonClicked($index)\" ng-class=\"b.className\" ng-repeat=\"b in buttons\" ng-bind-html=\"b.text\"></button>' +\n\t                      '<button class=\"button destructive action-sheet-destructive\" ng-if=\"destructiveText\" ng-click=\"destructiveButtonClicked()\" ng-bind-html=\"destructiveText\"></button>' +\n\t                    '</div>' +\n\t                    '<div class=\"action-sheet-group action-sheet-cancel\" ng-if=\"cancelText\">' +\n\t                      '<button class=\"button\" ng-click=\"cancel()\" ng-bind-html=\"cancelText\"></button>' +\n\t                    '</div>' +\n\t                  '</div>' +\n\t                '</div>' +\n\t              '</div>'\n\t  };\n\t}]);\n\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ionCheckbox\n\t * @module ionic\n\t * @restrict E\n\t * @codepen hqcju\n\t * @description\n\t * The checkbox is no different than the HTML checkbox input, except it's styled differently.\n\t *\n\t * The checkbox behaves like any [AngularJS checkbox](http://docs.angularjs.org/api/ng/input/input[checkbox]).\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-checkbox ng-model=\"isChecked\">Checkbox Label</ion-checkbox>\n\t * ```\n\t */\n\t\n\tIonicModule\n\t.directive('ionCheckbox', ['$ionicConfig', function($ionicConfig) {\n\t  return {\n\t    restrict: 'E',\n\t    replace: true,\n\t    require: '?ngModel',\n\t    transclude: true,\n\t    template:\n\t      '<label class=\"item item-checkbox\">' +\n\t        '<div class=\"checkbox checkbox-input-hidden disable-pointer-events\">' +\n\t          '<input type=\"checkbox\">' +\n\t          '<i class=\"checkbox-icon\"></i>' +\n\t        '</div>' +\n\t        '<div class=\"item-content disable-pointer-events\" ng-transclude></div>' +\n\t      '</label>',\n\t    compile: function(element, attr) {\n\t      var input = element.find('input');\n\t      forEach({\n\t        'name': attr.name,\n\t        'ng-value': attr.ngValue,\n\t        'ng-model': attr.ngModel,\n\t        'ng-checked': attr.ngChecked,\n\t        'ng-disabled': attr.ngDisabled,\n\t        'ng-true-value': attr.ngTrueValue,\n\t        'ng-false-value': attr.ngFalseValue,\n\t        'ng-change': attr.ngChange,\n\t        'ng-required': attr.ngRequired,\n\t        'required': attr.required\n\t      }, function(value, name) {\n\t        if (isDefined(value)) {\n\t          input.attr(name, value);\n\t        }\n\t      });\n\t      var checkboxWrapper = element[0].querySelector('.checkbox');\n\t      checkboxWrapper.classList.add('checkbox-' + $ionicConfig.form.checkbox());\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 44 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc directive\n\t * @restrict A\n\t * @name collectionRepeat\n\t * @module ionic\n\t * @codepen 7ec1ec58f2489ab8f359fa1a0fe89c15\n\t * @description\n\t * `collection-repeat` allows an app to show huge lists of items much more performantly than\n\t * `ng-repeat`.\n\t *\n\t * It renders into the DOM only as many items as are currently visible.\n\t *\n\t * This means that on a phone screen that can fit eight items, only the eight items matching\n\t * the current scroll position will be rendered.\n\t *\n\t * **The Basics**:\n\t *\n\t * - The data given to collection-repeat must be an array.\n\t * - If the `item-height` and `item-width` attributes are not supplied, it will be assumed that\n\t *   every item in the list has the same dimensions as the first item.\n\t * - Don't use angular one-time binding (`::`) with collection-repeat. The scope of each item is\n\t *   assigned new data and re-digested as you scroll. Bindings need to update, and one-time bindings\n\t *   won't.\n\t *\n\t * **Performance Tips**:\n\t *\n\t * - The iOS webview has a performance bottleneck when switching out `<img src>` attributes.\n\t *   To increase performance of images on iOS, cache your images in advance and,\n\t *   if possible, lower the number of unique images. We're working on [a solution](https://github.com/driftyco/ionic/issues/3194).\n\t *\n\t * @usage\n\t * #### Basic Item List ([codepen](http://codepen.io/ionic/pen/0c2c35a34a8b18ad4d793fef0b081693))\n\t * ```html\n\t * <ion-content>\n\t *   <ion-item collection-repeat=\"item in items\">\n\t *     {% raw %}{{item}}{% endraw %}\n\t *   </ion-item>\n\t * </ion-content>\n\t * ```\n\t *\n\t * #### Grid of Images ([codepen](http://codepen.io/ionic/pen/5515d4efd9d66f780e96787387f41664))\n\t * ```html\n\t * <ion-content>\n\t *   <img collection-repeat=\"photo in photos\"\n\t *     item-width=\"33%\"\n\t *     item-height=\"200px\"\n\t *     ng-src=\"{% raw %}{{photo.url}}{% endraw %}\">\n\t * </ion-content>\n\t * ```\n\t *\n\t * #### Horizontal Scroller, Dynamic Item Width ([codepen](http://codepen.io/ionic/pen/67cc56b349124a349acb57a0740e030e))\n\t * ```html\n\t * <ion-content>\n\t *   <h2>Available Kittens:</h2>\n\t *   <ion-scroll direction=\"x\" class=\"available-scroller\">\n\t *     <div class=\"photo\" collection-repeat=\"photo in main.photos\"\n\t *        item-height=\"250\" item-width=\"photo.width + 30\">\n\t *        <img ng-src=\"{% raw %}{{photo.src}}{% endraw %}\">\n\t *     </div>\n\t *   </ion-scroll>\n\t * </ion-content>\n\t * ```\n\t *\n\t * @param {expression} collection-repeat The expression indicating how to enumerate a collection,\n\t *   of the format  `variable in expression`  where variable is the user defined loop variable\n\t *   and `expression` is a scope expression giving the collection to enumerate.\n\t *   For example: `album in artist.albums` or `album in artist.albums | orderBy:'name'`.\n\t * @param {expression=} item-width The width of the repeated element. The expression must return\n\t *   a number (pixels) or a percentage. Defaults to the width of the first item in the list.\n\t *   (previously named collection-item-width)\n\t * @param {expression=} item-height The height of the repeated element. The expression must return\n\t *   a number (pixels) or a percentage. Defaults to the height of the first item in the list.\n\t *   (previously named collection-item-height)\n\t * @param {number=} item-render-buffer The number of items to load before and after the visible\n\t *   items in the list. Default 3. Tip: set this higher if you have lots of images to preload, but\n\t *   don't set it too high or you'll see performance loss.\n\t * @param {boolean=} force-refresh-images Force images to refresh as you scroll. This fixes a problem\n\t *   where, when an element is interchanged as scrolling, its image will still have the old src\n\t *   while the new src loads. Setting this to true comes with a small performance loss.\n\t */\n\t\n\tIonicModule\n\t.directive('collectionRepeat', CollectionRepeatDirective)\n\t.factory('$ionicCollectionManager', RepeatManagerFactory);\n\t\n\tvar ONE_PX_TRANSPARENT_IMG_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\n\tvar WIDTH_HEIGHT_REGEX = /height:.*?px;\\s*width:.*?px/;\n\tvar DEFAULT_RENDER_BUFFER = 3;\n\t\n\tCollectionRepeatDirective.$inject = ['$ionicCollectionManager', '$parse', '$window', '$$rAF', '$rootScope', '$timeout'];\n\tfunction CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {\n\t  return {\n\t    restrict: 'A',\n\t    priority: 1000,\n\t    transclude: 'element',\n\t    $$tlb: true,\n\t    require: '^^$ionicScroll',\n\t    link: postLink\n\t  };\n\t\n\t  function postLink(scope, element, attr, scrollCtrl, transclude) {\n\t    var scrollView = scrollCtrl.scrollView;\n\t    var node = element[0];\n\t    var containerNode = angular.element('<div class=\"collection-repeat-container\">')[0];\n\t    node.parentNode.replaceChild(containerNode, node);\n\t\n\t    if (scrollView.options.scrollingX && scrollView.options.scrollingY) {\n\t      throw new Error(\"collection-repeat expected a parent x or y scrollView, not \" +\n\t                      \"an xy scrollView.\");\n\t    }\n\t\n\t    var repeatExpr = attr.collectionRepeat;\n\t    var match = repeatExpr.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);\n\t    if (!match) {\n\t      throw new Error(\"collection-repeat expected expression in form of '_item_ in \" +\n\t                      \"_collection_[ track by _id_]' but got '\" + attr.collectionRepeat + \"'.\");\n\t    }\n\t    var keyExpr = match[1];\n\t    var listExpr = match[2];\n\t    var listGetter = $parse(listExpr);\n\t    var heightData = {};\n\t    var widthData = {};\n\t    var computedStyleDimensions = {};\n\t    var data = [];\n\t    var repeatManager;\n\t\n\t    // attr.collectionBufferSize is deprecated\n\t    var renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize;\n\t    var renderBuffer = angular.isDefined(renderBufferExpr) ?\n\t      parseInt(renderBufferExpr) :\n\t      DEFAULT_RENDER_BUFFER;\n\t\n\t    // attr.collectionItemHeight is deprecated\n\t    var heightExpr = attr.itemHeight || attr.collectionItemHeight;\n\t    // attr.collectionItemWidth is deprecated\n\t    var widthExpr = attr.itemWidth || attr.collectionItemWidth;\n\t\n\t    var afterItemsContainer = initAfterItemsContainer();\n\t\n\t    var changeValidator = makeChangeValidator();\n\t    initDimensions();\n\t\n\t    // Dimensions are refreshed on resize or data change.\n\t    scrollCtrl.$element.on('scroll-resize', refreshDimensions);\n\t\n\t    angular.element($window).on('resize', onResize);\n\t    var unlistenToExposeAside = $rootScope.$on('$ionicExposeAside', ionic.animationFrameThrottle(function() {\n\t      scrollCtrl.scrollView.resize();\n\t      onResize();\n\t    }));\n\t    $timeout(refreshDimensions, 0, false);\n\t\n\t    function onResize() {\n\t      if (changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight)) {\n\t        refreshDimensions();\n\t      }\n\t    }\n\t\n\t    scope.$watchCollection(listGetter, function(newValue) {\n\t      data = newValue || (newValue = []);\n\t      if (!angular.isArray(newValue)) {\n\t        throw new Error(\"collection-repeat expected an array for '\" + listExpr + \"', \" +\n\t          \"but got a \" + typeof value);\n\t      }\n\t      // Wait for this digest to end before refreshing everything.\n\t      scope.$$postDigest(function() {\n\t        getRepeatManager().setData(data);\n\t        if (changeValidator.dataChangeRequiresRefresh(data)) refreshDimensions();\n\t      });\n\t    });\n\t\n\t    scope.$on('$destroy', function() {\n\t      angular.element($window).off('resize', onResize);\n\t      unlistenToExposeAside();\n\t      scrollCtrl.$element && scrollCtrl.$element.off('scroll-resize', refreshDimensions);\n\t\n\t      computedStyleNode && computedStyleNode.parentNode &&\n\t        computedStyleNode.parentNode.removeChild(computedStyleNode);\n\t      computedStyleScope && computedStyleScope.$destroy();\n\t      computedStyleScope = computedStyleNode = null;\n\t\n\t      repeatManager && repeatManager.destroy();\n\t      repeatManager = null;\n\t    });\n\t\n\t    function makeChangeValidator() {\n\t      var self;\n\t      return (self = {\n\t        dataLength: 0,\n\t        width: 0,\n\t        height: 0,\n\t        // A resize triggers a refresh only if we have data, the scrollView has size,\n\t        // and the size has changed.\n\t        resizeRequiresRefresh: function(newWidth, newHeight) {\n\t          var requiresRefresh = self.dataLength && newWidth && newHeight &&\n\t            (newWidth !== self.width || newHeight !== self.height);\n\t\n\t          self.width = newWidth;\n\t          self.height = newHeight;\n\t\n\t          return !!requiresRefresh;\n\t        },\n\t        // A change in data only triggers a refresh if the data has length, or if the data's\n\t        // length is less than before.\n\t        dataChangeRequiresRefresh: function(newData) {\n\t          var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;\n\t\n\t          self.dataLength = newData.length;\n\t\n\t          return !!requiresRefresh;\n\t        }\n\t      });\n\t    }\n\t\n\t    function getRepeatManager() {\n\t      return repeatManager || (repeatManager = new $ionicCollectionManager({\n\t        afterItemsNode: afterItemsContainer[0],\n\t        containerNode: containerNode,\n\t        heightData: heightData,\n\t        widthData: widthData,\n\t        forceRefreshImages: !!(isDefined(attr.forceRefreshImages) && attr.forceRefreshImages !== 'false'),\n\t        keyExpression: keyExpr,\n\t        renderBuffer: renderBuffer,\n\t        scope: scope,\n\t        scrollView: scrollCtrl.scrollView,\n\t        transclude: transclude\n\t      }));\n\t    }\n\t\n\t    function initAfterItemsContainer() {\n\t      var container = angular.element(\n\t        scrollView.__content.querySelector('.collection-repeat-after-container')\n\t      );\n\t      // Put everything in the view after the repeater into a container.\n\t      if (!container.length) {\n\t        var elementIsAfterRepeater = false;\n\t        var afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {\n\t          if (ionic.DomUtil.contains(node, containerNode)) {\n\t            elementIsAfterRepeater = true;\n\t            return false;\n\t          }\n\t          return elementIsAfterRepeater;\n\t        });\n\t        container = angular.element('<span class=\"collection-repeat-after-container\">');\n\t        if (scrollView.options.scrollingX) {\n\t          container.addClass('horizontal');\n\t        }\n\t        container.append(afterNodes);\n\t        scrollView.__content.appendChild(container[0]);\n\t      }\n\t      return container;\n\t    }\n\t\n\t    function initDimensions() {\n\t      //Height and width have four 'modes':\n\t      //1) Computed Mode\n\t      //  - Nothing is supplied, so we getComputedStyle() on one element in the list and use\n\t      //    that width and height value for the width and height of every item. This is re-computed\n\t      //    every resize.\n\t      //2) Constant Mode, Static Integer\n\t      //  - The user provides a constant number for width or height, in pixels. We parse it,\n\t      //    store it on the `value` field, and it never changes\n\t      //3) Constant Mode, Percent\n\t      //  - The user provides a percent string for width or height. The getter for percent is\n\t      //    stored on the `getValue()` field, and is re-evaluated once every resize. The result\n\t      //    is stored on the `value` field.\n\t      //4) Dynamic Mode\n\t      //  - The user provides a dynamic expression for the width or height.  This is re-evaluated\n\t      //    for every item, stored on the `.getValue()` field.\n\t      if (heightExpr) {\n\t        parseDimensionAttr(heightExpr, heightData);\n\t      } else {\n\t        heightData.computed = true;\n\t      }\n\t      if (widthExpr) {\n\t        parseDimensionAttr(widthExpr, widthData);\n\t      } else {\n\t        widthData.computed = true;\n\t      }\n\t    }\n\t\n\t    function refreshDimensions() {\n\t      var hasData = data.length > 0;\n\t\n\t      if (hasData && (heightData.computed || widthData.computed)) {\n\t        computeStyleDimensions();\n\t      }\n\t\n\t      if (hasData && heightData.computed) {\n\t        heightData.value = computedStyleDimensions.height;\n\t        if (!heightData.value) {\n\t          throw new Error('collection-repeat tried to compute the height of repeated elements \"' +\n\t            repeatExpr + '\", but was unable to. Please provide the \"item-height\" attribute. ' +\n\t            'http://ionicframework.com/docs/api/directive/collectionRepeat/');\n\t        }\n\t      } else if (!heightData.dynamic && heightData.getValue) {\n\t        // If it's a constant with a getter (eg percent), we just refresh .value after resize\n\t        heightData.value = heightData.getValue();\n\t      }\n\t\n\t      if (hasData && widthData.computed) {\n\t        widthData.value = computedStyleDimensions.width;\n\t        if (!widthData.value) {\n\t          throw new Error('collection-repeat tried to compute the width of repeated elements \"' +\n\t            repeatExpr + '\", but was unable to. Please provide the \"item-width\" attribute. ' +\n\t            'http://ionicframework.com/docs/api/directive/collectionRepeat/');\n\t        }\n\t      } else if (!widthData.dynamic && widthData.getValue) {\n\t        // If it's a constant with a getter (eg percent), we just refresh .value after resize\n\t        widthData.value = widthData.getValue();\n\t      }\n\t      // Dynamic dimensions aren't updated on resize. Since they're already dynamic anyway,\n\t      // .getValue() will be used.\n\t\n\t      getRepeatManager().refreshLayout();\n\t    }\n\t\n\t    function parseDimensionAttr(attrValue, dimensionData) {\n\t      if (!attrValue) return;\n\t\n\t      var parsedValue;\n\t      // Try to just parse the plain attr value\n\t      try {\n\t        parsedValue = $parse(attrValue);\n\t      } catch (e) {\n\t        // If the parse fails and the value has `px` or `%` in it, surround the attr in\n\t        // quotes, to attempt to let the user provide a simple `attr=\"100%\"` or `attr=\"100px\"`\n\t        if (attrValue.trim().match(/\\d+(px|%)$/)) {\n\t          attrValue = '\"' + attrValue + '\"';\n\t        }\n\t        parsedValue = $parse(attrValue);\n\t      }\n\t\n\t      var constantAttrValue = attrValue.replace(/(\\'|\\\"|px|%)/g, '').trim();\n\t      var isConstant = constantAttrValue.length && !/([a-zA-Z]|\\$|:|\\?)/.test(constantAttrValue);\n\t      dimensionData.attrValue = attrValue;\n\t\n\t      // If it's a constant, it's either a percent or just a constant pixel number.\n\t      if (isConstant) {\n\t        // For percents, store the percent getter on .getValue()\n\t        if (attrValue.indexOf('%') > -1) {\n\t          var decimalValue = parseFloat(parsedValue()) / 100;\n\t          dimensionData.getValue = dimensionData === heightData ?\n\t            function() { return Math.floor(decimalValue * scrollView.__clientHeight); } :\n\t            function() { return Math.floor(decimalValue * scrollView.__clientWidth); };\n\t        } else {\n\t          // For static constants, just store the static constant.\n\t          dimensionData.value = parseInt(parsedValue());\n\t        }\n\t\n\t      } else {\n\t        dimensionData.dynamic = true;\n\t        dimensionData.getValue = dimensionData === heightData ?\n\t          function heightGetter(scope, locals) {\n\t            var result = parsedValue(scope, locals);\n\t            if (result.charAt && result.charAt(result.length - 1) === '%') {\n\t              return Math.floor(parseFloat(result) / 100 * scrollView.__clientHeight);\n\t            }\n\t            return parseInt(result);\n\t          } :\n\t          function widthGetter(scope, locals) {\n\t            var result = parsedValue(scope, locals);\n\t            if (result.charAt && result.charAt(result.length - 1) === '%') {\n\t              return Math.floor(parseFloat(result) / 100 * scrollView.__clientWidth);\n\t            }\n\t            return parseInt(result);\n\t          };\n\t      }\n\t    }\n\t\n\t    var computedStyleNode;\n\t    var computedStyleScope;\n\t    function computeStyleDimensions() {\n\t      if (!computedStyleNode) {\n\t        transclude(computedStyleScope = scope.$new(), function(clone) {\n\t          clone[0].removeAttribute('collection-repeat'); // remove absolute position styling\n\t          computedStyleNode = clone[0];\n\t        });\n\t      }\n\t\n\t      computedStyleScope[keyExpr] = (listGetter(scope) || [])[0];\n\t      if (!$rootScope.$$phase) computedStyleScope.$digest();\n\t      containerNode.appendChild(computedStyleNode);\n\t\n\t      var style = $window.getComputedStyle(computedStyleNode);\n\t      computedStyleDimensions.width = parseInt(style.width);\n\t      computedStyleDimensions.height = parseInt(style.height);\n\t\n\t      containerNode.removeChild(computedStyleNode);\n\t    }\n\t\n\t  }\n\t\n\t}\n\t\n\tRepeatManagerFactory.$inject = ['$rootScope', '$window', '$$rAF'];\n\tfunction RepeatManagerFactory($rootScope, $window, $$rAF) {\n\t  var EMPTY_DIMENSION = { primaryPos: 0, secondaryPos: 0, primarySize: 0, secondarySize: 0, rowPrimarySize: 0 };\n\t\n\t  return function RepeatController(options) {\n\t    var afterItemsNode = options.afterItemsNode;\n\t    var containerNode = options.containerNode;\n\t    var forceRefreshImages = options.forceRefreshImages;\n\t    var heightData = options.heightData;\n\t    var widthData = options.widthData;\n\t    var keyExpression = options.keyExpression;\n\t    var renderBuffer = options.renderBuffer;\n\t    var scope = options.scope;\n\t    var scrollView = options.scrollView;\n\t    var transclude = options.transclude;\n\t\n\t    var data = [];\n\t\n\t    var getterLocals = {};\n\t    var heightFn = heightData.getValue || function() { return heightData.value; };\n\t    var heightGetter = function(index, value) {\n\t      getterLocals[keyExpression] = value;\n\t      getterLocals.$index = index;\n\t      return heightFn(scope, getterLocals);\n\t    };\n\t\n\t    var widthFn = widthData.getValue || function() { return widthData.value; };\n\t    var widthGetter = function(index, value) {\n\t      getterLocals[keyExpression] = value;\n\t      getterLocals.$index = index;\n\t      return widthFn(scope, getterLocals);\n\t    };\n\t\n\t    var isVertical = !!scrollView.options.scrollingY;\n\t\n\t    // We say it's a grid view if we're either dynamic or not 100% width\n\t    var isGridView = isVertical ?\n\t      (widthData.dynamic || widthData.value !== scrollView.__clientWidth) :\n\t      (heightData.dynamic || heightData.value !== scrollView.__clientHeight);\n\t\n\t    var isStaticView = !heightData.dynamic && !widthData.dynamic;\n\t\n\t    var PRIMARY = 'PRIMARY';\n\t    var SECONDARY = 'SECONDARY';\n\t    var TRANSLATE_TEMPLATE_STR = isVertical ?\n\t      'translate3d(SECONDARYpx,PRIMARYpx,0)' :\n\t      'translate3d(PRIMARYpx,SECONDARYpx,0)';\n\t    var WIDTH_HEIGHT_TEMPLATE_STR = isVertical ?\n\t      'height: PRIMARYpx; width: SECONDARYpx;' :\n\t      'height: SECONDARYpx; width: PRIMARYpx;';\n\t\n\t    var estimatedHeight;\n\t    var estimatedWidth;\n\t\n\t    var repeaterBeforeSize = 0;\n\t    var repeaterAfterSize = 0;\n\t\n\t    var renderStartIndex = -1;\n\t    var renderEndIndex = -1;\n\t    var renderAfterBoundary = -1;\n\t    var renderBeforeBoundary = -1;\n\t\n\t    var itemsPool = [];\n\t    var itemsLeaving = [];\n\t    var itemsEntering = [];\n\t    var itemsShownMap = {};\n\t    var nextItemId = 0;\n\t\n\t    var scrollViewSetDimensions = isVertical ?\n\t      function() { scrollView.setDimensions(null, null, null, view.getContentSize(), true); } :\n\t      function() { scrollView.setDimensions(null, null, view.getContentSize(), null, true); };\n\t\n\t    // view is a mix of list/grid methods + static/dynamic methods.\n\t    // See bottom for implementations. Available methods:\n\t    //\n\t    // getEstimatedPrimaryPos(i), getEstimatedSecondaryPos(i), getEstimatedIndex(scrollTop),\n\t    // calculateDimensions(toIndex), getDimensions(index),\n\t    // updateRenderRange(scrollTop, scrollValueEnd), onRefreshLayout(), onRefreshData()\n\t    var view = isVertical ? new VerticalViewType() : new HorizontalViewType();\n\t    (isGridView ? GridViewType : ListViewType).call(view);\n\t    (isStaticView ? StaticViewType : DynamicViewType).call(view);\n\t\n\t    var contentSizeStr = isVertical ? 'getContentHeight' : 'getContentWidth';\n\t    var originalGetContentSize = scrollView.options[contentSizeStr];\n\t    scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize);\n\t\n\t    scrollView.__$callback = scrollView.__callback;\n\t    scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {\n\t      var scrollValue = view.getScrollValue();\n\t      if (renderStartIndex === -1 ||\n\t          scrollValue + view.scrollPrimarySize > renderAfterBoundary ||\n\t          scrollValue < renderBeforeBoundary) {\n\t        render();\n\t      }\n\t      scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);\n\t    };\n\t\n\t    var isLayoutReady = false;\n\t    var isDataReady = false;\n\t    this.refreshLayout = function() {\n\t      if (data.length) {\n\t        estimatedHeight = heightGetter(0, data[0]);\n\t        estimatedWidth = widthGetter(0, data[0]);\n\t      } else {\n\t        // If we don't have any data in our array, just guess.\n\t        estimatedHeight = 100;\n\t        estimatedWidth = 100;\n\t      }\n\t\n\t      // Get the size of every element AFTER the repeater. We have to get the margin before and\n\t      // after the first/last element to fix a browser bug with getComputedStyle() not counting\n\t      // the first/last child's margins into height.\n\t      var style = getComputedStyle(afterItemsNode) || {};\n\t      var firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {};\n\t      var lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};\n\t      repeaterAfterSize = (parseInt(style[isVertical ? 'height' : 'width']) || 0) +\n\t        (firstStyle && parseInt(firstStyle[isVertical ? 'marginTop' : 'marginLeft']) || 0) +\n\t        (lastStyle && parseInt(lastStyle[isVertical ? 'marginBottom' : 'marginRight']) || 0);\n\t\n\t      // Get the offsetTop of the repeater.\n\t      repeaterBeforeSize = 0;\n\t      var current = containerNode;\n\t      do {\n\t        repeaterBeforeSize += current[isVertical ? 'offsetTop' : 'offsetLeft'];\n\t      } while ( ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent) );\n\t\n\t      var containerPrevNode = containerNode.previousElementSibling;\n\t      var beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {};\n\t      var beforeMargin = parseInt(beforeStyle[isVertical ? 'marginBottom' : 'marginRight'] || 0);\n\t\n\t      // Because we position the collection container with position: relative, it doesn't take\n\t      // into account where to position itself relative to the previous element's marginBottom.\n\t      // To compensate, we translate the container up by the previous element's margin.\n\t      containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR\n\t        .replace(PRIMARY, -beforeMargin)\n\t        .replace(SECONDARY, 0);\n\t      repeaterBeforeSize -= beforeMargin;\n\t\n\t      if (!scrollView.__clientHeight || !scrollView.__clientWidth) {\n\t        scrollView.__clientWidth = scrollView.__container.clientWidth;\n\t        scrollView.__clientHeight = scrollView.__container.clientHeight;\n\t      }\n\t\n\t      (view.onRefreshLayout || angular.noop)();\n\t      view.refreshDirection();\n\t      scrollViewSetDimensions();\n\t\n\t      // Create the pool of items for reuse, setting the size to (estimatedItemsOnScreen) * 2,\n\t      // plus the size of the renderBuffer.\n\t      if (!isLayoutReady) {\n\t        var poolSize = Math.max(20, renderBuffer * 3);\n\t        for (var i = 0; i < poolSize; i++) {\n\t          itemsPool.push(new RepeatItem());\n\t        }\n\t      }\n\t\n\t      isLayoutReady = true;\n\t      if (isLayoutReady && isDataReady) {\n\t        // If the resize or latest data change caused the scrollValue to\n\t        // now be out of bounds, resize the scrollView.\n\t        if (scrollView.__scrollLeft > scrollView.__maxScrollLeft ||\n\t            scrollView.__scrollTop > scrollView.__maxScrollTop) {\n\t          scrollView.resize();\n\t        }\n\t        forceRerender(true);\n\t      }\n\t    };\n\t\n\t    this.setData = function(newData) {\n\t      data = newData;\n\t      (view.onRefreshData || angular.noop)();\n\t      isDataReady = true;\n\t    };\n\t\n\t    this.destroy = function() {\n\t      render.destroyed = true;\n\t\n\t      itemsPool.forEach(function(item) {\n\t        item.scope.$destroy();\n\t        item.scope = item.element = item.node = item.images = null;\n\t      });\n\t      itemsPool.length = itemsEntering.length = itemsLeaving.length = 0;\n\t      itemsShownMap = {};\n\t\n\t      //Restore the scrollView's normal behavior and resize it to normal size.\n\t      scrollView.options[contentSizeStr] = originalGetContentSize;\n\t      scrollView.__callback = scrollView.__$callback;\n\t      scrollView.resize();\n\t\n\t      (view.onDestroy || angular.noop)();\n\t    };\n\t\n\t    function forceRerender() {\n\t      return render(true);\n\t    }\n\t    function render(forceRerender) {\n\t      if (render.destroyed) return;\n\t      var i;\n\t      var ii;\n\t      var item;\n\t      var dim;\n\t      var scope;\n\t      var scrollValue = view.getScrollValue();\n\t      var scrollValueEnd = scrollValue + view.scrollPrimarySize;\n\t\n\t      view.updateRenderRange(scrollValue, scrollValueEnd);\n\t\n\t      renderStartIndex = Math.max(0, renderStartIndex - renderBuffer);\n\t      renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);\n\t\n\t      for (i in itemsShownMap) {\n\t        if (i < renderStartIndex || i > renderEndIndex) {\n\t          item = itemsShownMap[i];\n\t          delete itemsShownMap[i];\n\t          itemsLeaving.push(item);\n\t          item.isShown = false;\n\t        }\n\t      }\n\t\n\t      // Render indicies that aren't shown yet\n\t      //\n\t      // NOTE(ajoslin): this may sound crazy, but calling any other functions during this render\n\t      // loop will often push the render time over the edge from less than one frame to over\n\t      // one frame, causing visible jank.\n\t      // DON'T call any other functions inside this loop unless it's vital.\n\t      for (i = renderStartIndex; i <= renderEndIndex; i++) {\n\t        // We only go forward with render if the index is in data, the item isn't already shown,\n\t        // or forceRerender is on.\n\t        if (i >= data.length || (itemsShownMap[i] && !forceRerender)) continue;\n\t\n\t        item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() :\n\t                                    itemsPool.length ? itemsPool.shift() :\n\t                                    new RepeatItem());\n\t        itemsEntering.push(item);\n\t        item.isShown = true;\n\t\n\t        scope = item.scope;\n\t        scope.$index = i;\n\t        scope[keyExpression] = data[i];\n\t        scope.$first = (i === 0);\n\t        scope.$last = (i === (data.length - 1));\n\t        scope.$middle = !(scope.$first || scope.$last);\n\t        scope.$odd = !(scope.$even = (i & 1) === 0);\n\t\n\t        if (scope.$$disconnected) ionic.Utils.reconnectScope(item.scope);\n\t\n\t        dim = view.getDimensions(i);\n\t        if (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) {\n\t          item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR\n\t            .replace(PRIMARY, (item.primaryPos = dim.primaryPos))\n\t            .replace(SECONDARY, (item.secondaryPos = dim.secondaryPos));\n\t        }\n\t        if (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) {\n\t          item.node.style.cssText = item.node.style.cssText\n\t            .replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR\n\t              //TODO fix item.primarySize + 1 hack\n\t              .replace(PRIMARY, (item.primarySize = dim.primarySize) + 1)\n\t              .replace(SECONDARY, (item.secondarySize = dim.secondarySize))\n\t            );\n\t        }\n\t\n\t      }\n\t\n\t      // If we reach the end of the list, render the afterItemsNode - this contains all the\n\t      // elements the developer placed after the collection-repeat\n\t      if (renderEndIndex === data.length - 1) {\n\t        dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION;\n\t        afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR\n\t          .replace(PRIMARY, dim.primaryPos + dim.primarySize)\n\t          .replace(SECONDARY, 0);\n\t      }\n\t\n\t      while (itemsLeaving.length) {\n\t        item = itemsLeaving.pop();\n\t        item.scope.$broadcast('$collectionRepeatLeave');\n\t        ionic.Utils.disconnectScope(item.scope);\n\t        itemsPool.push(item);\n\t        item.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';\n\t        item.primaryPos = item.secondaryPos = null;\n\t      }\n\t\n\t      if (forceRefreshImages) {\n\t        for (i = 0, ii = itemsEntering.length; i < ii && (item = itemsEntering[i]); i++) {\n\t          if (!item.images) continue;\n\t          for (var j = 0, jj = item.images.length, img; j < jj && (img = item.images[j]); j++) {\n\t            var src = img.src;\n\t            img.src = ONE_PX_TRANSPARENT_IMG_SRC;\n\t            img.src = src;\n\t          }\n\t        }\n\t      }\n\t      if (forceRerender) {\n\t        var rootScopePhase = $rootScope.$$phase;\n\t        while (itemsEntering.length) {\n\t          item = itemsEntering.pop();\n\t          if (!rootScopePhase) item.scope.$digest();\n\t        }\n\t      } else {\n\t        digestEnteringItems();\n\t      }\n\t    }\n\t\n\t    function digestEnteringItems() {\n\t      var item;\n\t      if (digestEnteringItems.running) return;\n\t      digestEnteringItems.running = true;\n\t\n\t      $$rAF(function process() {\n\t        var rootScopePhase = $rootScope.$$phase;\n\t        while (itemsEntering.length) {\n\t          item = itemsEntering.pop();\n\t          if (item.isShown) {\n\t            if (!rootScopePhase) item.scope.$digest();\n\t          }\n\t        }\n\t        digestEnteringItems.running = false;\n\t      });\n\t    }\n\t\n\t    function RepeatItem() {\n\t      var self = this;\n\t      this.scope = scope.$new();\n\t      this.id = 'item' + (nextItemId++);\n\t      transclude(this.scope, function(clone) {\n\t        self.element = clone;\n\t        self.element.data('$$collectionRepeatItem', self);\n\t        // TODO destroy\n\t        self.node = clone[0];\n\t        // Batch style setting to lower repaints\n\t        self.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';\n\t        self.node.style.cssText += ' height: 0px; width: 0px;';\n\t        ionic.Utils.disconnectScope(self.scope);\n\t        containerNode.appendChild(self.node);\n\t        self.images = clone[0].getElementsByTagName('img');\n\t      });\n\t    }\n\t\n\t    function VerticalViewType() {\n\t      this.getItemPrimarySize = heightGetter;\n\t      this.getItemSecondarySize = widthGetter;\n\t\n\t      this.getScrollValue = function() {\n\t        return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize,\n\t          scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));\n\t      };\n\t\n\t      this.refreshDirection = function() {\n\t        this.scrollPrimarySize = scrollView.__clientHeight;\n\t        this.scrollSecondarySize = scrollView.__clientWidth;\n\t\n\t        this.estimatedPrimarySize = estimatedHeight;\n\t        this.estimatedSecondarySize = estimatedWidth;\n\t        this.estimatedItemsAcross = isGridView &&\n\t          Math.floor(scrollView.__clientWidth / estimatedWidth) ||\n\t          1;\n\t      };\n\t    }\n\t    function HorizontalViewType() {\n\t      this.getItemPrimarySize = widthGetter;\n\t      this.getItemSecondarySize = heightGetter;\n\t\n\t      this.getScrollValue = function() {\n\t        return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize,\n\t          scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));\n\t      };\n\t\n\t      this.refreshDirection = function() {\n\t        this.scrollPrimarySize = scrollView.__clientWidth;\n\t        this.scrollSecondarySize = scrollView.__clientHeight;\n\t\n\t        this.estimatedPrimarySize = estimatedWidth;\n\t        this.estimatedSecondarySize = estimatedHeight;\n\t        this.estimatedItemsAcross = isGridView &&\n\t          Math.floor(scrollView.__clientHeight / estimatedHeight) ||\n\t          1;\n\t      };\n\t    }\n\t\n\t    function GridViewType() {\n\t      this.getEstimatedSecondaryPos = function(index) {\n\t        return (index % this.estimatedItemsAcross) * this.estimatedSecondarySize;\n\t      };\n\t      this.getEstimatedPrimaryPos = function(index) {\n\t        return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;\n\t      };\n\t      this.getEstimatedIndex = function(scrollValue) {\n\t        return Math.floor(scrollValue / this.estimatedPrimarySize) *\n\t          this.estimatedItemsAcross;\n\t      };\n\t    }\n\t\n\t    function ListViewType() {\n\t      this.getEstimatedSecondaryPos = function() {\n\t        return 0;\n\t      };\n\t      this.getEstimatedPrimaryPos = function(index) {\n\t        return index * this.estimatedPrimarySize;\n\t      };\n\t      this.getEstimatedIndex = function(scrollValue) {\n\t        return Math.floor((scrollValue) / this.estimatedPrimarySize);\n\t      };\n\t    }\n\t\n\t    function StaticViewType() {\n\t      this.getContentSize = function() {\n\t        return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize +\n\t          repeaterBeforeSize + repeaterAfterSize;\n\t      };\n\t      // static view always returns the same object for getDimensions, to avoid memory allocation\n\t      // while scrolling. This could be dangerous if this was a public function, but it's not.\n\t      // Only we use it.\n\t      var dim = {};\n\t      this.getDimensions = function(index) {\n\t        dim.primaryPos = this.getEstimatedPrimaryPos(index);\n\t        dim.secondaryPos = this.getEstimatedSecondaryPos(index);\n\t        dim.primarySize = this.estimatedPrimarySize;\n\t        dim.secondarySize = this.estimatedSecondarySize;\n\t        return dim;\n\t      };\n\t      this.updateRenderRange = function(scrollValue, scrollValueEnd) {\n\t        renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue));\n\t\n\t        // Make sure the renderEndIndex takes into account all the items on the row\n\t        renderEndIndex = Math.min(data.length - 1,\n\t          this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1);\n\t\n\t        renderBeforeBoundary = Math.max(0,\n\t          this.getEstimatedPrimaryPos(renderStartIndex));\n\t        renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) +\n\t          this.estimatedPrimarySize;\n\t      };\n\t    }\n\t\n\t    function DynamicViewType() {\n\t      var self = this;\n\t      var debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, true);\n\t      var calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList;\n\t      var dimensionsIndex;\n\t      var dimensions = [];\n\t\n\t\n\t      // Get the dimensions at index. {width, height, left, top}.\n\t      // We start with no dimensions calculated, then any time dimensions are asked for at an\n\t      // index we calculate dimensions up to there.\n\t      function calculateDimensionsList(toIndex) {\n\t        var i, prevDimension, dim;\n\t        for (i = Math.max(0, dimensionsIndex); i <= toIndex && (dim = dimensions[i]); i++) {\n\t          prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;\n\t          dim.primarySize = self.getItemPrimarySize(i, data[i]);\n\t          dim.secondarySize = self.scrollSecondarySize;\n\t          dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize;\n\t          dim.secondaryPos = 0;\n\t        }\n\t      }\n\t      function calculateDimensionsGrid(toIndex) {\n\t        var i, prevDimension, dim;\n\t        for (i = Math.max(dimensionsIndex, 0); i <= toIndex && (dim = dimensions[i]); i++) {\n\t          prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;\n\t          dim.secondarySize = Math.min(\n\t            self.getItemSecondarySize(i, data[i]),\n\t            self.scrollSecondarySize\n\t          );\n\t          dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize;\n\t\n\t          if (i === 0 || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize) {\n\t            dim.secondaryPos = 0;\n\t            dim.primarySize = self.getItemPrimarySize(i, data[i]);\n\t            dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize;\n\t\n\t            dim.rowStartIndex = i;\n\t            dim.rowPrimarySize = dim.primarySize;\n\t          } else {\n\t            dim.primarySize = self.getItemPrimarySize(i, data[i]);\n\t            dim.primaryPos = prevDimension.primaryPos;\n\t            dim.rowStartIndex = prevDimension.rowStartIndex;\n\t\n\t            dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(\n\t              dimensions[dim.rowStartIndex].rowPrimarySize,\n\t              dim.primarySize\n\t            );\n\t            dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize);\n\t          }\n\t        }\n\t      }\n\t\n\t      this.getContentSize = function() {\n\t        var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;\n\t        return ((dim.primaryPos + dim.primarySize) || 0) +\n\t          this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) +\n\t          repeaterBeforeSize + repeaterAfterSize;\n\t      };\n\t      this.onDestroy = function() {\n\t        dimensions.length = 0;\n\t      };\n\t\n\t      this.onRefreshData = function() {\n\t        var i;\n\t        var ii;\n\t        // Make sure dimensions has as many items as data.length.\n\t        // This is to be sure we don't have to allocate objects while scrolling.\n\t        for (i = dimensions.length, ii = data.length; i < ii; i++) {\n\t          dimensions.push({});\n\t        }\n\t        dimensionsIndex = -1;\n\t      };\n\t      this.onRefreshLayout = function() {\n\t        dimensionsIndex = -1;\n\t      };\n\t      this.getDimensions = function(index) {\n\t        index = Math.min(index, data.length - 1);\n\t\n\t        if (dimensionsIndex < index) {\n\t          // Once we start asking for dimensions near the end of the list, go ahead and calculate\n\t          // everything. This is to make sure when the user gets to the end of the list, the\n\t          // scroll height of the list is 100% accurate (not estimated anymore).\n\t          if (index > data.length * 0.9) {\n\t            calculateDimensions(data.length - 1);\n\t            dimensionsIndex = data.length - 1;\n\t            scrollViewSetDimensions();\n\t          } else {\n\t            calculateDimensions(index);\n\t            dimensionsIndex = index;\n\t            debouncedScrollViewSetDimensions();\n\t          }\n\t\n\t        }\n\t        return dimensions[index];\n\t      };\n\t\n\t      var oldRenderStartIndex = -1;\n\t      var oldScrollValue = -1;\n\t      this.updateRenderRange = function(scrollValue, scrollValueEnd) {\n\t        var i;\n\t        var len;\n\t        var dim;\n\t\n\t        // Calculate more dimensions than we estimate we'll need, to be sure.\n\t        this.getDimensions( this.getEstimatedIndex(scrollValueEnd) * 2 );\n\t\n\t        // -- Calculate renderStartIndex\n\t        // base case: start at 0\n\t        if (oldRenderStartIndex === -1 || scrollValue === 0) {\n\t          i = 0;\n\t        // scrolling down\n\t        } else if (scrollValue >= oldScrollValue) {\n\t          for (i = oldRenderStartIndex, len = data.length; i < len; i++) {\n\t            if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue) {\n\t              break;\n\t            }\n\t          }\n\t        // scrolling up\n\t        } else {\n\t          for (i = oldRenderStartIndex; i >= 0; i--) {\n\t            if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {\n\t              // when grid view, make sure the render starts at the beginning of a row.\n\t              i = isGridView ? dim.rowStartIndex : i;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        renderStartIndex = Math.min(Math.max(0, i), data.length - 1);\n\t        renderBeforeBoundary = renderStartIndex !== -1 ? this.getDimensions(renderStartIndex).primaryPos : -1;\n\t\n\t        // -- Calculate renderEndIndex\n\t        var lastRowDim;\n\t        for (i = renderStartIndex + 1, len = data.length; i < len; i++) {\n\t          if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {\n\t\n\t            // Go all the way to the end of the row if we're in a grid\n\t            if (isGridView) {\n\t              lastRowDim = dim;\n\t              while (i < len - 1 &&\n\t                    (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos) {\n\t                i++;\n\t              }\n\t            }\n\t            break;\n\t          }\n\t        }\n\t\n\t        renderEndIndex = Math.min(i, data.length - 1);\n\t        renderAfterBoundary = renderEndIndex !== -1 ?\n\t          ((dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize)) :\n\t          -1;\n\t\n\t        oldScrollValue = scrollValue;\n\t        oldRenderStartIndex = renderStartIndex;\n\t      };\n\t    }\n\t\n\t\n\t  };\n\t\n\t}\n\n\n/***/ },\n/* 45 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @ngdoc directive\r\n\t * @name ionContent\r\n\t * @module ionic\r\n\t * @delegate ionic.service:$ionicScrollDelegate\r\n\t * @restrict E\r\n\t *\r\n\t * @description\r\n\t * The ionContent directive provides an easy to use content area that can be configured\r\n\t * to use Ionic's custom Scroll View, or the built in overflow scrolling of the browser.\r\n\t *\r\n\t * While we recommend using the custom Scroll features in Ionic in most cases, sometimes\r\n\t * (for performance reasons) only the browser's native overflow scrolling will suffice,\r\n\t * and so we've made it easy to toggle between the Ionic scroll implementation and\r\n\t * overflow scrolling.\r\n\t *\r\n\t * You can implement pull-to-refresh with the {@link ionic.directive:ionRefresher}\r\n\t * directive, and infinite scrolling with the {@link ionic.directive:ionInfiniteScroll}\r\n\t * directive.\r\n\t *\r\n\t * If there is any dynamic content inside the ion-content, be sure to call `.resize()` with {@link ionic.service:$ionicScrollDelegate}\r\n\t * after the content has been added.\r\n\t *\r\n\t * Be aware that this directive gets its own child scope. If you do not understand why this\r\n\t * is important, you can read [https://docs.angularjs.org/guide/scope](https://docs.angularjs.org/guide/scope).\r\n\t *\r\n\t * @param {string=} delegate-handle The handle used to identify this scrollView\r\n\t * with {@link ionic.service:$ionicScrollDelegate}.\r\n\t * @param {string=} direction Which way to scroll. 'x' or 'y' or 'xy'. Default 'y'.\r\n\t * @param {boolean=} locking Whether to lock scrolling in one direction at a time. Useful to set to false when zoomed in or scrolling in two directions. Default true.\r\n\t * @param {boolean=} padding Whether to add padding to the content.\r\n\t * Defaults to true on iOS, false on Android.\r\n\t * @param {boolean=} scroll Whether to allow scrolling of content.  Defaults to true.\r\n\t * @param {boolean=} overflow-scroll Whether to use overflow-scrolling instead of\r\n\t * Ionic scroll. See {@link ionic.provider:$ionicConfigProvider} to set this as the global default.\r\n\t * @param {boolean=} scrollbar-x Whether to show the horizontal scrollbar. Default true.\r\n\t * @param {boolean=} scrollbar-y Whether to show the vertical scrollbar. Default true.\r\n\t * @param {string=} start-x Initial horizontal scroll position. Default 0.\r\n\t * @param {string=} start-y Initial vertical scroll position. Default 0.\r\n\t * @param {expression=} on-scroll Expression to evaluate when the content is scrolled.\r\n\t * @param {expression=} on-scroll-complete Expression to evaluate when a scroll action completes. Has access to 'scrollLeft' and 'scrollTop' locals.\r\n\t * @param {boolean=} has-bouncing Whether to allow scrolling to bounce past the edges\r\n\t * of the content.  Defaults to true on iOS, false on Android.\r\n\t * @param {number=} scroll-event-interval Number of milliseconds between each firing of the 'on-scroll' expression. Default 10.\r\n\t */\r\n\tIonicModule\r\n\t.directive('ionContent', [\r\n\t  '$timeout',\r\n\t  '$controller',\r\n\t  '$ionicBind',\r\n\t  '$ionicConfig',\r\n\tfunction($timeout, $controller, $ionicBind, $ionicConfig) {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    require: '^?ionNavView',\r\n\t    scope: true,\r\n\t    priority: 800,\r\n\t    compile: function(element, attr) {\r\n\t      var innerElement;\r\n\t      var scrollCtrl;\r\n\t\r\n\t      element.addClass('scroll-content ionic-scroll');\r\n\t\r\n\t      if (attr.scroll != 'false') {\r\n\t        //We cannot use normal transclude here because it breaks element.data()\r\n\t        //inheritance on compile\r\n\t        innerElement = jqLite('<div class=\"scroll\"></div>');\r\n\t        innerElement.append(element.contents());\r\n\t        element.append(innerElement);\r\n\t      } else {\r\n\t        element.addClass('scroll-content-false');\r\n\t      }\r\n\t\r\n\t      var nativeScrolling = attr.overflowScroll !== \"false\" && (attr.overflowScroll === \"true\" || !$ionicConfig.scrolling.jsScrolling());\r\n\t\r\n\t      // collection-repeat requires JS scrolling\r\n\t      if (nativeScrolling) {\r\n\t        nativeScrolling = !element[0].querySelector('[collection-repeat]');\r\n\t      }\r\n\t      return { pre: prelink };\r\n\t      function prelink($scope, $element, $attr) {\r\n\t        var parentScope = $scope.$parent;\r\n\t        $scope.$watch(function() {\r\n\t          return (parentScope.$hasHeader ? ' has-header' : '') +\r\n\t            (parentScope.$hasSubheader ? ' has-subheader' : '') +\r\n\t            (parentScope.$hasFooter ? ' has-footer' : '') +\r\n\t            (parentScope.$hasSubfooter ? ' has-subfooter' : '') +\r\n\t            (parentScope.$hasTabs ? ' has-tabs' : '') +\r\n\t            (parentScope.$hasTabsTop ? ' has-tabs-top' : '');\r\n\t        }, function(className, oldClassName) {\r\n\t          $element.removeClass(oldClassName);\r\n\t          $element.addClass(className);\r\n\t        });\r\n\t\r\n\t        //Only this ionContent should use these variables from parent scopes\r\n\t        $scope.$hasHeader = $scope.$hasSubheader =\r\n\t          $scope.$hasFooter = $scope.$hasSubfooter =\r\n\t          $scope.$hasTabs = $scope.$hasTabsTop =\r\n\t          false;\r\n\t        $ionicBind($scope, $attr, {\r\n\t          $onScroll: '&onScroll',\r\n\t          $onScrollComplete: '&onScrollComplete',\r\n\t          hasBouncing: '@',\r\n\t          padding: '@',\r\n\t          direction: '@',\r\n\t          scrollbarX: '@',\r\n\t          scrollbarY: '@',\r\n\t          startX: '@',\r\n\t          startY: '@',\r\n\t          scrollEventInterval: '@'\r\n\t        });\r\n\t        $scope.direction = $scope.direction || 'y';\r\n\t\r\n\t        if (isDefined($attr.padding)) {\r\n\t          $scope.$watch($attr.padding, function(newVal) {\r\n\t              (innerElement || $element).toggleClass('padding', !!newVal);\r\n\t          });\r\n\t        }\r\n\t\r\n\t        if ($attr.scroll === \"false\") {\r\n\t          //do nothing\r\n\t        } else {\r\n\t          var scrollViewOptions = {};\r\n\t\r\n\t          // determined in compile phase above\r\n\t          if (nativeScrolling) {\r\n\t            // use native scrolling\r\n\t            $element.addClass('overflow-scroll');\r\n\t\r\n\t            scrollViewOptions = {\r\n\t              el: $element[0],\r\n\t              delegateHandle: attr.delegateHandle,\r\n\t              startX: $scope.$eval($scope.startX) || 0,\r\n\t              startY: $scope.$eval($scope.startY) || 0,\r\n\t              nativeScrolling: true\r\n\t            };\r\n\t\r\n\t          } else {\r\n\t            // Use JS scrolling\r\n\t            scrollViewOptions = {\r\n\t              el: $element[0],\r\n\t              delegateHandle: attr.delegateHandle,\r\n\t              locking: (attr.locking || 'true') === 'true',\r\n\t              bouncing: $scope.$eval($scope.hasBouncing),\r\n\t              startX: $scope.$eval($scope.startX) || 0,\r\n\t              startY: $scope.$eval($scope.startY) || 0,\r\n\t              scrollbarX: $scope.$eval($scope.scrollbarX) !== false,\r\n\t              scrollbarY: $scope.$eval($scope.scrollbarY) !== false,\r\n\t              scrollingX: $scope.direction.indexOf('x') >= 0,\r\n\t              scrollingY: $scope.direction.indexOf('y') >= 0,\r\n\t              scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,\r\n\t              scrollingComplete: onScrollComplete\r\n\t            };\r\n\t          }\r\n\t\r\n\t          // init scroll controller with appropriate options\r\n\t          scrollCtrl = $controller('$ionicScroll', {\r\n\t            $scope: $scope,\r\n\t            scrollViewOptions: scrollViewOptions\r\n\t          });\r\n\t\r\n\t          $scope.scrollCtrl = scrollCtrl;\r\n\t\r\n\t          $scope.$on('$destroy', function() {\r\n\t            if (scrollViewOptions) {\r\n\t              scrollViewOptions.scrollingComplete = noop;\r\n\t              delete scrollViewOptions.el;\r\n\t            }\r\n\t            innerElement = null;\r\n\t            $element = null;\r\n\t            attr.$$element = null;\r\n\t          });\r\n\t        }\r\n\t\r\n\t        function onScrollComplete() {\r\n\t          $scope.$onScrollComplete({\r\n\t            scrollTop: scrollCtrl.scrollView.__scrollTop,\r\n\t            scrollLeft: scrollCtrl.scrollView.__scrollLeft\r\n\t          });\r\n\t        }\r\n\t\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t}]);\r\n\n\n/***/ },\n/* 46 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name exposeAsideWhen\n\t * @module ionic\n\t * @restrict A\n\t * @parent ionic.directive:ionSideMenus\n\t *\n\t * @description\n\t * It is common for a tablet application to hide a menu when in portrait mode, but to show the\n\t * same menu on the left side when the tablet is in landscape mode. The `exposeAsideWhen` attribute\n\t * directive can be used to accomplish a similar interface.\n\t *\n\t * By default, side menus are hidden underneath its side menu content, and can be opened by either\n\t * swiping the content left or right, or toggling a button to show the side menu. However, by adding the\n\t * `exposeAsideWhen` attribute directive to an {@link ionic.directive:ionSideMenu} element directive,\n\t * a side menu can be given instructions on \"when\" the menu should be exposed (always viewable). For\n\t * example, the `expose-aside-when=\"large\"` attribute will keep the side menu hidden when the viewport's\n\t * width is less than `768px`, but when the viewport's width is `768px` or greater, the menu will then\n\t * always be shown and can no longer be opened or closed like it could when it was hidden for smaller\n\t * viewports.\n\t *\n\t * Using `large` as the attribute's value is a shortcut value to `(min-width:768px)` since it is\n\t * the most common use-case. However, for added flexibility, any valid media query could be added\n\t * as the value, such as `(min-width:600px)` or even multiple queries such as\n\t * `(min-width:750px) and (max-width:1200px)`.\n\t * @usage\n\t * ```html\n\t * <ion-side-menus>\n\t *   <!-- Center content -->\n\t *   <ion-side-menu-content>\n\t *   </ion-side-menu-content>\n\t *\n\t *   <!-- Left menu -->\n\t *   <ion-side-menu expose-aside-when=\"large\">\n\t *   </ion-side-menu>\n\t * </ion-side-menus>\n\t * ```\n\t * For a complete side menu example, see the\n\t * {@link ionic.directive:ionSideMenus} documentation.\n\t */\n\t\n\tIonicModule.directive('exposeAsideWhen', ['$window', function($window) {\n\t  return {\n\t    restrict: 'A',\n\t    require: '^ionSideMenus',\n\t    link: function($scope, $element, $attr, sideMenuCtrl) {\n\t\n\t      // Setup a match media query listener that triggers a ui change only when a change\n\t      // in media matching status occurs\n\t      var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;\n\t      var mql = $window.matchMedia(mq);\n\t      mql.addListener(function() {\n\t        onResize();\n\t      });\n\t\n\t      function checkAsideExpose() {\n\t        var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;\n\t        sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);\n\t        sideMenuCtrl.activeAsideResizing(false);\n\t      }\n\t\n\t      function onResize() {\n\t        sideMenuCtrl.activeAsideResizing(true);\n\t        debouncedCheck();\n\t      }\n\t\n\t      var debouncedCheck = ionic.debounce(function() {\n\t        $scope.$apply(checkAsideExpose);\n\t      }, 300, false);\n\t\n\t      $scope.$evalAsync(checkAsideExpose);\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 47 */\n/***/ function(module, exports) {\n\n\tvar GESTURE_DIRECTIVES = 'onHold onTap onDoubleTap onTouch onRelease onDragStart onDrag onDragEnd onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft'.split(' ');\n\t\n\tGESTURE_DIRECTIVES.forEach(function(name) {\n\t  IonicModule.directive(name, gestureDirective(name));\n\t});\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onHold\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Touch stays at the same location for 500ms. Similar to long touch events available for AngularJS and jQuery.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-hold=\"onHold()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onTap\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Quick touch at a location. If the duration of the touch goes\n\t * longer than 250ms it is no longer a tap gesture.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-tap=\"onTap()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDoubleTap\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Double tap touch at a location.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-double-tap=\"onDoubleTap()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onTouch\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called immediately when the user first begins a touch. This\n\t * gesture does not wait for a touchend/mouseup.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-touch=\"onTouch()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onRelease\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when the user ends a touch.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-release=\"onRelease()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDragStart\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when a drag gesture has started.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-drag-start=\"onDragStart()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDrag\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Move with one touch around on the page. Blocking the scrolling when\n\t * moving left and right is a good practice. When all the drag events are\n\t * blocking you disable scrolling on that area.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-drag=\"onDrag()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDragEnd\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when a drag gesture has ended.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-drag-end=\"onDragEnd()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDragUp\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when the element is dragged up.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-drag-up=\"onDragUp()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDragRight\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when the element is dragged to the right.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-drag-right=\"onDragRight()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDragDown\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when the element is dragged down.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-drag-down=\"onDragDown()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onDragLeft\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when the element is dragged to the left.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-drag-left=\"onDragLeft()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onSwipe\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when a moving touch has a high velocity in any direction.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-swipe=\"onSwipe()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onSwipeUp\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when a moving touch has a high velocity moving up.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-swipe-up=\"onSwipeUp()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onSwipeRight\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when a moving touch has a high velocity moving to the right.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-swipe-right=\"onSwipeRight()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onSwipeDown\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when a moving touch has a high velocity moving down.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-swipe-down=\"onSwipeDown()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name onSwipeLeft\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * Called when a moving touch has a high velocity moving to the left.\n\t *\n\t * @usage\n\t * ```html\n\t * <button on-swipe-left=\"onSwipeLeft()\" class=\"button\">Test</button>\n\t * ```\n\t */\n\t\n\t\n\tfunction gestureDirective(directiveName) {\n\t  return ['$ionicGesture', '$parse', function($ionicGesture, $parse) {\n\t    var eventType = directiveName.substr(2).toLowerCase();\n\t\n\t    return function(scope, element, attr) {\n\t      var fn = $parse( attr[directiveName] );\n\t\n\t      var listener = function(ev) {\n\t        scope.$apply(function() {\n\t          fn(scope, {\n\t            $event: ev\n\t          });\n\t        });\n\t      };\n\t\n\t      var gesture = $ionicGesture.on(eventType, listener, element);\n\t\n\t      scope.$on('$destroy', function() {\n\t        $ionicGesture.off(gesture, eventType, listener);\n\t      });\n\t    };\n\t  }];\n\t}\n\n\n/***/ },\n/* 48 */\n/***/ function(module, exports) {\n\n\t\n\tIonicModule\n\t//.directive('ionHeaderBar', tapScrollToTopDirective())\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ionHeaderBar\n\t * @module ionic\n\t * @restrict E\n\t *\n\t * @description\n\t * Adds a fixed header bar above some content.\n\t *\n\t * Can also be a subheader (lower down) if the 'bar-subheader' class is applied.\n\t * See [the header CSS docs](/docs/components/#subheader).\n\t *\n\t * @param {string=} align-title How to align the title. By default the title\n\t * will be aligned the same as how the platform aligns its titles (iOS centers\n\t * titles, Android aligns them left).\n\t * Available: 'left', 'right', or 'center'.  Defaults to the same as the platform.\n\t * @param {boolean=} no-tap-scroll By default, the header bar will scroll the\n\t * content to the top when tapped.  Set no-tap-scroll to true to disable this\n\t * behavior.\n\t * Available: true or false.  Defaults to false.\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-header-bar align-title=\"left\" class=\"bar-positive\">\n\t *   <div class=\"buttons\">\n\t *     <button class=\"button\" ng-click=\"doSomething()\">Left Button</button>\n\t *   </div>\n\t *   <h1 class=\"title\">Title!</h1>\n\t *   <div class=\"buttons\">\n\t *     <button class=\"button\">Right Button</button>\n\t *   </div>\n\t * </ion-header-bar>\n\t * <ion-content>\n\t *   Some content!\n\t * </ion-content>\n\t * ```\n\t */\n\t.directive('ionHeaderBar', headerFooterBarDirective(true))\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ionFooterBar\n\t * @module ionic\n\t * @restrict E\n\t *\n\t * @description\n\t * Adds a fixed footer bar below some content.\n\t *\n\t * Can also be a subfooter (higher up) if the 'bar-subfooter' class is applied.\n\t * See [the footer CSS docs](/docs/components/#footer).\n\t *\n\t * Note: If you use ionFooterBar in combination with ng-if, the surrounding content\n\t * will not align correctly.  This will be fixed soon.\n\t *\n\t * @param {string=} align-title Where to align the title.\n\t * Available: 'left', 'right', or 'center'.  Defaults to 'center'.\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-content>\n\t *   Some content!\n\t * </ion-content>\n\t * <ion-footer-bar align-title=\"left\" class=\"bar-assertive\">\n\t *   <div class=\"buttons\">\n\t *     <button class=\"button\">Left Button</button>\n\t *   </div>\n\t *   <h1 class=\"title\">Title!</h1>\n\t *   <div class=\"buttons\" ng-click=\"doSomething()\">\n\t *     <button class=\"button\">Right Button</button>\n\t *   </div>\n\t * </ion-footer-bar>\n\t * ```\n\t */\n\t.directive('ionFooterBar', headerFooterBarDirective(false));\n\t\n\tfunction tapScrollToTopDirective() { //eslint-disable-line no-unused-vars\n\t  return ['$ionicScrollDelegate', function($ionicScrollDelegate) {\n\t    return {\n\t      restrict: 'E',\n\t      link: function($scope, $element, $attr) {\n\t        if ($attr.noTapScroll == 'true') {\n\t          return;\n\t        }\n\t        ionic.on('tap', onTap, $element[0]);\n\t        $scope.$on('$destroy', function() {\n\t          ionic.off('tap', onTap, $element[0]);\n\t        });\n\t\n\t        function onTap(e) {\n\t          var depth = 3;\n\t          var current = e.target;\n\t          //Don't scroll to top in certain cases\n\t          while (depth-- && current) {\n\t            if (current.classList.contains('button') ||\n\t                current.tagName.match(/input|textarea|select/i) ||\n\t                current.isContentEditable) {\n\t              return;\n\t            }\n\t            current = current.parentNode;\n\t          }\n\t          var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];\n\t          var bounds = $element[0].getBoundingClientRect();\n\t          if (ionic.DomUtil.rectContains(\n\t            touch.pageX, touch.pageY,\n\t            bounds.left, bounds.top - 20,\n\t            bounds.left + bounds.width, bounds.top + bounds.height\n\t          )) {\n\t            $ionicScrollDelegate.scrollTop(true);\n\t          }\n\t        }\n\t      }\n\t    };\n\t  }];\n\t}\n\t\n\tfunction headerFooterBarDirective(isHeader) {\n\t  return ['$document', '$timeout', function($document, $timeout) {\n\t    return {\n\t      restrict: 'E',\n\t      controller: '$ionicHeaderBar',\n\t      compile: function(tElement) {\n\t        tElement.addClass(isHeader ? 'bar bar-header' : 'bar bar-footer');\n\t        // top style tabs? if so, remove bottom border for seamless display\n\t        $timeout(function() {\n\t          if (isHeader && $document[0].getElementsByClassName('tabs-top').length) tElement.addClass('has-tabs-top');\n\t        });\n\t\n\t        return { pre: prelink };\n\t        function prelink($scope, $element, $attr, ctrl) {\n\t          if (isHeader) {\n\t            $scope.$watch(function() { return $element[0].className; }, function(value) {\n\t              var isShown = value.indexOf('ng-hide') === -1;\n\t              var isSubheader = value.indexOf('bar-subheader') !== -1;\n\t              $scope.$hasHeader = isShown && !isSubheader;\n\t              $scope.$hasSubheader = isShown && isSubheader;\n\t              $scope.$emit('$ionicSubheader', $scope.$hasSubheader);\n\t            });\n\t            $scope.$on('$destroy', function() {\n\t              delete $scope.$hasHeader;\n\t              delete $scope.$hasSubheader;\n\t            });\n\t            ctrl.align();\n\t            $scope.$on('$ionicHeader.align', function() {\n\t              ionic.requestAnimationFrame(function() {\n\t                ctrl.align();\n\t              });\n\t            });\n\t\n\t          } else {\n\t            $scope.$watch(function() { return $element[0].className; }, function(value) {\n\t              var isShown = value.indexOf('ng-hide') === -1;\n\t              var isSubfooter = value.indexOf('bar-subfooter') !== -1;\n\t              $scope.$hasFooter = isShown && !isSubfooter;\n\t              $scope.$hasSubfooter = isShown && isSubfooter;\n\t            });\n\t            $scope.$on('$destroy', function() {\n\t              delete $scope.$hasFooter;\n\t              delete $scope.$hasSubfooter;\n\t            });\n\t            $scope.$watch('$hasTabs', function(val) {\n\t              $element.toggleClass('has-tabs', !!val);\n\t            });\n\t            ctrl.align();\n\t            $scope.$on('$ionicFooter.align', function() {\n\t              ionic.requestAnimationFrame(function() {\n\t                ctrl.align();\n\t              });\n\t            });\n\t          }\n\t        }\n\t      }\n\t    };\n\t  }];\n\t}\n\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionInfiniteScroll\n\t * @module ionic\n\t * @parent ionic.directive:ionContent, ionic.directive:ionScroll\n\t * @restrict E\n\t *\n\t * @description\n\t * The ionInfiniteScroll directive allows you to call a function whenever\n\t * the user gets to the bottom of the page or near the bottom of the page.\n\t *\n\t * The expression you pass in for `on-infinite` is called when the user scrolls\n\t * greater than `distance` away from the bottom of the content.  Once `on-infinite`\n\t * is done loading new data, it should broadcast the `scroll.infiniteScrollComplete`\n\t * event from your controller (see below example).\n\t *\n\t * @param {expression} on-infinite What to call when the scroller reaches the\n\t * bottom.\n\t * @param {string=} distance The distance from the bottom that the scroll must\n\t * reach to trigger the on-infinite expression. Default: 1%.\n\t * @param {string=} spinner The {@link ionic.directive:ionSpinner} to show while loading. The SVG\n\t * {@link ionic.directive:ionSpinner} is now the default, replacing rotating font icons.\n\t * @param {string=} icon The icon to show while loading. Default: 'ion-load-d'.  This is depreicated\n\t * in favor of the SVG {@link ionic.directive:ionSpinner}.\n\t * @param {boolean=} immediate-check Whether to check the infinite scroll bounds immediately on load.\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-content ng-controller=\"MyController\">\n\t *   <ion-list>\n\t *   ....\n\t *   ....\n\t *   </ion-list>\n\t *\n\t *   <ion-infinite-scroll\n\t *     on-infinite=\"loadMore()\"\n\t *     distance=\"1%\">\n\t *   </ion-infinite-scroll>\n\t * </ion-content>\n\t * ```\n\t * ```js\n\t * function MyController($scope, $http) {\n\t *   $scope.items = [];\n\t *   $scope.loadMore = function() {\n\t *     $http.get('/more-items').success(function(items) {\n\t *       useItems(items);\n\t *       $scope.$broadcast('scroll.infiniteScrollComplete');\n\t *     });\n\t *   };\n\t *\n\t *   $scope.$on('$stateChangeSuccess', function() {\n\t *     $scope.loadMore();\n\t *   });\n\t * }\n\t * ```\n\t *\n\t * An easy to way to stop infinite scroll once there is no more data to load\n\t * is to use angular's `ng-if` directive:\n\t *\n\t * ```html\n\t * <ion-infinite-scroll\n\t *   ng-if=\"moreDataCanBeLoaded()\"\n\t *   icon=\"ion-loading-c\"\n\t *   on-infinite=\"loadMoreData()\">\n\t * </ion-infinite-scroll>\n\t * ```\n\t */\n\tIonicModule\n\t.directive('ionInfiniteScroll', ['$timeout', function($timeout) {\n\t  return {\n\t    restrict: 'E',\n\t    require: ['?^$ionicScroll', 'ionInfiniteScroll'],\n\t    template: function($element, $attrs) {\n\t      if ($attrs.icon) return '<i class=\"icon {{icon()}} icon-refreshing {{scrollingType}}\"></i>';\n\t      return '<ion-spinner icon=\"{{spinner()}}\"></ion-spinner>';\n\t    },\n\t    scope: true,\n\t    controller: '$ionInfiniteScroll',\n\t    link: function($scope, $element, $attrs, ctrls) {\n\t      var infiniteScrollCtrl = ctrls[1];\n\t      var scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0];\n\t      var jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();\n\t\n\t      // if this view is not beneath a scrollCtrl, it can't be injected, proceed w/ native scrolling\n\t      if (jsScrolling) {\n\t        infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;\n\t        $scope.scrollingType = 'js-scrolling';\n\t        //bind to JS scroll events\n\t        scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds);\n\t      } else {\n\t        // grabbing the scrollable element, to determine dimensions, and current scroll pos\n\t        var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll');\n\t        infiniteScrollCtrl.scrollEl = scrollEl;\n\t        // if there's no scroll controller, and no overflow scroll div, infinite scroll wont work\n\t        if (!scrollEl) {\n\t          throw 'Infinite scroll must be used inside a scrollable div';\n\t        }\n\t        //bind to native scroll events\n\t        infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds);\n\t      }\n\t\n\t      // Optionally check bounds on start after scrollView is fully rendered\n\t      var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : true;\n\t      if (doImmediateCheck) {\n\t        $timeout(function() { infiniteScrollCtrl.checkBounds(); });\n\t      }\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t* @ngdoc directive\r\n\t* @name ionInput\r\n\t* @parent ionic.directive:ionList\r\n\t* @module ionic\r\n\t* @restrict E\r\n\t* Creates a text input group that can easily be focused\r\n\t*\r\n\t* @usage\r\n\t*\r\n\t* ```html\r\n\t* <ion-list>\r\n\t*   <ion-input>\r\n\t*     <input type=\"text\" placeholder=\"First Name\">\r\n\t*   <ion-input>\r\n\t*\r\n\t*   <ion-input>\r\n\t*     <ion-label>Username</ion-label>\r\n\t*     <input type=\"text\">\r\n\t*   </ion-input>\r\n\t* </ion-list>\r\n\t* ```\r\n\t*/\r\n\t\r\n\tvar labelIds = -1;\r\n\t\r\n\tIonicModule\r\n\t.directive('ionInput', [function() {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    controller: ['$scope', '$element', function($scope, $element) {\r\n\t      this.$scope = $scope;\r\n\t      this.$element = $element;\r\n\t\r\n\t      this.setInputAriaLabeledBy = function(id) {\r\n\t        var inputs = $element[0].querySelectorAll('input,textarea');\r\n\t        inputs.length && inputs[0].setAttribute('aria-labelledby', id);\r\n\t      };\r\n\t\r\n\t      this.focus = function() {\r\n\t        var inputs = $element[0].querySelectorAll('input,textarea');\r\n\t        inputs.length && inputs[0].focus();\r\n\t      };\r\n\t    }]\r\n\t  };\r\n\t}]);\r\n\t\r\n\t/**\r\n\t* @ngdoc directive\r\n\t* @name ionLabel\r\n\t* @parent ionic.directive:ionList\r\n\t* @module ionic\r\n\t* @restrict E\r\n\t*\r\n\t* New in Ionic 1.2. It is strongly recommended that you use `<ion-label>` in place\r\n\t* of any `<label>` elements for maximum cross-browser support and performance.\r\n\t*\r\n\t* Creates a label for a form input.\r\n\t*\r\n\t* @usage\r\n\t*\r\n\t* ```html\r\n\t* <ion-list>\r\n\t*   <ion-input>\r\n\t*     <ion-label>Username</ion-label>\r\n\t*     <input type=\"text\">\r\n\t*   </ion-input>\r\n\t* </ion-list>\r\n\t* ```\r\n\t*/\r\n\tIonicModule\r\n\t.directive('ionLabel', [function() {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    require: '?^ionInput',\r\n\t    compile: function() {\r\n\t\r\n\t      return function link($scope, $element, $attrs, ionInputCtrl) {\r\n\t        var element = $element[0];\r\n\t\r\n\t        $element.addClass('input-label');\r\n\t\r\n\t        $element.attr('aria-label', $element.text());\r\n\t        var id = element.id || '_label-' + ++labelIds;\r\n\t\r\n\t        if (!element.id) {\r\n\t          $element.attr('id', id);\r\n\t        }\r\n\t\r\n\t        if (ionInputCtrl) {\r\n\t\r\n\t          ionInputCtrl.setInputAriaLabeledBy(id);\r\n\t\r\n\t          $element.on('click', function() {\r\n\t            ionInputCtrl.focus();\r\n\t          });\r\n\t        }\r\n\t      };\r\n\t    }\r\n\t  };\r\n\t}]);\r\n\t\r\n\t/**\r\n\t * Input label adds accessibility to <span class=\"input-label\">.\r\n\t */\r\n\tIonicModule\r\n\t.directive('inputLabel', [function() {\r\n\t  return {\r\n\t    restrict: 'C',\r\n\t    require: '?^ionInput',\r\n\t    compile: function() {\r\n\t\r\n\t      return function link($scope, $element, $attrs, ionInputCtrl) {\r\n\t        var element = $element[0];\r\n\t\r\n\t        $element.attr('aria-label', $element.text());\r\n\t        var id = element.id || '_label-' + ++labelIds;\r\n\t\r\n\t        if (!element.id) {\r\n\t          $element.attr('id', id);\r\n\t        }\r\n\t\r\n\t        if (ionInputCtrl) {\r\n\t          ionInputCtrl.setInputAriaLabeledBy(id);\r\n\t        }\r\n\t\r\n\t      };\r\n\t    }\r\n\t  };\r\n\t}]);\r\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\tvar ITEM_TPL_DELETE_BUTTON =\n\t  '<div class=\"item-left-edit item-delete enable-pointer-events\">' +\n\t  '</div>';\n\t/**\n\t* @ngdoc directive\n\t* @name ionDeleteButton\n\t* @parent ionic.directive:ionItem\n\t* @module ionic\n\t* @restrict E\n\t* Creates a delete button inside a list item, that is visible when the\n\t* {@link ionic.directive:ionList ionList parent's} `show-delete` evaluates to true or\n\t* `$ionicListDelegate.showDelete(true)` is called.\n\t*\n\t* Takes any ionicon as a class.\n\t*\n\t* See {@link ionic.directive:ionList} for a complete example & explanation.\n\t*\n\t* @usage\n\t*\n\t* ```html\n\t* <ion-list show-delete=\"shouldShowDelete\">\n\t*   <ion-item>\n\t*     <ion-delete-button class=\"ion-minus-circled\"></ion-delete-button>\n\t*     Hello, list item!\n\t*   </ion-item>\n\t* </ion-list>\n\t* <ion-toggle ng-model=\"shouldShowDelete\">\n\t*   Show Delete?\n\t* </ion-toggle>\n\t* ```\n\t*/\n\tIonicModule\n\t.directive('ionDeleteButton', function() {\n\t\n\t  function stopPropagation(ev) {\n\t    ev.stopPropagation();\n\t  }\n\t\n\t  return {\n\t    restrict: 'E',\n\t    require: ['^^ionItem', '^?ionList'],\n\t    //Run before anything else, so we can move it before other directives process\n\t    //its location (eg ngIf relies on the location of the directive in the dom)\n\t    priority: Number.MAX_VALUE,\n\t    compile: function($element, $attr) {\n\t      //Add the classes we need during the compile phase, so that they stay\n\t      //even if something else like ngIf removes the element and re-addss it\n\t      $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);\n\t      return function($scope, $element, $attr, ctrls) {\n\t        var itemCtrl = ctrls[0];\n\t        var listCtrl = ctrls[1];\n\t        var container = jqLite(ITEM_TPL_DELETE_BUTTON);\n\t        container.append($element);\n\t        itemCtrl.$element.append(container).addClass('item-left-editable');\n\t\n\t        //Don't bubble click up to main .item\n\t        $element.on('click', stopPropagation);\n\t\n\t        init();\n\t        $scope.$on('$ionic.reconnectScope', init);\n\t        function init() {\n\t          listCtrl = listCtrl || $element.controller('ionList');\n\t          if (listCtrl && listCtrl.showDelete()) {\n\t            container.addClass('visible active');\n\t          }\n\t        }\n\t      };\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t\n\tIonicModule\n\t.directive('itemFloatingLabel', function() {\n\t  return {\n\t    restrict: 'C',\n\t    link: function(scope, element) {\n\t      var el = element[0];\n\t      var input = el.querySelector('input, textarea');\n\t      var inputLabel = el.querySelector('.input-label');\n\t\n\t      if (!input || !inputLabel) return;\n\t\n\t      var onInput = function() {\n\t        if (input.value) {\n\t          inputLabel.classList.add('has-input');\n\t        } else {\n\t          inputLabel.classList.remove('has-input');\n\t        }\n\t      };\n\t\n\t      input.addEventListener('input', onInput);\n\t\n\t      var ngModelCtrl = jqLite(input).controller('ngModel');\n\t      if (ngModelCtrl) {\n\t        ngModelCtrl.$render = function() {\n\t          input.value = ngModelCtrl.$viewValue || '';\n\t          onInput();\n\t        };\n\t      }\n\t\n\t      scope.$on('$destroy', function() {\n\t        input.removeEventListener('input', onInput);\n\t      });\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports) {\n\n\t/**\n\t* @ngdoc directive\n\t* @name ionItem\n\t* @parent ionic.directive:ionList\n\t* @module ionic\n\t* @restrict E\n\t* Creates a list-item that can easily be swiped,\n\t* deleted, reordered, edited, and more.\n\t*\n\t* See {@link ionic.directive:ionList} for a complete example & explanation.\n\t*\n\t* Can be assigned any item class name. See the\n\t* [list CSS documentation](/docs/components/#list).\n\t*\n\t* @usage\n\t*\n\t* ```html\n\t* <ion-list>\n\t*   <ion-item>Hello!</ion-item>\n\t*   <ion-item href=\"#/detail\">\n\t*     Link to detail page\n\t*   </ion-item>\n\t* </ion-list>\n\t* ```\n\t*/\n\tIonicModule\n\t.directive('ionItem', ['$$rAF', function($$rAF) {\n\t  return {\n\t    restrict: 'E',\n\t    controller: ['$scope', '$element', function($scope, $element) {\n\t      this.$scope = $scope;\n\t      this.$element = $element;\n\t    }],\n\t    scope: true,\n\t    compile: function($element, $attrs) {\n\t      var isAnchor = isDefined($attrs.href) ||\n\t                     isDefined($attrs.ngHref) ||\n\t                     isDefined($attrs.uiSref);\n\t      var isComplexItem = isAnchor ||\n\t        //Lame way of testing, but we have to know at compile what to do with the element\n\t        /ion-(delete|option|reorder)-button/i.test($element.html());\n\t\n\t      if (isComplexItem) {\n\t        var innerElement = jqLite(isAnchor ? '<a></a>' : '<div></div>');\n\t        innerElement.addClass('item-content');\n\t\n\t        if (isDefined($attrs.href) || isDefined($attrs.ngHref)) {\n\t          innerElement.attr('ng-href', '{{$href()}}');\n\t          if (isDefined($attrs.target)) {\n\t            innerElement.attr('target', '{{$target()}}');\n\t          }\n\t        }\n\t\n\t        innerElement.append($element.contents());\n\t\n\t        $element.addClass('item item-complex')\n\t                .append(innerElement);\n\t      } else {\n\t        $element.addClass('item');\n\t      }\n\t\n\t      return function link($scope, $element, $attrs) {\n\t        $scope.$href = function() {\n\t          return $attrs.href || $attrs.ngHref;\n\t        };\n\t        $scope.$target = function() {\n\t          return $attrs.target;\n\t        };\n\t\n\t        var content = $element[0].querySelector('.item-content');\n\t        if (content) {\n\t          $scope.$on('$collectionRepeatLeave', function() {\n\t            if (content && content.$$ionicOptionsOpen) {\n\t              content.style[ionic.CSS.TRANSFORM] = '';\n\t              content.style[ionic.CSS.TRANSITION] = 'none';\n\t              $$rAF(function() {\n\t                content.style[ionic.CSS.TRANSITION] = '';\n\t              });\n\t              content.$$ionicOptionsOpen = false;\n\t            }\n\t          });\n\t        }\n\t      };\n\t\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\tvar ITEM_TPL_OPTION_BUTTONS =\n\t  '<div class=\"item-options invisible\">' +\n\t  '</div>';\n\t/**\n\t* @ngdoc directive\n\t* @name ionOptionButton\n\t* @parent ionic.directive:ionItem\n\t* @module ionic\n\t* @restrict E\n\t* @description\n\t* Creates an option button inside a list item, that is visible when the item is swiped\n\t* to the left by the user.  Swiped open option buttons can be hidden with\n\t* {@link ionic.service:$ionicListDelegate#closeOptionButtons $ionicListDelegate.closeOptionButtons}.\n\t*\n\t* Can be assigned any button class.\n\t*\n\t* See {@link ionic.directive:ionList} for a complete example & explanation.\n\t*\n\t* @usage\n\t*\n\t* ```html\n\t* <ion-list>\n\t*   <ion-item>\n\t*     I love kittens!\n\t*     <ion-option-button class=\"button-positive\">Share</ion-option-button>\n\t*     <ion-option-button class=\"button-assertive\">Edit</ion-option-button>\n\t*   </ion-item>\n\t* </ion-list>\n\t* ```\n\t*/\n\tIonicModule.directive('ionOptionButton', [function() {\n\t  function stopPropagation(e) {\n\t    e.stopPropagation();\n\t  }\n\t  return {\n\t    restrict: 'E',\n\t    require: '^ionItem',\n\t    priority: Number.MAX_VALUE,\n\t    compile: function($element, $attr) {\n\t      $attr.$set('class', ($attr['class'] || '') + ' button', true);\n\t      return function($scope, $element, $attr, itemCtrl) {\n\t        if (!itemCtrl.optionsContainer) {\n\t          itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);\n\t          itemCtrl.$element.append(itemCtrl.optionsContainer);\n\t        }\n\t        itemCtrl.optionsContainer.append($element);\n\t\n\t        itemCtrl.$element.addClass('item-right-editable');\n\t\n\t        //Don't bubble click up to main .item\n\t        $element.on('click', stopPropagation);\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports) {\n\n\tvar ITEM_TPL_REORDER_BUTTON =\n\t  '<div data-prevent-scroll=\"true\" class=\"item-right-edit item-reorder enable-pointer-events\">' +\n\t  '</div>';\n\t\n\t/**\n\t* @ngdoc directive\n\t* @name ionReorderButton\n\t* @parent ionic.directive:ionItem\n\t* @module ionic\n\t* @restrict E\n\t* Creates a reorder button inside a list item, that is visible when the\n\t* {@link ionic.directive:ionList ionList parent's} `show-reorder` evaluates to true or\n\t* `$ionicListDelegate.showReorder(true)` is called.\n\t*\n\t* Can be dragged to reorder items in the list. Takes any ionicon class.\n\t*\n\t* Note: Reordering works best when used with `ng-repeat`.  Be sure that all `ion-item` children of an `ion-list` are part of the same `ng-repeat` expression.\n\t*\n\t* When an item reorder is complete, the expression given in the `on-reorder` attribute is called. The `on-reorder` expression is given two locals that can be used: `$fromIndex` and `$toIndex`.  See below for an example.\n\t*\n\t* Look at {@link ionic.directive:ionList} for more examples.\n\t*\n\t* @usage\n\t*\n\t* ```html\n\t* <ion-list ng-controller=\"MyCtrl\" show-reorder=\"true\">\n\t*   <ion-item ng-repeat=\"item in items\">\n\t*     Item {{item}}\n\t*     <ion-reorder-button class=\"ion-navicon\"\n\t*                         on-reorder=\"moveItem(item, $fromIndex, $toIndex)\">\n\t*     </ion-reorder-button>\n\t*   </ion-item>\n\t* </ion-list>\n\t* ```\n\t* ```js\n\t* function MyCtrl($scope) {\n\t*   $scope.items = [1, 2, 3, 4];\n\t*   $scope.moveItem = function(item, fromIndex, toIndex) {\n\t*     //Move the item in the array\n\t*     $scope.items.splice(fromIndex, 1);\n\t*     $scope.items.splice(toIndex, 0, item);\n\t*   };\n\t* }\n\t* ```\n\t*\n\t* @param {expression=} on-reorder Expression to call when an item is reordered.\n\t* Parameters given: $fromIndex, $toIndex.\n\t*/\n\tIonicModule\n\t.directive('ionReorderButton', ['$parse', function($parse) {\n\t  return {\n\t    restrict: 'E',\n\t    require: ['^ionItem', '^?ionList'],\n\t    priority: Number.MAX_VALUE,\n\t    compile: function($element, $attr) {\n\t      $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);\n\t      $element[0].setAttribute('data-prevent-scroll', true);\n\t      return function($scope, $element, $attr, ctrls) {\n\t        var itemCtrl = ctrls[0];\n\t        var listCtrl = ctrls[1];\n\t        var onReorderFn = $parse($attr.onReorder);\n\t\n\t        $scope.$onReorder = function(oldIndex, newIndex) {\n\t          onReorderFn($scope, {\n\t            $fromIndex: oldIndex,\n\t            $toIndex: newIndex\n\t          });\n\t        };\n\t\n\t        // prevent clicks from bubbling up to the item\n\t        if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {\n\t          $element[0].onclick = function(e) {\n\t            e.stopPropagation();\n\t            return false;\n\t          };\n\t        }\n\t\n\t        var container = jqLite(ITEM_TPL_REORDER_BUTTON);\n\t        container.append($element);\n\t        itemCtrl.$element.append(container).addClass('item-right-editable');\n\t\n\t        if (listCtrl && listCtrl.showReorder()) {\n\t          container.addClass('visible active');\n\t        }\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name keyboardAttach\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * keyboard-attach is an attribute directive which will cause an element to float above\n\t * the keyboard when the keyboard shows. Currently only supports the\n\t * [ion-footer-bar]({{ page.versionHref }}/api/directive/ionFooterBar/) directive.\n\t *\n\t * ### Notes\n\t * - This directive requires the\n\t * [Ionic Keyboard Plugin](https://github.com/driftyco/ionic-plugins-keyboard).\n\t * - On Android not in fullscreen mode, i.e. you have\n\t *   `<preference name=\"Fullscreen\" value=\"false\" />` or no preference in your `config.xml` file,\n\t *   this directive is unnecessary since it is the default behavior.\n\t * - On iOS, if there is an input in your footer, you will need to set\n\t *   `cordova.plugins.Keyboard.disableScroll(true)`.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t *  <ion-footer-bar align-title=\"left\" keyboard-attach class=\"bar-assertive\">\n\t *    <h1 class=\"title\">Title!</h1>\n\t *  </ion-footer-bar>\n\t * ```\n\t */\n\t\n\tIonicModule\n\t.directive('keyboardAttach', function() {\n\t  return function(scope, element) {\n\t    ionic.on('native.keyboardshow', onShow, window);\n\t    ionic.on('native.keyboardhide', onHide, window);\n\t\n\t    //deprecated\n\t    ionic.on('native.showkeyboard', onShow, window);\n\t    ionic.on('native.hidekeyboard', onHide, window);\n\t\n\t\n\t    var scrollCtrl;\n\t\n\t    function onShow(e) {\n\t      if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {\n\t        return;\n\t      }\n\t\n\t      //for testing\n\t      var keyboardHeight = e.keyboardHeight || (e.detail && e.detail.keyboardHeight);\n\t      element.css('bottom', keyboardHeight + \"px\");\n\t      scrollCtrl = element.controller('$ionicScroll');\n\t      if (scrollCtrl) {\n\t        scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + \"px\";\n\t      }\n\t    }\n\t\n\t    function onHide() {\n\t      if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {\n\t        return;\n\t      }\n\t\n\t      element.css('bottom', '');\n\t      if (scrollCtrl) {\n\t        scrollCtrl.scrollView.__container.style.bottom = '';\n\t      }\n\t    }\n\t\n\t    scope.$on('$destroy', function() {\n\t      ionic.off('native.keyboardshow', onShow, window);\n\t      ionic.off('native.keyboardhide', onHide, window);\n\t\n\t      //deprecated\n\t      ionic.off('native.showkeyboard', onShow, window);\n\t      ionic.off('native.hidekeyboard', onHide, window);\n\t    });\n\t  };\n\t});\n\t\n\tfunction keyboardAttachGetClientHeight(element) {\n\t  return element.clientHeight;\n\t}\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t/**\n\t* @ngdoc directive\n\t* @name ionList\n\t* @module ionic\n\t* @delegate ionic.service:$ionicListDelegate\n\t* @codepen JsHjf\n\t* @restrict E\n\t* @description\n\t* The List is a widely used interface element in almost any mobile app, and can include\n\t* content ranging from basic text all the way to buttons, toggles, icons, and thumbnails.\n\t*\n\t* Both the list, which contains items, and the list items themselves can be any HTML\n\t* element. The containing element requires the `list` class and each list item requires\n\t* the `item` class.\n\t*\n\t* However, using the ionList and ionItem directives make it easy to support various\n\t* interaction modes such as swipe to edit, drag to reorder, and removing items.\n\t*\n\t* Related: {@link ionic.directive:ionItem}, {@link ionic.directive:ionOptionButton}\n\t* {@link ionic.directive:ionReorderButton}, {@link ionic.directive:ionDeleteButton}, [`list CSS documentation`](/docs/components/#list).\n\t*\n\t* @usage\n\t*\n\t* Basic Usage:\n\t*\n\t* ```html\n\t* <ion-list>\n\t*   <ion-item ng-repeat=\"item in items\">\n\t*     {% raw %}Hello, {{item}}!{% endraw %}\n\t*   </ion-item>\n\t* </ion-list>\n\t* ```\n\t*\n\t* Advanced Usage: Thumbnails, Delete buttons, Reordering, Swiping\n\t*\n\t* ```html\n\t* <ion-list ng-controller=\"MyCtrl\"\n\t*           show-delete=\"shouldShowDelete\"\n\t*           show-reorder=\"shouldShowReorder\"\n\t*           can-swipe=\"listCanSwipe\">\n\t*   <ion-item ng-repeat=\"item in items\"\n\t*             class=\"item-thumbnail-left\">\n\t*\n\t*     {% raw %}<img ng-src=\"{{item.img}}\">\n\t*     <h2>{{item.title}}</h2>\n\t*     <p>{{item.description}}</p>{% endraw %}\n\t*     <ion-option-button class=\"button-positive\"\n\t*                        ng-click=\"share(item)\">\n\t*       Share\n\t*     </ion-option-button>\n\t*     <ion-option-button class=\"button-info\"\n\t*                        ng-click=\"edit(item)\">\n\t*       Edit\n\t*     </ion-option-button>\n\t*     <ion-delete-button class=\"ion-minus-circled\"\n\t*                        ng-click=\"items.splice($index, 1)\">\n\t*     </ion-delete-button>\n\t*     <ion-reorder-button class=\"ion-navicon\"\n\t*                         on-reorder=\"reorderItem(item, $fromIndex, $toIndex)\">\n\t*     </ion-reorder-button>\n\t*\n\t*   </ion-item>\n\t* </ion-list>\n\t* ```\n\t*\n\t*```javascript\n\t* app.controller('MyCtrl', function($scope) {\n\t*  $scope.shouldShowDelete = false;\n\t*  $scope.shouldShowReorder = false;\n\t*  $scope.listCanSwipe = true\n\t* });\n\t*```\n\t*\n\t* @param {string=} delegate-handle The handle used to identify this list with\n\t* {@link ionic.service:$ionicListDelegate}.\n\t* @param type {string=} The type of list to use (list-inset or card)\n\t* @param show-delete {boolean=} Whether the delete buttons for the items in the list are\n\t* currently shown or hidden.\n\t* @param show-reorder {boolean=} Whether the reorder buttons for the items in the list are\n\t* currently shown or hidden.\n\t* @param can-swipe {boolean=} Whether the items in the list are allowed to be swiped to reveal\n\t* option buttons. Default: true.\n\t*/\n\tIonicModule\n\t.directive('ionList', [\n\t  '$timeout',\n\tfunction($timeout) {\n\t  return {\n\t    restrict: 'E',\n\t    require: ['ionList', '^?$ionicScroll'],\n\t    controller: '$ionicList',\n\t    compile: function($element, $attr) {\n\t      var listEl = jqLite('<div class=\"list\">')\n\t        .append($element.contents())\n\t        .addClass($attr.type);\n\t\n\t      $element.append(listEl);\n\t\n\t      return function($scope, $element, $attrs, ctrls) {\n\t        var listCtrl = ctrls[0];\n\t        var scrollCtrl = ctrls[1];\n\t\n\t        // Wait for child elements to render...\n\t        $timeout(init);\n\t\n\t        function init() {\n\t          var listView = listCtrl.listView = new ionic.views.ListView({\n\t            el: $element[0],\n\t            listEl: $element.children()[0],\n\t            scrollEl: scrollCtrl && scrollCtrl.element,\n\t            scrollView: scrollCtrl && scrollCtrl.scrollView,\n\t            onReorder: function(el, oldIndex, newIndex) {\n\t              var itemScope = jqLite(el).scope();\n\t              if (itemScope && itemScope.$onReorder) {\n\t                // Make sure onReorder is called in apply cycle,\n\t                // but also make sure it has no conflicts by doing\n\t                // $evalAsync\n\t                $timeout(function() {\n\t                  itemScope.$onReorder(oldIndex, newIndex);\n\t                });\n\t              }\n\t            },\n\t            canSwipe: function() {\n\t              return listCtrl.canSwipeItems();\n\t            }\n\t          });\n\t\n\t          $scope.$on('$destroy', function() {\n\t            if (listView) {\n\t              listView.deregister && listView.deregister();\n\t              listView = null;\n\t            }\n\t          });\n\t\n\t          if (isDefined($attr.canSwipe)) {\n\t            $scope.$watch('!!(' + $attr.canSwipe + ')', function(value) {\n\t              listCtrl.canSwipeItems(value);\n\t            });\n\t          }\n\t          if (isDefined($attr.showDelete)) {\n\t            $scope.$watch('!!(' + $attr.showDelete + ')', function(value) {\n\t              listCtrl.showDelete(value);\n\t            });\n\t          }\n\t          if (isDefined($attr.showReorder)) {\n\t            $scope.$watch('!!(' + $attr.showReorder + ')', function(value) {\n\t              listCtrl.showReorder(value);\n\t            });\n\t          }\n\t\n\t          $scope.$watch(function() {\n\t            return listCtrl.showDelete();\n\t          }, function(isShown, wasShown) {\n\t            //Only use isShown=false if it was already shown\n\t            if (!isShown && !wasShown) { return; }\n\t\n\t            if (isShown) listCtrl.closeOptionButtons();\n\t            listCtrl.canSwipeItems(!isShown);\n\t\n\t            $element.children().toggleClass('list-left-editing', isShown);\n\t            $element.toggleClass('disable-pointer-events', isShown);\n\t\n\t            var deleteButton = jqLite($element[0].getElementsByClassName('item-delete'));\n\t            setButtonShown(deleteButton, listCtrl.showDelete);\n\t          });\n\t\n\t          $scope.$watch(function() {\n\t            return listCtrl.showReorder();\n\t          }, function(isShown, wasShown) {\n\t            //Only use isShown=false if it was already shown\n\t            if (!isShown && !wasShown) { return; }\n\t\n\t            if (isShown) listCtrl.closeOptionButtons();\n\t            listCtrl.canSwipeItems(!isShown);\n\t\n\t            $element.children().toggleClass('list-right-editing', isShown);\n\t            $element.toggleClass('disable-pointer-events', isShown);\n\t\n\t            var reorderButton = jqLite($element[0].getElementsByClassName('item-reorder'));\n\t            setButtonShown(reorderButton, listCtrl.showReorder);\n\t          });\n\t\n\t          function setButtonShown(el, shown) {\n\t            shown() && el.addClass('visible') || el.removeClass('active');\n\t            ionic.requestAnimationFrame(function() {\n\t              shown() && el.addClass('active') || el.removeClass('visible');\n\t            });\n\t          }\n\t        }\n\t\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name menuClose\n\t * @module ionic\n\t * @restrict AC\n\t *\n\t * @description\n\t * `menu-close` is an attribute directive that closes a currently opened side menu.\n\t * Note that by default, navigation transitions will not animate between views when\n\t * the menu is open. Additionally, this directive will reset the entering view's\n\t * history stack, making the new page the root of the history stack. This is done\n\t * to replicate the user experience seen in most side menu implementations, which is\n\t * to not show the back button at the root of the stack and show only the\n\t * menu button. We recommend that you also use the `enable-menu-with-back-views=\"false\"`\n\t * {@link ionic.directive:ionSideMenus} attribute when using the menuClose directive.\n\t *\n\t * @usage\n\t * Below is an example of a link within a side menu. Tapping this link would\n\t * automatically close the currently opened menu.\n\t *\n\t * ```html\n\t * <a menu-close href=\"#/home\" class=\"item\">Home</a>\n\t * ```\n\t *\n\t * Note that if your destination state uses a resolve and that resolve asynchronously\n\t * takes longer than a standard transition (300ms), you'll need to set the\n\t * `nextViewOptions` manually as your resolve completes.\n\t *\n\t * ```js\n\t * $ionicHistory.nextViewOptions({\n\t *  historyRoot: true,\n\t *  disableAnimate: true,\n\t *  expire: 300\n\t * });\n\t * ```\n\t */\n\tIonicModule\n\t.directive('menuClose', ['$ionicHistory', '$timeout', function($ionicHistory, $timeout) {\n\t  return {\n\t    restrict: 'AC',\n\t    link: function($scope, $element) {\n\t      $element.bind('click', function() {\n\t        var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');\n\t        if (sideMenuCtrl) {\n\t          $ionicHistory.nextViewOptions({\n\t            historyRoot: true,\n\t            disableAnimate: true,\n\t            expire: 300\n\t          });\n\t          // if no transition in 300ms, reset nextViewOptions\n\t          // the expire should take care of it, but will be cancelled in some\n\t          // cases. This directive is an exception to the rules of history.js\n\t          $timeout( function() {\n\t            $ionicHistory.nextViewOptions({\n\t              historyRoot: false,\n\t              disableAnimate: false\n\t            });\n\t          }, 300);\n\t          sideMenuCtrl.close();\n\t        }\n\t      });\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name menuToggle\n\t * @module ionic\n\t * @restrict AC\n\t *\n\t * @description\n\t * Toggle a side menu on the given side.\n\t *\n\t * @usage\n\t * Below is an example of a link within a nav bar. Tapping this button\n\t * would open the given side menu, and tapping it again would close it.\n\t *\n\t * ```html\n\t * <ion-nav-bar>\n\t *   <ion-nav-buttons side=\"left\">\n\t *    <!-- Toggle left side menu -->\n\t *    <button menu-toggle=\"left\" class=\"button button-icon icon ion-navicon\"></button>\n\t *   </ion-nav-buttons>\n\t *   <ion-nav-buttons side=\"right\">\n\t *    <!-- Toggle right side menu -->\n\t *    <button menu-toggle=\"right\" class=\"button button-icon icon ion-navicon\"></button>\n\t *   </ion-nav-buttons>\n\t * </ion-nav-bar>\n\t * ```\n\t *\n\t * ### Button Hidden On Child Views\n\t * By default, the menu toggle button will only appear on a root\n\t * level side-menu page. Navigating in to child views will hide the menu-\n\t * toggle button. They can be made visible on child pages by setting the\n\t * enable-menu-with-back-views attribute of the {@link ionic.directive:ionSideMenus}\n\t * directive to true.\n\t *\n\t * ```html\n\t * <ion-side-menus enable-menu-with-back-views=\"true\">\n\t * ```\n\t */\n\tIonicModule\n\t.directive('menuToggle', function() {\n\t  return {\n\t    restrict: 'AC',\n\t    link: function($scope, $element, $attr) {\n\t      $scope.$on('$ionicView.beforeEnter', function(ev, viewData) {\n\t        if (viewData.enableBack) {\n\t          var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');\n\t          if (!sideMenuCtrl.enableMenuWithBackViews()) {\n\t            $element.addClass('hide');\n\t          }\n\t        } else {\n\t          $element.removeClass('hide');\n\t        }\n\t      });\n\t\n\t      $element.bind('click', function() {\n\t        var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');\n\t        sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);\n\t      });\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t/*\n\t * We don't document the ionModal directive, we instead document\n\t * the $ionicModal service\n\t */\n\tIonicModule\n\t.directive('ionModal', [function() {\n\t  return {\n\t    restrict: 'E',\n\t    transclude: true,\n\t    replace: true,\n\t    controller: [function() {}],\n\t    template: '<div class=\"modal-backdrop\">' +\n\t                '<div class=\"modal-backdrop-bg\"></div>' +\n\t                '<div class=\"modal-wrapper\" ng-transclude></div>' +\n\t              '</div>'\n\t  };\n\t}]);\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.directive('ionModalView', function() {\n\t  return {\n\t    restrict: 'E',\n\t    compile: function(element) {\n\t      element.addClass('modal');\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionNavBackButton\n\t * @module ionic\n\t * @restrict E\n\t * @parent ionNavBar\n\t * @description\n\t * Creates a back button inside an {@link ionic.directive:ionNavBar}.\n\t *\n\t * The back button will appear when the user is able to go back in the current navigation stack. By\n\t * default, the markup of the back button is automatically built using platform-appropriate defaults\n\t * (iOS back button icon on iOS and Android icon on Android).\n\t *\n\t * Additionally, the button is automatically set to `$ionicGoBack()` on click/tap. By default, the\n\t * app will navigate back one view when the back button is clicked.  More advanced behavior is also\n\t * possible, as outlined below.\n\t *\n\t * @usage\n\t *\n\t * Recommended markup for default settings:\n\t *\n\t * ```html\n\t * <ion-nav-bar>\n\t *   <ion-nav-back-button>\n\t *   </ion-nav-back-button>\n\t * </ion-nav-bar>\n\t * ```\n\t *\n\t * With custom inner markup, and automatically adds a default click action:\n\t *\n\t * ```html\n\t * <ion-nav-bar>\n\t *   <ion-nav-back-button class=\"button-clear\">\n\t *     <i class=\"ion-arrow-left-c\"></i> Back\n\t *   </ion-nav-back-button>\n\t * </ion-nav-bar>\n\t * ```\n\t *\n\t * With custom inner markup and custom click action, using {@link ionic.service:$ionicHistory}:\n\t *\n\t * ```html\n\t * <ion-nav-bar ng-controller=\"MyCtrl\">\n\t *   <ion-nav-back-button class=\"button-clear\"\n\t *     ng-click=\"myGoBack()\">\n\t *     <i class=\"ion-arrow-left-c\"></i> Back\n\t *   </ion-nav-back-button>\n\t * </ion-nav-bar>\n\t * ```\n\t * ```js\n\t * function MyCtrl($scope, $ionicHistory) {\n\t *   $scope.myGoBack = function() {\n\t *     $ionicHistory.goBack();\n\t *   };\n\t * }\n\t * ```\n\t */\n\tIonicModule\n\t.directive('ionNavBackButton', ['$ionicConfig', '$document', function($ionicConfig, $document) {\n\t  return {\n\t    restrict: 'E',\n\t    require: '^ionNavBar',\n\t    compile: function(tElement, tAttrs) {\n\t\n\t      // clone the back button, but as a <div>\n\t      var buttonEle = $document[0].createElement('button');\n\t      for (var n in tAttrs.$attr) {\n\t        buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);\n\t      }\n\t\n\t      if (!tAttrs.ngClick) {\n\t        buttonEle.setAttribute('ng-click', '$ionicGoBack()');\n\t      }\n\t\n\t      buttonEle.className = 'button back-button hide buttons ' + (tElement.attr('class') || '');\n\t      buttonEle.innerHTML = tElement.html() || '';\n\t\n\t      var childNode;\n\t      var hasIcon = hasIconClass(tElement[0]);\n\t      var hasInnerText;\n\t      var hasButtonText;\n\t      var hasPreviousTitle;\n\t\n\t      for (var x = 0; x < tElement[0].childNodes.length; x++) {\n\t        childNode = tElement[0].childNodes[x];\n\t        if (childNode.nodeType === 1) {\n\t          if (hasIconClass(childNode)) {\n\t            hasIcon = true;\n\t          } else if (childNode.classList.contains('default-title')) {\n\t            hasButtonText = true;\n\t          } else if (childNode.classList.contains('previous-title')) {\n\t            hasPreviousTitle = true;\n\t          }\n\t        } else if (!hasInnerText && childNode.nodeType === 3) {\n\t          hasInnerText = !!childNode.nodeValue.trim();\n\t        }\n\t      }\n\t\n\t      function hasIconClass(ele) {\n\t        return /ion-|icon/.test(ele.className);\n\t      }\n\t\n\t      var defaultIcon = $ionicConfig.backButton.icon();\n\t      if (!hasIcon && defaultIcon && defaultIcon !== 'none') {\n\t        buttonEle.innerHTML = '<i class=\"icon ' + defaultIcon + '\"></i> ' + buttonEle.innerHTML;\n\t        buttonEle.className += ' button-clear';\n\t      }\n\t\n\t      if (!hasInnerText) {\n\t        var buttonTextEle = $document[0].createElement('span');\n\t        buttonTextEle.className = 'back-text';\n\t\n\t        if (!hasButtonText && $ionicConfig.backButton.text()) {\n\t          buttonTextEle.innerHTML += '<span class=\"default-title\">' + $ionicConfig.backButton.text() + '</span>';\n\t        }\n\t        if (!hasPreviousTitle && $ionicConfig.backButton.previousTitleText()) {\n\t          buttonTextEle.innerHTML += '<span class=\"previous-title\"></span>';\n\t        }\n\t        buttonEle.appendChild(buttonTextEle);\n\t\n\t      }\n\t\n\t      tElement.attr('class', 'hide');\n\t      tElement.empty();\n\t\n\t      return {\n\t        pre: function($scope, $element, $attr, navBarCtrl) {\n\t          // only register the plain HTML, the navBarCtrl takes care of scope/compile/link\n\t          navBarCtrl.navElement('backButton', buttonEle.outerHTML);\n\t          buttonEle = null;\n\t        }\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ionNavBar\n\t * @module ionic\n\t * @delegate ionic.service:$ionicNavBarDelegate\n\t * @restrict E\n\t *\n\t * @description\n\t * If we have an {@link ionic.directive:ionNavView} directive, we can also create an\n\t * `<ion-nav-bar>`, which will create a topbar that updates as the application state changes.\n\t *\n\t * We can add a back button by putting an {@link ionic.directive:ionNavBackButton} inside.\n\t *\n\t * We can add buttons depending on the currently visible view using\n\t * {@link ionic.directive:ionNavButtons}.\n\t *\n\t * Note that the ion-nav-bar element will only work correctly if your content has an\n\t * ionView around it.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <body ng-app=\"starter\">\n\t *   <!-- The nav bar that will be updated as we navigate -->\n\t *   <ion-nav-bar class=\"bar-positive\">\n\t *   </ion-nav-bar>\n\t *\n\t *   <!-- where the initial view template will be rendered -->\n\t *   <ion-nav-view>\n\t *     <ion-view>\n\t *       <ion-content>Hello!</ion-content>\n\t *     </ion-view>\n\t *   </ion-nav-view>\n\t * </body>\n\t * ```\n\t *\n\t * @param {string=} delegate-handle The handle used to identify this navBar\n\t * with {@link ionic.service:$ionicNavBarDelegate}.\n\t * @param align-title {string=} Where to align the title of the navbar.\n\t * Available: 'left', 'right', 'center'. Defaults to 'center'.\n\t * @param {boolean=} no-tap-scroll By default, the navbar will scroll the content\n\t * to the top when tapped.  Set no-tap-scroll to true to disable this behavior.\n\t *\n\t * </table><br/>\n\t */\n\tIonicModule\n\t.directive('ionNavBar', function() {\n\t  return {\n\t    restrict: 'E',\n\t    controller: '$ionicNavBar',\n\t    scope: true,\n\t    link: function($scope, $element, $attr, ctrl) {\n\t      ctrl.init();\n\t    }\n\t  };\n\t});\n\t\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionNavButtons\n\t * @module ionic\n\t * @restrict E\n\t * @parent ionNavView\n\t *\n\t * @description\n\t * Use nav buttons to set the buttons on your {@link ionic.directive:ionNavBar}\n\t * from within an {@link ionic.directive:ionView}. This gives each\n\t * view template the ability to specify which buttons should show in the nav bar,\n\t * overriding any default buttons already placed in the nav bar.\n\t *\n\t * Any buttons you declare will be positioned on the navbar's corresponding side. Primary\n\t * buttons generally map to the left side of the header, and secondary buttons are\n\t * generally on the right side. However, their exact locations are platform-specific.\n\t * For example, in iOS, the primary buttons are on the far left of the header, and\n\t * secondary buttons are on the far right, with the header title centered between them.\n\t * For Android, however, both groups of buttons are on the far right of the header,\n\t * with the header title aligned left.\n\t *\n\t * We recommend always using `primary` and `secondary`, so the buttons correctly map\n\t * to the side familiar to users of each platform. However, in cases where buttons should\n\t * always be on an exact side, both `left` and `right` sides are still available. For\n\t * example, a toggle button for a left side menu should be on the left side; in this case,\n\t * we'd recommend using `side=\"left\"`, so it's always on the left, no matter the platform.\n\t *\n\t * ***Note*** that `ion-nav-buttons` must be immediate descendants of the `ion-view` or\n\t * `ion-nav-bar` element (basically, don't wrap it in another div).\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-nav-bar>\n\t * </ion-nav-bar>\n\t * <ion-nav-view>\n\t *   <ion-view>\n\t *     <ion-nav-buttons side=\"primary\">\n\t *       <button class=\"button\" ng-click=\"doSomething()\">\n\t *         I'm a button on the primary of the navbar!\n\t *       </button>\n\t *     </ion-nav-buttons>\n\t *     <ion-content>\n\t *       Some super content here!\n\t *     </ion-content>\n\t *   </ion-view>\n\t * </ion-nav-view>\n\t * ```\n\t *\n\t * @param {string} side The side to place the buttons in the\n\t * {@link ionic.directive:ionNavBar}. Available sides: `primary`, `secondary`, `left`, and `right`.\n\t */\n\tIonicModule\n\t.directive('ionNavButtons', ['$document', function($document) {\n\t  return {\n\t    require: '^ionNavBar',\n\t    restrict: 'E',\n\t    compile: function(tElement, tAttrs) {\n\t      var side = 'left';\n\t\n\t      if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {\n\t        side = tAttrs.side.toLowerCase();\n\t      }\n\t\n\t      var spanEle = $document[0].createElement('span');\n\t      spanEle.className = side + '-buttons';\n\t      spanEle.innerHTML = tElement.html();\n\t\n\t      var navElementType = side + 'Buttons';\n\t\n\t      tElement.attr('class', 'hide');\n\t      tElement.empty();\n\t\n\t      return {\n\t        pre: function($scope, $element, $attrs, navBarCtrl) {\n\t          // only register the plain HTML, the navBarCtrl takes care of scope/compile/link\n\t\n\t          var parentViewCtrl = $element.parent().data('$ionViewController');\n\t          if (parentViewCtrl) {\n\t            // if the parent is an ion-view, then these are ion-nav-buttons for JUST this ion-view\n\t            parentViewCtrl.navElement(navElementType, spanEle.outerHTML);\n\t\n\t          } else {\n\t            // these are buttons for all views that do not have their own ion-nav-buttons\n\t            navBarCtrl.navElement(navElementType, spanEle.outerHTML);\n\t          }\n\t\n\t          spanEle = null;\n\t        }\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name navDirection\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * The direction which the nav view transition should animate. Available options\n\t * are: `forward`, `back`, `enter`, `exit`, `swap`.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <a nav-direction=\"forward\" href=\"#/home\">Home</a>\n\t * ```\n\t */\n\tIonicModule\n\t.directive('navDirection', ['$ionicViewSwitcher', function($ionicViewSwitcher) {\n\t  return {\n\t    restrict: 'A',\n\t    priority: 1000,\n\t    link: function($scope, $element, $attr) {\n\t      $element.bind('click', function() {\n\t        $ionicViewSwitcher.nextDirection($attr.navDirection);\n\t      });\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionNavTitle\n\t * @module ionic\n\t * @restrict E\n\t * @parent ionNavView\n\t *\n\t * @description\n\t *\n\t * The nav title directive replaces an {@link ionic.directive:ionNavBar} title text with\n\t * custom HTML from within an {@link ionic.directive:ionView} template. This gives each\n\t * view the ability to specify its own custom title element, such as an image or any HTML,\n\t * rather than being text-only. Alternatively, text-only titles can be updated using the\n\t * `view-title` {@link ionic.directive:ionView} attribute.\n\t *\n\t * Note that `ion-nav-title` must be an immediate descendant of the `ion-view` or\n\t * `ion-nav-bar` element (basically don't wrap it in another div).\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-nav-bar>\n\t * </ion-nav-bar>\n\t * <ion-nav-view>\n\t *   <ion-view>\n\t *     <ion-nav-title>\n\t *       <img src=\"logo.svg\">\n\t *     </ion-nav-title>\n\t *     <ion-content>\n\t *       Some super content here!\n\t *     </ion-content>\n\t *   </ion-view>\n\t * </ion-nav-view>\n\t * ```\n\t *\n\t */\n\tIonicModule\n\t.directive('ionNavTitle', ['$document', function($document) {\n\t  return {\n\t    require: '^ionNavBar',\n\t    restrict: 'E',\n\t    compile: function(tElement, tAttrs) {\n\t      var navElementType = 'title';\n\t      var spanEle = $document[0].createElement('span');\n\t      for (var n in tAttrs.$attr) {\n\t        spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);\n\t      }\n\t      spanEle.classList.add('nav-bar-title');\n\t      spanEle.innerHTML = tElement.html();\n\t\n\t      tElement.attr('class', 'hide');\n\t      tElement.empty();\n\t\n\t      return {\n\t        pre: function($scope, $element, $attrs, navBarCtrl) {\n\t          // only register the plain HTML, the navBarCtrl takes care of scope/compile/link\n\t\n\t          var parentViewCtrl = $element.parent().data('$ionViewController');\n\t          if (parentViewCtrl) {\n\t            // if the parent is an ion-view, then these are ion-nav-buttons for JUST this ion-view\n\t            parentViewCtrl.navElement(navElementType, spanEle.outerHTML);\n\t\n\t          } else {\n\t            // these are buttons for all views that do not have their own ion-nav-buttons\n\t            navBarCtrl.navElement(navElementType, spanEle.outerHTML);\n\t          }\n\t\n\t          spanEle = null;\n\t        }\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name navTransition\n\t * @module ionic\n\t * @restrict A\n\t *\n\t * @description\n\t * The transition type which the nav view transition should use when it animates.\n\t * Current, options are `ios`, `android`, and `none`. More options coming soon.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <a nav-transition=\"none\" href=\"#/home\">Home</a>\n\t * ```\n\t */\n\tIonicModule\n\t.directive('navTransition', ['$ionicViewSwitcher', function($ionicViewSwitcher) {\n\t  return {\n\t    restrict: 'A',\n\t    priority: 1000,\n\t    link: function($scope, $element, $attr) {\n\t      $element.bind('click', function() {\n\t        $ionicViewSwitcher.nextTransition($attr.navTransition);\n\t      });\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionNavView\n\t * @module ionic\n\t * @restrict E\n\t * @codepen odqCz\n\t *\n\t * @description\n\t * As a user navigates throughout your app, Ionic is able to keep track of their\n\t * navigation history. By knowing their history, transitions between views\n\t * correctly enter and exit using the platform's transition style. An additional\n\t * benefit to Ionic's navigation system is its ability to manage multiple\n\t * histories. For example, each tab can have it's own navigation history stack.\n\t *\n\t * Ionic uses the AngularUI Router module so app interfaces can be organized\n\t * into various \"states\". Like Angular's core $route service, URLs can be used\n\t * to control the views. However, the AngularUI Router provides a more powerful\n\t * state manager in that states are bound to named, nested, and parallel views,\n\t * allowing more than one template to be rendered on the same page.\n\t * Additionally, each state is not required to be bound to a URL, and data can\n\t * be pushed to each state which allows much flexibility.\n\t *\n\t * The ionNavView directive is used to render templates in your application. Each template\n\t * is part of a state. States are usually mapped to a url, and are defined programatically\n\t * using angular-ui-router (see [their docs](https://github.com/angular-ui/ui-router/wiki),\n\t * and remember to replace ui-view with ion-nav-view in examples).\n\t *\n\t * @usage\n\t * In this example, we will create a navigation view that contains our different states for the app.\n\t *\n\t * To do this, in our markup we use ionNavView top level directive. To display a header bar we use\n\t * the {@link ionic.directive:ionNavBar} directive that updates as we navigate through the\n\t * navigation stack.\n\t *\n\t * Next, we need to setup our states that will be rendered.\n\t *\n\t * ```js\n\t * var app = angular.module('myApp', ['ionic']);\n\t * app.config(function($stateProvider) {\n\t *   $stateProvider\n\t *   .state('index', {\n\t *     url: '/',\n\t *     templateUrl: 'home.html'\n\t *   })\n\t *   .state('music', {\n\t *     url: '/music',\n\t *     templateUrl: 'music.html'\n\t *   });\n\t * });\n\t * ```\n\t * Then on app start, $stateProvider will look at the url, see if it matches the index state,\n\t * and then try to load home.html into the `<ion-nav-view>`.\n\t *\n\t * Pages are loaded by the URLs given. One simple way to create templates in Angular is to put\n\t * them directly into your HTML file and use the `<script type=\"text/ng-template\">` syntax.\n\t * So here is one way to put home.html into our app:\n\t *\n\t * ```html\n\t * <script id=\"home\" type=\"text/ng-template\">\n\t *   <!-- The title of the ion-view will be shown on the navbar -->\n\t *   <ion-view view-title=\"Home\">\n\t *     <ion-content ng-controller=\"HomeCtrl\">\n\t *       <!-- The content of the page -->\n\t *       <a href=\"#/music\">Go to music page!</a>\n\t *     </ion-content>\n\t *   </ion-view>\n\t * </script>\n\t * ```\n\t *\n\t * This is good to do because the template will be cached for very fast loading, instead of\n\t * having to fetch them from the network.\n\t *\n\t * ## Caching\n\t *\n\t * By default, views are cached to improve performance. When a view is navigated away from, its\n\t * element is left in the DOM, and its scope is disconnected from the `$watch` cycle. When\n\t * navigating to a view that is already cached, its scope is then reconnected, and the existing\n\t * element that was left in the DOM becomes the active view. This also allows for the scroll\n\t * position of previous views to be maintained.\n\t *\n\t * Caching can be disabled and enabled in multiple ways. By default, Ionic will cache a maximum of\n\t * 10 views, and not only can this be configured, but apps can also explicitly state which views\n\t * should and should not be cached.\n\t *\n\t * Note that because we are caching these views, *we arent destroying scopes*. Instead, scopes\n\t * are being disconnected from the watch cycle. Because scopes are not being destroyed and\n\t * recreated, controllers are not loading again on a subsequent viewing. If the app/controller\n\t * needs to know when a view has entered or has left, then view events emitted from the\n\t * {@link ionic.directive:ionView} scope, such as `$ionicView.enter`, may be useful.\n\t *\n\t * By default, when navigating back in the history, the \"forward\" views are removed from the cache.\n\t * If you navigate forward to the same view again, it'll create a new DOM element and controller\n\t * instance. Basically, any forward views are reset each time. This can be configured using the\n\t * {@link ionic.provider:$ionicConfigProvider}:\n\t *\n\t * ```js\n\t * $ionicConfigProvider.views.forwardCache(true);\n\t * ```\n\t *\n\t * #### Disable cache globally\n\t *\n\t * The {@link ionic.provider:$ionicConfigProvider} can be used to set the maximum allowable views\n\t * which can be cached, but this can also be use to disable all caching by setting it to 0.\n\t *\n\t * ```js\n\t * $ionicConfigProvider.views.maxCache(0);\n\t * ```\n\t *\n\t * #### Disable cache within state provider\n\t *\n\t * ```js\n\t * $stateProvider.state('myState', {\n\t *    cache: false,\n\t *    url : '/myUrl',\n\t *    templateUrl : 'my-template.html'\n\t * })\n\t * ```\n\t *\n\t * #### Disable cache with an attribute\n\t *\n\t * ```html\n\t * <ion-view cache-view=\"false\" view-title=\"My Title!\">\n\t *   ...\n\t * </ion-view>\n\t * ```\n\t *\n\t *\n\t * ## AngularUI Router\n\t *\n\t * Please visit [AngularUI Router's docs](https://github.com/angular-ui/ui-router/wiki) for\n\t * more info. Below is a great video by the AngularUI Router team that may help to explain\n\t * how it all works:\n\t *\n\t * <iframe width=\"560\" height=\"315\" src=\"//www.youtube.com/embed/dqJRoh8MnBo\"\n\t * frameborder=\"0\" allowfullscreen></iframe>\n\t *\n\t * @param {string=} name A view name. The name should be unique amongst the other views in the\n\t * same state. You can have views of the same name that live in different states. For more\n\t * information, see ui-router's\n\t * [ui-view documentation](http://angular-ui.github.io/ui-router/site/#/api/ui.router.state.directive:ui-view).\n\t */\n\tIonicModule\n\t.directive('ionNavView', [\n\t  '$state',\n\t  '$ionicConfig',\n\tfunction($state, $ionicConfig) {\n\t  // IONIC's fork of Angular UI Router, v0.2.10\n\t  // the navView handles registering views in the history and how to transition between them\n\t  return {\n\t    restrict: 'E',\n\t    terminal: true,\n\t    priority: 2000,\n\t    transclude: true,\n\t    controller: '$ionicNavView',\n\t    compile: function(tElement, tAttrs, transclude) {\n\t\n\t      // a nav view element is a container for numerous views\n\t      tElement.addClass('view-container');\n\t      ionic.DomUtil.cachedAttr(tElement, 'nav-view-transition', $ionicConfig.views.transition());\n\t\n\t      return function($scope, $element, $attr, navViewCtrl) {\n\t        var latestLocals;\n\t\n\t        // Put in the compiled initial view\n\t        transclude($scope, function(clone) {\n\t          $element.append(clone);\n\t        });\n\t\n\t        var viewData = navViewCtrl.init();\n\t\n\t        // listen for $stateChangeSuccess\n\t        $scope.$on('$stateChangeSuccess', function() {\n\t          updateView(false);\n\t        });\n\t        $scope.$on('$viewContentLoading', function() {\n\t          updateView(false);\n\t        });\n\t\n\t        // initial load, ready go\n\t        updateView(true);\n\t\n\t\n\t        function updateView(firstTime) {\n\t          // get the current local according to the $state\n\t          var viewLocals = $state.$current && $state.$current.locals[viewData.name];\n\t\n\t          // do not update THIS nav-view if its is not the container for the given state\n\t          // if the viewLocals are the same as THIS latestLocals, then nothing to do\n\t          if (!viewLocals || (!firstTime && viewLocals === latestLocals)) return;\n\t\n\t          // update the latestLocals\n\t          latestLocals = viewLocals;\n\t          viewData.state = viewLocals.$$state;\n\t\n\t          // register, update and transition to the new view\n\t          navViewCtrl.register(viewLocals);\n\t        }\n\t\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t\n\t.config(['$provide', function($provide) {\n\t  $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\n\t    // drop the default ngClick directive\n\t    $delegate.shift();\n\t    return $delegate;\n\t  }]);\n\t}])\n\t\n\t/**\n\t * @private\n\t */\n\t.factory('$ionicNgClick', ['$parse', function($parse) {\n\t  return function(scope, element, clickExpr) {\n\t    var clickHandler = angular.isFunction(clickExpr) ?\n\t      clickExpr :\n\t      $parse(clickExpr);\n\t\n\t    element.on('click', function(event) {\n\t      scope.$apply(function() {\n\t        clickHandler(scope, {$event: (event)});\n\t      });\n\t    });\n\t\n\t    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n\t    // something else nearby.\n\t    element.onclick = noop;\n\t  };\n\t}])\n\t\n\t.directive('ngClick', ['$ionicNgClick', function($ionicNgClick) {\n\t  return function(scope, element, attr) {\n\t    $ionicNgClick(scope, element, attr.ngClick);\n\t  };\n\t}])\n\t\n\t.directive('ionStopEvent', function() {\n\t  return {\n\t    restrict: 'A',\n\t    link: function(scope, element, attr) {\n\t      element.bind(attr.ionStopEvent, eventStopPropagation);\n\t    }\n\t  };\n\t});\n\tfunction eventStopPropagation(e) {\n\t  e.stopPropagation();\n\t}\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ionPane\n\t * @module ionic\n\t * @restrict E\n\t *\n\t * @description A simple container that fits content, with no side effects.  Adds the 'pane' class to the element.\n\t */\n\tIonicModule\n\t.directive('ionPane', function() {\n\t  return {\n\t    restrict: 'E',\n\t    link: function(scope, element) {\n\t      element.addClass('pane');\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports) {\n\n\t/*\n\t * We don't document the ionPopover directive, we instead document\n\t * the $ionicPopover service\n\t */\n\tIonicModule\n\t.directive('ionPopover', [function() {\n\t  return {\n\t    restrict: 'E',\n\t    transclude: true,\n\t    replace: true,\n\t    controller: [function() {}],\n\t    template: '<div class=\"popover-backdrop\">' +\n\t                '<div class=\"popover-wrapper\" ng-transclude></div>' +\n\t              '</div>'\n\t  };\n\t}]);\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.directive('ionPopoverView', function() {\n\t  return {\n\t    restrict: 'E',\n\t    compile: function(element) {\n\t      element.append(jqLite('<div class=\"popover-arrow\">'));\n\t      element.addClass('popover');\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionRadio\n\t * @module ionic\n\t * @restrict E\n\t * @codepen saoBG\n\t * @description\n\t * The radio directive is no different than the HTML radio input, except it's styled differently.\n\t *\n\t * Radio behaves like [AngularJS radio](http://docs.angularjs.org/api/ng/input/input[radio]).\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-radio ng-model=\"choice\" ng-value=\"'A'\">Choose A</ion-radio>\n\t * <ion-radio ng-model=\"choice\" ng-value=\"'B'\">Choose B</ion-radio>\n\t * <ion-radio ng-model=\"choice\" ng-value=\"'C'\">Choose C</ion-radio>\n\t * ```\n\t *\n\t * @param {string=} name The name of the radio input.\n\t * @param {expression=} value The value of the radio input.\n\t * @param {boolean=} disabled The state of the radio input.\n\t * @param {string=} icon The icon to use when the radio input is selected.\n\t * @param {expression=} ng-value Angular equivalent of the value attribute.\n\t * @param {expression=} ng-model The angular model for the radio input.\n\t * @param {boolean=} ng-disabled Angular equivalent of the disabled attribute.\n\t * @param {expression=} ng-change Triggers given expression when radio input's model changes\n\t */\n\tIonicModule\n\t.directive('ionRadio', function() {\n\t  return {\n\t    restrict: 'E',\n\t    replace: true,\n\t    require: '?ngModel',\n\t    transclude: true,\n\t    template:\n\t      '<label class=\"item item-radio\">' +\n\t        '<input type=\"radio\" name=\"radio-group\">' +\n\t        '<div class=\"radio-content\">' +\n\t          '<div class=\"item-content disable-pointer-events\" ng-transclude></div>' +\n\t          '<i class=\"radio-icon disable-pointer-events icon ion-checkmark\"></i>' +\n\t        '</div>' +\n\t      '</label>',\n\t\n\t    compile: function(element, attr) {\n\t      if (attr.icon) {\n\t        var iconElm = element.find('i');\n\t        iconElm.removeClass('ion-checkmark').addClass(attr.icon);\n\t      }\n\t\n\t      var input = element.find('input');\n\t      forEach({\n\t          'name': attr.name,\n\t          'value': attr.value,\n\t          'disabled': attr.disabled,\n\t          'ng-value': attr.ngValue,\n\t          'ng-model': attr.ngModel,\n\t          'ng-disabled': attr.ngDisabled,\n\t          'ng-change': attr.ngChange,\n\t          'ng-required': attr.ngRequired,\n\t          'required': attr.required\n\t      }, function(value, name) {\n\t        if (isDefined(value)) {\n\t            input.attr(name, value);\n\t          }\n\t      });\n\t\n\t      return function(scope, element, attr) {\n\t        scope.getValue = function() {\n\t          return scope.ngValue || attr.value;\n\t        };\n\t      };\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ionRefresher\n\t * @module ionic\n\t * @restrict E\n\t * @parent ionic.directive:ionContent, ionic.directive:ionScroll\n\t * @description\n\t * Allows you to add pull-to-refresh to a scrollView.\n\t *\n\t * Place it as the first child of your {@link ionic.directive:ionContent} or\n\t * {@link ionic.directive:ionScroll} element.\n\t *\n\t * When refreshing is complete, $broadcast the 'scroll.refreshComplete' event\n\t * from your controller.\n\t *\n\t * @usage\n\t *\n\t * ```html\n\t * <ion-content ng-controller=\"MyController\">\n\t *   <ion-refresher\n\t *     pulling-text=\"Pull to refresh...\"\n\t *     on-refresh=\"doRefresh()\">\n\t *   </ion-refresher>\n\t *   <ion-list>\n\t *     <ion-item ng-repeat=\"item in items\"></ion-item>\n\t *   </ion-list>\n\t * </ion-content>\n\t * ```\n\t * ```js\n\t * angular.module('testApp', ['ionic'])\n\t * .controller('MyController', function($scope, $http) {\n\t *   $scope.items = [1,2,3];\n\t *   $scope.doRefresh = function() {\n\t *     $http.get('/new-items')\n\t *      .success(function(newItems) {\n\t *        $scope.items = newItems;\n\t *      })\n\t *      .finally(function() {\n\t *        // Stop the ion-refresher from spinning\n\t *        $scope.$broadcast('scroll.refreshComplete');\n\t *      });\n\t *   };\n\t * });\n\t * ```\n\t *\n\t * @param {expression=} on-refresh Called when the user pulls down enough and lets go\n\t * of the refresher.\n\t * @param {expression=} on-pulling Called when the user starts to pull down\n\t * on the refresher.\n\t * @param {string=} pulling-text The text to display while the user is pulling down.\n\t * @param {string=} pulling-icon The icon to display while the user is pulling down.\n\t * Default: 'ion-android-arrow-down'.\n\t * @param {string=} spinner The {@link ionic.directive:ionSpinner} icon to display\n\t * after user lets go of the refresher. The SVG {@link ionic.directive:ionSpinner}\n\t * is now the default, replacing rotating font icons. Set to `none` to disable both the\n\t * spinner and the icon.\n\t * @param {string=} refreshing-icon The font icon to display after user lets go of the\n\t * refresher. This is depreicated in favor of the SVG {@link ionic.directive:ionSpinner}.\n\t * @param {boolean=} disable-pulling-rotation Disables the rotation animation of the pulling\n\t * icon when it reaches its activated threshold. To be used with a custom `pulling-icon`.\n\t *\n\t */\n\tIonicModule\n\t.directive('ionRefresher', [function() {\n\t  return {\n\t    restrict: 'E',\n\t    replace: true,\n\t    require: ['?^$ionicScroll', 'ionRefresher'],\n\t    controller: '$ionicRefresher',\n\t    template:\n\t    '<div class=\"scroll-refresher invisible\" collection-repeat-ignore>' +\n\t      '<div class=\"ionic-refresher-content\" ' +\n\t      'ng-class=\"{\\'ionic-refresher-with-text\\': pullingText || refreshingText}\">' +\n\t        '<div class=\"icon-pulling\" ng-class=\"{\\'pulling-rotation-disabled\\':disablePullingRotation}\">' +\n\t          '<i class=\"icon {{pullingIcon}}\"></i>' +\n\t        '</div>' +\n\t        '<div class=\"text-pulling\" ng-bind-html=\"pullingText\"></div>' +\n\t        '<div class=\"icon-refreshing\">' +\n\t          '<ion-spinner ng-if=\"showSpinner\" icon=\"{{spinner}}\"></ion-spinner>' +\n\t          '<i ng-if=\"showIcon\" class=\"icon {{refreshingIcon}}\"></i>' +\n\t        '</div>' +\n\t        '<div class=\"text-refreshing\" ng-bind-html=\"refreshingText\"></div>' +\n\t      '</div>' +\n\t    '</div>',\n\t    link: function($scope, $element, $attrs, ctrls) {\n\t\n\t      // JS Scrolling uses the scroll controller\n\t      var scrollCtrl = ctrls[0],\n\t          refresherCtrl = ctrls[1];\n\t      if (!scrollCtrl || scrollCtrl.isNative()) {\n\t        // Kick off native scrolling\n\t        refresherCtrl.init();\n\t      } else {\n\t        $element[0].classList.add('js-scrolling');\n\t        scrollCtrl._setRefresher(\n\t          $scope,\n\t          $element[0],\n\t          refresherCtrl.getRefresherDomMethods()\n\t        );\n\t\n\t        $scope.$on('scroll.refreshComplete', function() {\n\t          $scope.$evalAsync(function() {\n\t            scrollCtrl.scrollView.finishPullToRefresh();\n\t          });\n\t        });\n\t      }\n\t\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @ngdoc directive\r\n\t * @name ionScroll\r\n\t * @module ionic\r\n\t * @delegate ionic.service:$ionicScrollDelegate\r\n\t * @codepen mwFuh\r\n\t * @restrict E\r\n\t *\r\n\t * @description\r\n\t * Creates a scrollable container for all content inside.\r\n\t *\r\n\t * @usage\r\n\t *\r\n\t * Basic usage:\r\n\t *\r\n\t * ```html\r\n\t * <ion-scroll zooming=\"true\" direction=\"xy\" style=\"width: 500px; height: 500px\">\r\n\t *   <div style=\"width: 5000px; height: 5000px; background: url('https://upload.wikimedia.org/wikipedia/commons/a/ad/Europe_geological_map-en.jpg') repeat\"></div>\r\n\t *  </ion-scroll>\r\n\t * ```\r\n\t *\r\n\t * Note that it's important to set the height of the scroll box as well as the height of the inner\r\n\t * content to enable scrolling. This makes it possible to have full control over scrollable areas.\r\n\t *\r\n\t * If you'd just like to have a center content scrolling area, use {@link ionic.directive:ionContent} instead.\r\n\t *\r\n\t * @param {string=} delegate-handle The handle used to identify this scrollView\r\n\t * with {@link ionic.service:$ionicScrollDelegate}.\r\n\t * @param {string=} direction Which way to scroll. 'x' or 'y' or 'xy'. Default 'y'.\r\n\t * @param {boolean=} locking Whether to lock scrolling in one direction at a time. Useful to set to false when zoomed in or scrolling in two directions. Default true.\r\n\t * @param {boolean=} paging Whether to scroll with paging.\r\n\t * @param {expression=} on-refresh Called on pull-to-refresh, triggered by an {@link ionic.directive:ionRefresher}.\r\n\t * @param {expression=} on-scroll Called whenever the user scrolls.\r\n\t * @param {boolean=} scrollbar-x Whether to show the horizontal scrollbar. Default true.\r\n\t * @param {boolean=} scrollbar-y Whether to show the vertical scrollbar. Default true.\r\n\t * @param {boolean=} zooming Whether to support pinch-to-zoom\r\n\t * @param {integer=} min-zoom The smallest zoom amount allowed (default is 0.5)\r\n\t * @param {integer=} max-zoom The largest zoom amount allowed (default is 3)\r\n\t * @param {boolean=} has-bouncing Whether to allow scrolling to bounce past the edges\r\n\t * of the content.  Defaults to true on iOS, false on Android.\r\n\t */\r\n\tIonicModule\r\n\t.directive('ionScroll', [\r\n\t  '$timeout',\r\n\t  '$controller',\r\n\t  '$ionicBind',\r\n\t  '$ionicConfig',\r\n\tfunction($timeout, $controller, $ionicBind, $ionicConfig) {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    scope: true,\r\n\t    controller: function() {},\r\n\t    compile: function(element, attr) {\r\n\t      element.addClass('scroll-view ionic-scroll');\r\n\t\r\n\t      //We cannot transclude here because it breaks element.data() inheritance on compile\r\n\t      var innerElement = jqLite('<div class=\"scroll\"></div>');\r\n\t      innerElement.append(element.contents());\r\n\t      element.append(innerElement);\r\n\t\r\n\t      var nativeScrolling = attr.overflowScroll !== \"false\" && (attr.overflowScroll === \"true\" || !$ionicConfig.scrolling.jsScrolling());\r\n\t\r\n\t      return { pre: prelink };\r\n\t      function prelink($scope, $element, $attr) {\r\n\t        $ionicBind($scope, $attr, {\r\n\t          direction: '@',\r\n\t          paging: '@',\r\n\t          $onScroll: '&onScroll',\r\n\t          scroll: '@',\r\n\t          scrollbarX: '@',\r\n\t          scrollbarY: '@',\r\n\t          zooming: '@',\r\n\t          minZoom: '@',\r\n\t          maxZoom: '@'\r\n\t        });\r\n\t        $scope.direction = $scope.direction || 'y';\r\n\t\r\n\t        if (isDefined($attr.padding)) {\r\n\t          $scope.$watch($attr.padding, function(newVal) {\r\n\t            innerElement.toggleClass('padding', !!newVal);\r\n\t          });\r\n\t        }\r\n\t        if ($scope.$eval($scope.paging) === true) {\r\n\t          innerElement.addClass('scroll-paging');\r\n\t        }\r\n\t\r\n\t        if (!$scope.direction) { $scope.direction = 'y'; }\r\n\t        var isPaging = $scope.$eval($scope.paging) === true;\r\n\t\r\n\t        if (nativeScrolling) {\r\n\t          $element.addClass('overflow-scroll');\r\n\t        }\r\n\t\r\n\t        $element.addClass('scroll-' + $scope.direction);\r\n\t\r\n\t        var scrollViewOptions = {\r\n\t          el: $element[0],\r\n\t          delegateHandle: $attr.delegateHandle,\r\n\t          locking: ($attr.locking || 'true') === 'true',\r\n\t          bouncing: $scope.$eval($attr.hasBouncing),\r\n\t          paging: isPaging,\r\n\t          scrollbarX: $scope.$eval($scope.scrollbarX) !== false,\r\n\t          scrollbarY: $scope.$eval($scope.scrollbarY) !== false,\r\n\t          scrollingX: $scope.direction.indexOf('x') >= 0,\r\n\t          scrollingY: $scope.direction.indexOf('y') >= 0,\r\n\t          zooming: $scope.$eval($scope.zooming) === true,\r\n\t          maxZoom: $scope.$eval($scope.maxZoom) || 3,\r\n\t          minZoom: $scope.$eval($scope.minZoom) || 0.5,\r\n\t          preventDefault: true,\r\n\t          nativeScrolling: nativeScrolling\r\n\t        };\r\n\t\r\n\t        if (isPaging) {\r\n\t          scrollViewOptions.speedMultiplier = 0.8;\r\n\t          scrollViewOptions.bouncing = false;\r\n\t        }\r\n\t\r\n\t        $controller('$ionicScroll', {\r\n\t          $scope: $scope,\r\n\t          scrollViewOptions: scrollViewOptions\r\n\t        });\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t}]);\r\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t * @ngdoc directive\r\n\t * @name ionSideMenuContent\r\n\t * @module ionic\r\n\t * @restrict E\r\n\t * @parent ionic.directive:ionSideMenus\r\n\t *\r\n\t * @description\r\n\t * A container for the main visible content, sibling to one or more\r\n\t * {@link ionic.directive:ionSideMenu} directives.\r\n\t *\r\n\t * @usage\r\n\t * ```html\r\n\t * <ion-side-menu-content\r\n\t *   edge-drag-threshold=\"true\"\r\n\t *   drag-content=\"true\">\r\n\t * </ion-side-menu-content>\r\n\t * ```\r\n\t * For a complete side menu example, see the\r\n\t * {@link ionic.directive:ionSideMenus} documentation.\r\n\t *\r\n\t * @param {boolean=} drag-content Whether the content can be dragged. Default true.\r\n\t * @param {boolean|number=} edge-drag-threshold Whether the content drag can only start if it is below a certain threshold distance from the edge of the screen.  Default false. Accepts three types of values:\r\n\t   *  - If a non-zero number is given, that many pixels is used as the maximum allowed distance from the edge that starts dragging the side menu.\r\n\t   *  - If true is given, the default number of pixels (25) is used as the maximum allowed distance.\r\n\t   *  - If false or 0 is given, the edge drag threshold is disabled, and dragging from anywhere on the content is allowed.\r\n\t *\r\n\t */\r\n\tIonicModule\r\n\t.directive('ionSideMenuContent', [\r\n\t  '$timeout',\r\n\t  '$ionicGesture',\r\n\t  '$window',\r\n\tfunction($timeout, $ionicGesture, $window) {\r\n\t\r\n\t  return {\r\n\t    restrict: 'EA', //DEPRECATED 'A'\r\n\t    require: '^ionSideMenus',\r\n\t    scope: true,\r\n\t    compile: function(element, attr) {\r\n\t      element.addClass('menu-content pane');\r\n\t\r\n\t      return { pre: prelink };\r\n\t      function prelink($scope, $element, $attr, sideMenuCtrl) {\r\n\t        var startCoord = null;\r\n\t        var primaryScrollAxis = null;\r\n\t\r\n\t        if (isDefined(attr.dragContent)) {\r\n\t          $scope.$watch(attr.dragContent, function(value) {\r\n\t            sideMenuCtrl.canDragContent(value);\r\n\t          });\r\n\t        } else {\r\n\t          sideMenuCtrl.canDragContent(true);\r\n\t        }\r\n\t\r\n\t        if (isDefined(attr.edgeDragThreshold)) {\r\n\t          $scope.$watch(attr.edgeDragThreshold, function(value) {\r\n\t            sideMenuCtrl.edgeDragThreshold(value);\r\n\t          });\r\n\t        }\r\n\t\r\n\t        // Listen for taps on the content to close the menu\r\n\t        function onContentTap(gestureEvt) {\r\n\t          if (sideMenuCtrl.getOpenAmount() !== 0) {\r\n\t            sideMenuCtrl.close();\r\n\t            gestureEvt.gesture.srcEvent.preventDefault();\r\n\t            startCoord = null;\r\n\t            primaryScrollAxis = null;\r\n\t          } else if (!startCoord) {\r\n\t            startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);\r\n\t          }\r\n\t        }\r\n\t\r\n\t        function onDragX(e) {\r\n\t          if (!sideMenuCtrl.isDraggableTarget(e)) return;\r\n\t\r\n\t          if (getPrimaryScrollAxis(e) == 'x') {\r\n\t            sideMenuCtrl._handleDrag(e);\r\n\t            e.gesture.srcEvent.preventDefault();\r\n\t          }\r\n\t        }\r\n\t\r\n\t        function onDragY(e) {\r\n\t          if (getPrimaryScrollAxis(e) == 'x') {\r\n\t            e.gesture.srcEvent.preventDefault();\r\n\t          }\r\n\t        }\r\n\t\r\n\t        function onDragRelease(e) {\r\n\t          sideMenuCtrl._endDrag(e);\r\n\t          startCoord = null;\r\n\t          primaryScrollAxis = null;\r\n\t        }\r\n\t\r\n\t        function getPrimaryScrollAxis(gestureEvt) {\r\n\t          // gets whether the user is primarily scrolling on the X or Y\r\n\t          // If a majority of the drag has been on the Y since the start of\r\n\t          // the drag, but the X has moved a little bit, it's still a Y drag\r\n\t\r\n\t          if (primaryScrollAxis) {\r\n\t            // we already figured out which way they're scrolling\r\n\t            return primaryScrollAxis;\r\n\t          }\r\n\t\r\n\t          if (gestureEvt && gestureEvt.gesture) {\r\n\t\r\n\t            if (!startCoord) {\r\n\t              // get the starting point\r\n\t              startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);\r\n\t\r\n\t            } else {\r\n\t              // we already have a starting point, figure out which direction they're going\r\n\t              var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);\r\n\t\r\n\t              var xDistance = Math.abs(endCoord.x - startCoord.x);\r\n\t              var yDistance = Math.abs(endCoord.y - startCoord.y);\r\n\t\r\n\t              var scrollAxis = (xDistance < yDistance ? 'y' : 'x');\r\n\t\r\n\t              if (Math.max(xDistance, yDistance) > 30) {\r\n\t                // ok, we pretty much know which way they're going\r\n\t                // let's lock it in\r\n\t                primaryScrollAxis = scrollAxis;\r\n\t              }\r\n\t\r\n\t              return scrollAxis;\r\n\t            }\r\n\t          }\r\n\t          return 'y';\r\n\t        }\r\n\t\r\n\t        var content = {\r\n\t          element: element[0],\r\n\t          onDrag: function() {},\r\n\t          endDrag: function() {},\r\n\t          setCanScroll: function(canScroll) {\r\n\t            var c = $element[0].querySelector('.scroll');\r\n\t\r\n\t            if (!c) {\r\n\t              return;\r\n\t            }\r\n\t\r\n\t            var content = angular.element(c.parentElement);\r\n\t            if (!content) {\r\n\t              return;\r\n\t            }\r\n\t\r\n\t            // freeze our scroll container if we have one\r\n\t            var scrollScope = content.scope();\r\n\t            scrollScope.scrollCtrl && scrollScope.scrollCtrl.freezeScrollShut(!canScroll);\r\n\t          },\r\n\t          getTranslateX: function() {\r\n\t            return $scope.sideMenuContentTranslateX || 0;\r\n\t          },\r\n\t          setTranslateX: ionic.animationFrameThrottle(function(amount) {\r\n\t            var xTransform = content.offsetX + amount;\r\n\t            $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + xTransform + 'px,0,0)';\r\n\t            $timeout(function() {\r\n\t              $scope.sideMenuContentTranslateX = amount;\r\n\t            });\r\n\t          }),\r\n\t          setMarginLeft: ionic.animationFrameThrottle(function(amount) {\r\n\t            if (amount) {\r\n\t              amount = parseInt(amount, 10);\r\n\t              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amount + 'px,0,0)';\r\n\t              $element[0].style.width = ($window.innerWidth - amount) + 'px';\r\n\t              content.offsetX = amount;\r\n\t            } else {\r\n\t              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n\t              $element[0].style.width = '';\r\n\t              content.offsetX = 0;\r\n\t            }\r\n\t          }),\r\n\t          setMarginRight: ionic.animationFrameThrottle(function(amount) {\r\n\t            if (amount) {\r\n\t              amount = parseInt(amount, 10);\r\n\t              $element[0].style.width = ($window.innerWidth - amount) + 'px';\r\n\t              content.offsetX = amount;\r\n\t            } else {\r\n\t              $element[0].style.width = '';\r\n\t              content.offsetX = 0;\r\n\t            }\r\n\t            // reset incase left gets grabby\r\n\t            $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n\t          }),\r\n\t          setMarginLeftAndRight: ionic.animationFrameThrottle(function(amountLeft, amountRight) {\r\n\t            amountLeft = amountLeft && parseInt(amountLeft, 10) || 0;\r\n\t            amountRight = amountRight && parseInt(amountRight, 10) || 0;\r\n\t\r\n\t            var amount = amountLeft + amountRight;\r\n\t\r\n\t            if (amount > 0) {\r\n\t              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amountLeft + 'px,0,0)';\r\n\t              $element[0].style.width = ($window.innerWidth - amount) + 'px';\r\n\t              content.offsetX = amountLeft;\r\n\t            } else {\r\n\t              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n\t              $element[0].style.width = '';\r\n\t              content.offsetX = 0;\r\n\t            }\r\n\t            // reset incase left gets grabby\r\n\t            //$element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n\t          }),\r\n\t          enableAnimation: function() {\r\n\t            $scope.animationEnabled = true;\r\n\t            $element[0].classList.add('menu-animated');\r\n\t          },\r\n\t          disableAnimation: function() {\r\n\t            $scope.animationEnabled = false;\r\n\t            $element[0].classList.remove('menu-animated');\r\n\t          },\r\n\t          offsetX: 0\r\n\t        };\r\n\t\r\n\t        sideMenuCtrl.setContent(content);\r\n\t\r\n\t        // add gesture handlers\r\n\t        var gestureOpts = { stop_browser_behavior: false };\r\n\t        gestureOpts.prevent_default_directions = ['left', 'right'];\r\n\t        var contentTapGesture = $ionicGesture.on('tap', onContentTap, $element, gestureOpts);\r\n\t        var dragRightGesture = $ionicGesture.on('dragright', onDragX, $element, gestureOpts);\r\n\t        var dragLeftGesture = $ionicGesture.on('dragleft', onDragX, $element, gestureOpts);\r\n\t        var dragUpGesture = $ionicGesture.on('dragup', onDragY, $element, gestureOpts);\r\n\t        var dragDownGesture = $ionicGesture.on('dragdown', onDragY, $element, gestureOpts);\r\n\t        var releaseGesture = $ionicGesture.on('release', onDragRelease, $element, gestureOpts);\r\n\t\r\n\t        // Cleanup\r\n\t        $scope.$on('$destroy', function() {\r\n\t          if (content) {\r\n\t            content.element = null;\r\n\t            content = null;\r\n\t          }\r\n\t          $ionicGesture.off(dragLeftGesture, 'dragleft', onDragX);\r\n\t          $ionicGesture.off(dragRightGesture, 'dragright', onDragX);\r\n\t          $ionicGesture.off(dragUpGesture, 'dragup', onDragY);\r\n\t          $ionicGesture.off(dragDownGesture, 'dragdown', onDragY);\r\n\t          $ionicGesture.off(releaseGesture, 'release', onDragRelease);\r\n\t          $ionicGesture.off(contentTapGesture, 'tap', onContentTap);\r\n\t        });\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t}]);\r\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionSideMenu\n\t * @module ionic\n\t * @restrict E\n\t * @parent ionic.directive:ionSideMenus\n\t *\n\t * @description\n\t * A container for a side menu, sibling to an {@link ionic.directive:ionSideMenuContent} directive.\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-side-menu\n\t *   side=\"left\"\n\t *   width=\"myWidthValue + 20\"\n\t *   is-enabled=\"shouldLeftSideMenuBeEnabled()\">\n\t * </ion-side-menu>\n\t * ```\n\t * For a complete side menu example, see the\n\t * {@link ionic.directive:ionSideMenus} documentation.\n\t *\n\t * @param {string} side Which side the side menu is currently on.  Allowed values: 'left' or 'right'.\n\t * @param {boolean=} is-enabled Whether this side menu is enabled.\n\t * @param {number=} width How many pixels wide the side menu should be.  Defaults to 275.\n\t */\n\tIonicModule\n\t.directive('ionSideMenu', function() {\n\t  return {\n\t    restrict: 'E',\n\t    require: '^ionSideMenus',\n\t    scope: true,\n\t    compile: function(element, attr) {\n\t      angular.isUndefined(attr.isEnabled) && attr.$set('isEnabled', 'true');\n\t      angular.isUndefined(attr.width) && attr.$set('width', '275');\n\t\n\t      element.addClass('menu menu-' + attr.side);\n\t\n\t      return function($scope, $element, $attr, sideMenuCtrl) {\n\t        $scope.side = $attr.side || 'left';\n\t\n\t        var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({\n\t          width: attr.width,\n\t          el: $element[0],\n\t          isEnabled: true\n\t        });\n\t\n\t        $scope.$watch($attr.width, function(val) {\n\t          var numberVal = +val;\n\t          if (numberVal && numberVal == val) {\n\t            sideMenu.setWidth(+val);\n\t          }\n\t        });\n\t        $scope.$watch($attr.isEnabled, function(val) {\n\t          sideMenu.setIsEnabled(!!val);\n\t        });\n\t      };\n\t    }\n\t  };\n\t});\n\t\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t\n\t/**\n\t * @ngdoc directive\n\t * @name ionSideMenus\n\t * @module ionic\n\t * @delegate ionic.service:$ionicSideMenuDelegate\n\t * @restrict E\n\t *\n\t * @description\n\t * A container element for side menu(s) and the main content. Allows the left and/or right side menu\n\t * to be toggled by dragging the main content area side to side.\n\t *\n\t * To automatically close an opened menu, you can add the {@link ionic.directive:menuClose} attribute\n\t * directive. The `menu-close` attribute is usually added to links and buttons within\n\t * `ion-side-menu-content`, so that when the element is clicked, the opened side menu will\n\t * automatically close.\n\t *\n\t * \"Burger Icon\" toggles can be added to the header with the {@link ionic.directive:menuToggle}\n\t * attribute directive. Clicking the toggle will open and close the side menu like the `menu-close`\n\t * directive. The side menu will automatically hide on child pages, but can be overridden with the\n\t * enable-menu-with-back-views attribute mentioned below.\n\t *\n\t * By default, side menus are hidden underneath their side menu content and can be opened by swiping\n\t * the content left or right or by toggling a button to show the side menu. Additionally, by adding the\n\t * {@link ionic.directive:exposeAsideWhen} attribute directive to an\n\t * {@link ionic.directive:ionSideMenu} element directive, a side menu can be given instructions about\n\t * \"when\" the menu should be exposed (always viewable).\n\t *\n\t * ![Side Menu](http://ionicframework.com.s3.amazonaws.com/docs/controllers/sidemenu.gif)\n\t *\n\t * For more information on side menus, check out:\n\t *\n\t * - {@link ionic.directive:ionSideMenuContent}\n\t * - {@link ionic.directive:ionSideMenu}\n\t * - {@link ionic.directive:menuToggle}\n\t * - {@link ionic.directive:menuClose}\n\t * - {@link ionic.directive:exposeAsideWhen}\n\t *\n\t * @usage\n\t * To use side menus, add an `<ion-side-menus>` parent element. This will encompass all pages that have a\n\t * side menu, and have at least 2 child elements: 1 `<ion-side-menu-content>` for the center content,\n\t * and one or more `<ion-side-menu>` directives for each side menu(left/right) that you wish to place.\n\t *\n\t * ```html\n\t * <ion-side-menus>\n\t *   <!-- Left menu -->\n\t *   <ion-side-menu side=\"left\">\n\t *   </ion-side-menu>\n\t *\n\t *   <ion-side-menu-content>\n\t *   <!-- Main content, usually <ion-nav-view> -->\n\t *   </ion-side-menu-content>\n\t *\n\t *   <!-- Right menu -->\n\t *   <ion-side-menu side=\"right\">\n\t *   </ion-side-menu>\n\t *\n\t * </ion-side-menus>\n\t * ```\n\t * ```js\n\t * function ContentController($scope, $ionicSideMenuDelegate) {\n\t *   $scope.toggleLeft = function() {\n\t *     $ionicSideMenuDelegate.toggleLeft();\n\t *   };\n\t * }\n\t * ```\n\t *\n\t * @param {bool=} enable-menu-with-back-views Determines whether the side menu is enabled when the\n\t * back button is showing. When set to `false`, any {@link ionic.directive:menuToggle} will be hidden,\n\t * and the user cannot swipe to open the menu. When going back to the root page of the side menu (the\n\t * page without a back button visible), then any menuToggle buttons will show again, and menus will be\n\t * enabled again.\n\t * @param {string=} delegate-handle The handle used to identify this side menu\n\t * with {@link ionic.service:$ionicSideMenuDelegate}.\n\t *\n\t */\n\t.directive('ionSideMenus', ['$ionicBody', function($ionicBody) {\n\t  return {\n\t    restrict: 'ECA',\n\t    controller: '$ionicSideMenus',\n\t    compile: function(element, attr) {\n\t      attr.$set('class', (attr['class'] || '') + ' view');\n\t\n\t      return { pre: prelink };\n\t      function prelink($scope, $element, $attrs, ctrl) {\n\t\n\t        ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews));\n\t\n\t        $scope.$on('$ionicExposeAside', function(evt, isAsideExposed) {\n\t          if (!$scope.$exposeAside) $scope.$exposeAside = {};\n\t          $scope.$exposeAside.active = isAsideExposed;\n\t          $ionicBody.enableClass(isAsideExposed, 'aside-open');\n\t        });\n\t\n\t        $scope.$on('$ionicView.beforeEnter', function(ev, d) {\n\t          if (d.historyId) {\n\t            $scope.$activeHistoryId = d.historyId;\n\t          }\n\t        });\n\t\n\t        $scope.$on('$destroy', function() {\n\t          $ionicBody.removeClass('menu-open', 'aside-open');\n\t        });\n\t\n\t      }\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 79 */\n/***/ function(module, exports) {\n\n\t\r\n\t/**\r\n\t * @ngdoc directive\r\n\t * @name ionSlideBox\r\n\t * @module ionic\r\n\t * @deprecated will be removed in the next Ionic release in favor of the new ion-slides component.\r\n\t * Don't depend on the internal behavior of this widget.\r\n\t * @delegate ionic.service:$ionicSlideBoxDelegate\r\n\t * @restrict E\r\n\t * @description\r\n\t * The Slide Box is a multi-page container where each page can be swiped or dragged between:\r\n\t *\r\n\t * ![SlideBox](http://ionicframework.com.s3.amazonaws.com/docs/controllers/slideBox.gif)\r\n\t *\r\n\t * @usage\r\n\t * ```html\r\n\t * <ion-slide-box on-slide-changed=\"slideHasChanged($index)\">\r\n\t *   <ion-slide>\r\n\t *     <div class=\"box blue\"><h1>BLUE</h1></div>\r\n\t *   </ion-slide>\r\n\t *   <ion-slide>\r\n\t *     <div class=\"box yellow\"><h1>YELLOW</h1></div>\r\n\t *   </ion-slide>\r\n\t *   <ion-slide>\r\n\t *     <div class=\"box pink\"><h1>PINK</h1></div>\r\n\t *   </ion-slide>\r\n\t * </ion-slide-box>\r\n\t * ```\r\n\t *\r\n\t * @param {string=} delegate-handle The handle used to identify this slideBox\r\n\t * with {@link ionic.service:$ionicSlideBoxDelegate}.\r\n\t * @param {boolean=} does-continue Whether the slide box should loop.\r\n\t * @param {boolean=} auto-play Whether the slide box should automatically slide. Default true if does-continue is true.\r\n\t * @param {number=} slide-interval How many milliseconds to wait to change slides (if does-continue is true). Defaults to 4000.\r\n\t * @param {boolean=} show-pager Whether a pager should be shown for this slide box. Accepts expressions via `show-pager=\"{{shouldShow()}}\"`. Defaults to true.\r\n\t * @param {expression=} pager-click Expression to call when a pager is clicked (if show-pager is true). Is passed the 'index' variable.\r\n\t * @param {expression=} on-slide-changed Expression called whenever the slide is changed.  Is passed an '$index' variable.\r\n\t * @param {expression=} active-slide Model to bind the current slide index to.\r\n\t */\r\n\tIonicModule\r\n\t.directive('ionSlideBox', [\r\n\t  '$animate',\r\n\t  '$timeout',\r\n\t  '$compile',\r\n\t  '$ionicSlideBoxDelegate',\r\n\t  '$ionicHistory',\r\n\t  '$ionicScrollDelegate',\r\n\tfunction($animate, $timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    replace: true,\r\n\t    transclude: true,\r\n\t    scope: {\r\n\t      autoPlay: '=',\r\n\t      doesContinue: '@',\r\n\t      slideInterval: '@',\r\n\t      showPager: '@',\r\n\t      pagerClick: '&',\r\n\t      disableScroll: '@',\r\n\t      onSlideChanged: '&',\r\n\t      activeSlide: '=?',\r\n\t      bounce: '@'\r\n\t    },\r\n\t    controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {\r\n\t      var _this = this;\r\n\t\r\n\t      var continuous = $scope.$eval($scope.doesContinue) === true;\r\n\t      var bouncing = ($scope.$eval($scope.bounce) !== false); //Default to true\r\n\t      var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;\r\n\t      var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4000 : 0;\r\n\t\r\n\t      var slider = new ionic.views.Slider({\r\n\t        el: $element[0],\r\n\t        auto: slideInterval,\r\n\t        continuous: continuous,\r\n\t        startSlide: $scope.activeSlide,\r\n\t        bouncing: bouncing,\r\n\t        slidesChanged: function() {\r\n\t          $scope.currentSlide = slider.currentIndex();\r\n\t\r\n\t          // Try to trigger a digest\r\n\t          $timeout(function() {});\r\n\t        },\r\n\t        callback: function(slideIndex) {\r\n\t          $scope.currentSlide = slideIndex;\r\n\t          $scope.onSlideChanged({ index: $scope.currentSlide, $index: $scope.currentSlide});\r\n\t          $scope.$parent.$broadcast('slideBox.slideChanged', slideIndex);\r\n\t          $scope.activeSlide = slideIndex;\r\n\t          // Try to trigger a digest\r\n\t          $timeout(function() {});\r\n\t        },\r\n\t        onDrag: function() {\r\n\t          freezeAllScrolls(true);\r\n\t        },\r\n\t        onDragEnd: function() {\r\n\t          freezeAllScrolls(false);\r\n\t        }\r\n\t      });\r\n\t\r\n\t      function freezeAllScrolls(shouldFreeze) {\r\n\t        if (shouldFreeze && !_this.isScrollFreeze) {\r\n\t          $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);\r\n\t\r\n\t        } else if (!shouldFreeze && _this.isScrollFreeze) {\r\n\t          $ionicScrollDelegate.freezeAllScrolls(false);\r\n\t        }\r\n\t        _this.isScrollFreeze = shouldFreeze;\r\n\t      }\r\n\t\r\n\t      slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);\r\n\t\r\n\t      $scope.$watch('activeSlide', function(nv) {\r\n\t        if (isDefined(nv)) {\r\n\t          slider.slide(nv);\r\n\t        }\r\n\t      });\r\n\t\r\n\t      $scope.$on('slideBox.nextSlide', function() {\r\n\t        slider.next();\r\n\t      });\r\n\t\r\n\t      $scope.$on('slideBox.prevSlide', function() {\r\n\t        slider.prev();\r\n\t      });\r\n\t\r\n\t      $scope.$on('slideBox.setSlide', function(e, index) {\r\n\t        slider.slide(index);\r\n\t      });\r\n\t\r\n\t      //Exposed for testing\r\n\t      this.__slider = slider;\r\n\t\r\n\t      var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(\r\n\t        slider, $attrs.delegateHandle, function() {\r\n\t          return $ionicHistory.isActiveScope($scope);\r\n\t        }\r\n\t      );\r\n\t      $scope.$on('$destroy', function() {\r\n\t        deregisterInstance();\r\n\t        slider.kill();\r\n\t      });\r\n\t\r\n\t      this.slidesCount = function() {\r\n\t        return slider.slidesCount();\r\n\t      };\r\n\t\r\n\t      this.onPagerClick = function(index) {\r\n\t        $scope.pagerClick({index: index});\r\n\t      };\r\n\t\r\n\t      $timeout(function() {\r\n\t        slider.load();\r\n\t      });\r\n\t    }],\r\n\t    template: '<div class=\"slider\">' +\r\n\t      '<div class=\"slider-slides\" ng-transclude>' +\r\n\t      '</div>' +\r\n\t    '</div>',\r\n\t\r\n\t    link: function($scope, $element, $attr) {\r\n\t      // Disable ngAnimate for slidebox and its children\r\n\t      $animate.enabled(false, $element);\r\n\t\r\n\t      // if showPager is undefined, show the pager\r\n\t      if (!isDefined($attr.showPager)) {\r\n\t        $scope.showPager = true;\r\n\t        getPager().toggleClass('hide', !true);\r\n\t      }\r\n\t\r\n\t      $attr.$observe('showPager', function(show) {\r\n\t        if (show === undefined) return;\r\n\t        show = $scope.$eval(show);\r\n\t        getPager().toggleClass('hide', !show);\r\n\t      });\r\n\t\r\n\t      var pager;\r\n\t      function getPager() {\r\n\t        if (!pager) {\r\n\t          var childScope = $scope.$new();\r\n\t          pager = jqLite('<ion-pager></ion-pager>');\r\n\t          $element.append(pager);\r\n\t          pager = $compile(pager)(childScope);\r\n\t        }\r\n\t        return pager;\r\n\t      }\r\n\t    }\r\n\t  };\r\n\t}])\r\n\t.directive('ionSlide', function() {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    require: '?^ionSlideBox',\r\n\t    compile: function(element) {\r\n\t      element.addClass('slider-slide');\r\n\t    }\r\n\t  };\r\n\t})\r\n\t\r\n\t.directive('ionPager', function() {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    replace: true,\r\n\t    require: '^ionSlideBox',\r\n\t    template: '<div class=\"slider-pager\"><span class=\"slider-pager-page\" ng-repeat=\"slide in numSlides() track by $index\" ng-class=\"{active: $index == currentSlide}\" ng-click=\"pagerClick($index)\"><i class=\"icon ion-record\"></i></span></div>',\r\n\t    link: function($scope, $element, $attr, slideBox) {\r\n\t      var selectPage = function(index) {\r\n\t        var children = $element[0].children;\r\n\t        var length = children.length;\r\n\t        for (var i = 0; i < length; i++) {\r\n\t          if (i == index) {\r\n\t            children[i].classList.add('active');\r\n\t          } else {\r\n\t            children[i].classList.remove('active');\r\n\t          }\r\n\t        }\r\n\t      };\r\n\t\r\n\t      $scope.pagerClick = function(index) {\r\n\t        slideBox.onPagerClick(index);\r\n\t      };\r\n\t\r\n\t      $scope.numSlides = function() {\r\n\t        return new Array(slideBox.slidesCount());\r\n\t      };\r\n\t\r\n\t      $scope.$watch('currentSlide', function(v) {\r\n\t        selectPage(v);\r\n\t      });\r\n\t    }\r\n\t  };\r\n\t\r\n\t});\r\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports) {\n\n\t\r\n\t/**\r\n\t * @ngdoc directive\r\n\t * @name ionSlides\r\n\t * @module ionic\r\n\t * @delegate ionic.service:$ionicSlideBoxDelegate\r\n\t * @restrict E\r\n\t * @description\r\n\t * The Slides component is a powerful multi-page container where each page can be swiped or dragged between.\r\n\t *\r\n\t * Note: this is a new version of the Ionic Slide Box based on the [Swiper](http://www.idangero.us/swiper/#.Vmc1J-ODFBc) widget from\r\n\t * [idangerous](http://www.idangero.us/).\r\n\t *\r\n\t * ![SlideBox](http://ionicframework.com.s3.amazonaws.com/docs/controllers/slideBox.gif)\r\n\t *\r\n\t * @usage\r\n\t * ```html\r\n\t * <ion-slides on-slide-changed=\"slideHasChanged($index)\">\r\n\t *   <ion-slide-page>\r\n\t *     <div class=\"box blue\"><h1>BLUE</h1></div>\r\n\t *   </ion-slide-page>\r\n\t *   <ion-slide-page>\r\n\t *     <div class=\"box yellow\"><h1>YELLOW</h1></div>\r\n\t *   </ion-slide-page>\r\n\t *   <ion-slide-page>\r\n\t *     <div class=\"box pink\"><h1>PINK</h1></div>\r\n\t *   </ion-slide-page>\r\n\t * </ion-slides>\r\n\t * ```\r\n\t *\r\n\t * @param {string=} delegate-handle The handle used to identify this slideBox\r\n\t * with {@link ionic.service:$ionicSlideBoxDelegate}.\r\n\t * @param {object=} options to pass to the widget. See the full ist here: [http://www.idangero.us/swiper/api/](http://www.idangero.us/swiper/api/)\r\n\t */\r\n\tIonicModule\r\n\t.directive('ionSlides', [\r\n\t  '$animate',\r\n\t  '$timeout',\r\n\t  '$compile',\r\n\tfunction($animate, $timeout, $compile) {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    transclude: true,\r\n\t    scope: {\r\n\t      options: '=',\r\n\t      slider: '='\r\n\t    },\r\n\t    template: '<div class=\"swiper-container\">' +\r\n\t      '<div class=\"swiper-wrapper\" ng-transclude>' +\r\n\t      '</div>' +\r\n\t        '<div ng-hide=\"!showPager\" class=\"swiper-pagination\"></div>' +\r\n\t      '</div>',\r\n\t    controller: ['$scope', '$element', function($scope, $element) {\r\n\t      var _this = this;\r\n\t\r\n\t      this.update = function() {\r\n\t        $timeout(function() {\r\n\t          if (!_this.__slider) {\r\n\t            return;\r\n\t          }\r\n\t\r\n\t          _this.__slider.update();\r\n\t          if (_this._options.loop) {\r\n\t            _this.__slider.createLoop();\r\n\t          }\r\n\t\r\n\t          // Don't allow pager to show with > 10 slides\r\n\t          if (_this.__slider.slides.length > 10) {\r\n\t            $scope.showPager = false;\r\n\t          }\r\n\t        });\r\n\t      };\r\n\t\r\n\t      this.rapidUpdate = ionic.debounce(function() {\r\n\t        _this.update();\r\n\t      }, 50);\r\n\t\r\n\t      this.getSlider = function() {\r\n\t        return _this.__slider;\r\n\t      };\r\n\t\r\n\t      var options = $scope.options || {};\r\n\t\r\n\t      var newOptions = angular.extend({\r\n\t        pagination: '.swiper-pagination',\r\n\t        paginationClickable: true,\r\n\t        lazyLoading: true,\r\n\t        preloadImages: false\r\n\t      }, options);\r\n\t\r\n\t      this._options = newOptions;\r\n\t\r\n\t      $timeout(function() {\r\n\t        var slider = new ionic.views.Swiper($element.children()[0], newOptions, $scope, $compile);\r\n\t\r\n\t        _this.__slider = slider;\r\n\t        $scope.slider = _this.__slider;\r\n\t\r\n\t        $scope.$on('$destroy', function() {\r\n\t          slider.destroy();\r\n\t        });\r\n\t      });\r\n\t\r\n\t    }],\r\n\t\r\n\t\r\n\t    link: function($scope) {\r\n\t      $scope.showPager = true;\r\n\t      // Disable ngAnimate for slidebox and its children\r\n\t      //$animate.enabled(false, $element);\r\n\t    }\r\n\t  };\r\n\t}])\r\n\t.directive('ionSlidePage', [function() {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    require: '?^ionSlides',\r\n\t    transclude: true,\r\n\t    replace: true,\r\n\t    template: '<div class=\"swiper-slide\" ng-transclude></div>',\r\n\t    link: function($scope, $element, $attr, ionSlidesCtrl) {\r\n\t      ionSlidesCtrl.rapidUpdate();\r\n\t    }\r\n\t  };\r\n\t}]);\r\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports) {\n\n\t/**\n\t* @ngdoc directive\n\t* @name ionSpinner\n\t* @module ionic\n\t* @restrict E\n\t *\n\t * @description\n\t * The `ionSpinner` directive provides a variety of animated spinners.\n\t * Spinners enables you to give your users feedback that the app is\n\t * processing/thinking/waiting/chillin' out, or whatever you'd like it to indicate.\n\t * By default, the {@link ionic.directive:ionRefresher} feature uses this spinner, rather\n\t * than rotating font icons (previously included in [ionicons](http://ionicons.com/)).\n\t * While font icons are great for simple or stationary graphics, they're not suited to\n\t * provide great animations, which is why Ionic uses SVG instead.\n\t *\n\t * Ionic offers ten spinners out of the box, and by default, it will use the appropriate spinner\n\t * for the platform on which it's running. Under the hood, the `ionSpinner` directive dynamically\n\t * builds the required SVG element, which allows Ionic to provide all ten of the animated SVGs\n\t * within 3KB.\n\t *\n\t * <style>\n\t * .spinner-table {\n\t *   max-width: 280px;\n\t * }\n\t * .spinner-table tbody > tr > th, .spinner-table tbody > tr > td {\n\t *   vertical-align: middle;\n\t *   width: 42px;\n\t *   height: 42px;\n\t * }\n\t * .spinner {\n\t *   stroke: #444;\n\t *   fill: #444; }\n\t *   .spinner svg {\n\t *     width: 28px;\n\t *     height: 28px; }\n\t *   .spinner.spinner-inverse {\n\t *     stroke: #fff;\n\t *     fill: #fff; }\n\t *\n\t * .spinner-android {\n\t *   stroke: #4b8bf4; }\n\t *\n\t * .spinner-ios, .spinner-ios-small {\n\t *   stroke: #69717d; }\n\t *\n\t * .spinner-spiral .stop1 {\n\t *   stop-color: #fff;\n\t *   stop-opacity: 0; }\n\t * .spinner-spiral.spinner-inverse .stop1 {\n\t *   stop-color: #000; }\n\t * .spinner-spiral.spinner-inverse .stop2 {\n\t *   stop-color: #fff; }\n\t * </style>\n\t *\n\t * <script src=\"http://code.ionicframework.com/nightly/js/ionic.bundle.min.js\"></script>\n\t * <table class=\"table spinner-table\" ng-app=\"ionic\">\n\t *  <tr>\n\t *    <th>\n\t *      <code>android</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"android\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>ios</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"ios\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>ios-small</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"ios-small\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>bubbles</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"bubbles\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>circles</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"circles\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>crescent</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"crescent\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>dots</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"dots\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>lines</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"lines\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>ripple</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"ripple\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t *  <tr>\n\t *    <th>\n\t *      <code>spiral</code>\n\t *    </th>\n\t *    <td>\n\t *      <ion-spinner icon=\"spiral\"></ion-spinner>\n\t *    </td>\n\t *  </tr>\n\t * </table>\n\t *\n\t * Each spinner uses SVG with SMIL animations, however, the Android spinner also uses JavaScript\n\t * so it also works on Android 4.0-4.3. Additionally, each spinner can be styled with CSS,\n\t * and scaled to any size.\n\t *\n\t *\n\t * @usage\n\t * The following code would use the default spinner for the platform it's running from. If it's neither\n\t * iOS or Android, it'll default to use `ios`.\n\t *\n\t * ```html\n\t * <ion-spinner></ion-spinner>\n\t * ```\n\t *\n\t * By setting the `icon` attribute, you can specify which spinner to use, no matter what\n\t * the platform is.\n\t *\n\t * ```html\n\t * <ion-spinner icon=\"spiral\"></ion-spinner>\n\t * ```\n\t *\n\t * ## Spinner Colors\n\t * Like with most of Ionic's other components, spinners can also be styled using\n\t * Ionic's standard color naming convention. For example:\n\t *\n\t * ```html\n\t * <ion-spinner class=\"spinner-energized\"></ion-spinner>\n\t * ```\n\t *\n\t *\n\t * ## Styling SVG with CSS\n\t * One cool thing about SVG is its ability to be styled with CSS! Some of the properties\n\t * have different names, for example, SVG uses the term `stroke` instead of `border`, and\n\t * `fill` instead of `background-color`.\n\t *\n\t * ```css\n\t * .spinner svg {\n\t *   width: 28px;\n\t *   height: 28px;\n\t *   stroke: #444;\n\t *   fill: #444;\n\t * }\n\t * ```\n\t *\n\t*/\n\tIonicModule\n\t.directive('ionSpinner', function() {\n\t  return {\n\t    restrict: 'E',\n\t    controller: '$ionicSpinner',\n\t    link: function($scope, $element, $attrs, ctrl) {\n\t      var spinnerName = ctrl.init();\n\t      $element.addClass('spinner spinner-' + spinnerName);\n\t\n\t      $element.on('$destroy', function onDestroy() {\n\t        ctrl.stop();\n\t      });\n\t    }\n\t  };\n\t});\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionTab\n\t * @module ionic\n\t * @restrict E\n\t * @parent ionic.directive:ionTabs\n\t *\n\t * @description\n\t * Contains a tab's content.  The content only exists while the given tab is selected.\n\t *\n\t * Each ionTab has its own view history.\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-tab\n\t *   title=\"Tab!\"\n\t *   icon=\"my-icon\"\n\t *   href=\"#/tab/tab-link\"\n\t *   on-select=\"onTabSelected()\"\n\t *   on-deselect=\"onTabDeselected()\">\n\t * </ion-tab>\n\t * ```\n\t * For a complete, working tab bar example, see the {@link ionic.directive:ionTabs} documentation.\n\t *\n\t * @param {string} title The title of the tab.\n\t * @param {string=} href The link that this tab will navigate to when tapped.\n\t * @param {string=} icon The icon of the tab. If given, this will become the default for icon-on and icon-off.\n\t * @param {string=} icon-on The icon of the tab while it is selected.\n\t * @param {string=} icon-off The icon of the tab while it is not selected.\n\t * @param {expression=} badge The badge to put on this tab (usually a number).\n\t * @param {expression=} badge-style The style of badge to put on this tab (eg: badge-positive).\n\t * @param {expression=} on-select Called when this tab is selected.\n\t * @param {expression=} on-deselect Called when this tab is deselected.\n\t * @param {expression=} ng-click By default, the tab will be selected on click. If ngClick is set, it will not.  You can explicitly switch tabs using {@link ionic.service:$ionicTabsDelegate#select $ionicTabsDelegate.select()}.\n\t * @param {expression=} hidden Whether the tab is to be hidden or not.\n\t * @param {expression=} disabled Whether the tab is to be disabled or not.\n\t */\n\tIonicModule\n\t.directive('ionTab', [\n\t  '$compile',\n\t  '$ionicConfig',\n\t  '$ionicBind',\n\t  '$ionicViewSwitcher',\n\tfunction($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {\n\t\n\t  //Returns ' key=\"value\"' if value exists\n\t  function attrStr(k, v) {\n\t    return isDefined(v) ? ' ' + k + '=\"' + v + '\"' : '';\n\t  }\n\t  return {\n\t    restrict: 'E',\n\t    require: ['^ionTabs', 'ionTab'],\n\t    controller: '$ionicTab',\n\t    scope: true,\n\t    compile: function(element, attr) {\n\t\n\t      //We create the tabNavTemplate in the compile phase so that the\n\t      //attributes we pass down won't be interpolated yet - we want\n\t      //to pass down the 'raw' versions of the attributes\n\t      var tabNavTemplate = '<ion-tab-nav' +\n\t        attrStr('ng-click', attr.ngClick) +\n\t        attrStr('title', attr.title) +\n\t        attrStr('icon', attr.icon) +\n\t        attrStr('icon-on', attr.iconOn) +\n\t        attrStr('icon-off', attr.iconOff) +\n\t        attrStr('badge', attr.badge) +\n\t        attrStr('badge-style', attr.badgeStyle) +\n\t        attrStr('hidden', attr.hidden) +\n\t        attrStr('disabled', attr.disabled) +\n\t        attrStr('class', attr['class']) +\n\t        '></ion-tab-nav>';\n\t\n\t      //Remove the contents of the element so we can compile them later, if tab is selected\n\t      var tabContentEle = document.createElement('div');\n\t      for (var x = 0; x < element[0].children.length; x++) {\n\t        tabContentEle.appendChild(element[0].children[x].cloneNode(true));\n\t      }\n\t      var childElementCount = tabContentEle.childElementCount;\n\t      element.empty();\n\t\n\t      var navViewName, isNavView;\n\t      if (childElementCount) {\n\t        if (tabContentEle.children[0].tagName === 'ION-NAV-VIEW') {\n\t          // get the name if it's a nav-view\n\t          navViewName = tabContentEle.children[0].getAttribute('name');\n\t          tabContentEle.children[0].classList.add('view-container');\n\t          isNavView = true;\n\t        }\n\t        if (childElementCount === 1) {\n\t          // make the 1 child element the primary tab content container\n\t          tabContentEle = tabContentEle.children[0];\n\t        }\n\t        if (!isNavView) tabContentEle.classList.add('pane');\n\t        tabContentEle.classList.add('tab-content');\n\t      }\n\t\n\t      return function link($scope, $element, $attr, ctrls) {\n\t        var childScope;\n\t        var childElement;\n\t        var tabsCtrl = ctrls[0];\n\t        var tabCtrl = ctrls[1];\n\t        var isTabContentAttached = false;\n\t        $scope.$tabSelected = false;\n\t\n\t        $ionicBind($scope, $attr, {\n\t          onSelect: '&',\n\t          onDeselect: '&',\n\t          title: '@',\n\t          uiSref: '@',\n\t          href: '@'\n\t        });\n\t\n\t        tabsCtrl.add($scope);\n\t        $scope.$on('$destroy', function() {\n\t          if (!$scope.$tabsDestroy) {\n\t            // if the containing ionTabs directive is being destroyed\n\t            // then don't bother going through the controllers remove\n\t            // method, since remove will reset the active tab as each tab\n\t            // is being destroyed, causing unnecessary view loads and transitions\n\t            tabsCtrl.remove($scope);\n\t          }\n\t          tabNavElement.isolateScope().$destroy();\n\t          tabNavElement.remove();\n\t          tabNavElement = tabContentEle = childElement = null;\n\t        });\n\t\n\t        //Remove title attribute so browser-tooltip does not apear\n\t        $element[0].removeAttribute('title');\n\t\n\t        if (navViewName) {\n\t          tabCtrl.navViewName = $scope.navViewName = navViewName;\n\t        }\n\t        $scope.$on('$stateChangeSuccess', selectIfMatchesState);\n\t        selectIfMatchesState();\n\t        function selectIfMatchesState() {\n\t          if (tabCtrl.tabMatchesState()) {\n\t            tabsCtrl.select($scope, false);\n\t          }\n\t        }\n\t\n\t        var tabNavElement = jqLite(tabNavTemplate);\n\t        tabNavElement.data('$ionTabsController', tabsCtrl);\n\t        tabNavElement.data('$ionTabController', tabCtrl);\n\t        tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));\n\t\n\t\n\t        function tabSelected(isSelected) {\n\t          if (isSelected && childElementCount) {\n\t            // this tab is being selected\n\t\n\t            // check if the tab is already in the DOM\n\t            // only do this if the tab has child elements\n\t            if (!isTabContentAttached) {\n\t              // tab should be selected and is NOT in the DOM\n\t              // create a new scope and append it\n\t              childScope = $scope.$new();\n\t              childElement = jqLite(tabContentEle);\n\t              $ionicViewSwitcher.viewEleIsActive(childElement, true);\n\t              tabsCtrl.$element.append(childElement);\n\t              $compile(childElement)(childScope);\n\t              isTabContentAttached = true;\n\t            }\n\t\n\t            // remove the hide class so the tabs content shows up\n\t            $ionicViewSwitcher.viewEleIsActive(childElement, true);\n\t\n\t          } else if (isTabContentAttached && childElement) {\n\t            // this tab should NOT be selected, and it is already in the DOM\n\t\n\t            if ($ionicConfig.views.maxCache() > 0) {\n\t              // keep the tabs in the DOM, only css hide it\n\t              $ionicViewSwitcher.viewEleIsActive(childElement, false);\n\t\n\t            } else {\n\t              // do not keep tabs in the DOM\n\t              destroyTab();\n\t            }\n\t\n\t          }\n\t        }\n\t\n\t        function destroyTab() {\n\t          childScope && childScope.$destroy();\n\t          isTabContentAttached && childElement && childElement.remove();\n\t          tabContentEle.innerHTML = '';\n\t          isTabContentAttached = childScope = childElement = null;\n\t        }\n\t\n\t        $scope.$watch('$tabSelected', tabSelected);\n\t\n\t        $scope.$on('$ionicView.afterEnter', function() {\n\t          $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);\n\t        });\n\t\n\t        $scope.$on('$ionicView.clearCache', function() {\n\t          if (!$scope.$tabSelected) {\n\t            destroyTab();\n\t          }\n\t        });\n\t\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 83 */\n/***/ function(module, exports) {\n\n\tIonicModule\n\t.directive('ionTabNav', [function() {\n\t  return {\n\t    restrict: 'E',\n\t    replace: true,\n\t    require: ['^ionTabs', '^ionTab'],\n\t    template:\n\t    '<a ng-class=\"{\\'tab-item-active\\': isTabActive(), \\'has-badge\\':badge, \\'tab-hidden\\':isHidden()}\" ' +\n\t      ' ng-disabled=\"disabled()\" class=\"tab-item\">' +\n\t      '<span class=\"badge {{badgeStyle}}\" ng-if=\"badge\">{{badge}}</span>' +\n\t      '<i class=\"icon {{getIconOn()}}\" ng-if=\"getIconOn() && isTabActive()\"></i>' +\n\t      '<i class=\"icon {{getIconOff()}}\" ng-if=\"getIconOff() && !isTabActive()\"></i>' +\n\t      '<span class=\"tab-title\" ng-bind-html=\"title\"></span>' +\n\t    '</a>',\n\t    scope: {\n\t      title: '@',\n\t      icon: '@',\n\t      iconOn: '@',\n\t      iconOff: '@',\n\t      badge: '=',\n\t      hidden: '@',\n\t      disabled: '&',\n\t      badgeStyle: '@',\n\t      'class': '@'\n\t    },\n\t    link: function($scope, $element, $attrs, ctrls) {\n\t      var tabsCtrl = ctrls[0],\n\t        tabCtrl = ctrls[1];\n\t\n\t      //Remove title attribute so browser-tooltip does not apear\n\t      $element[0].removeAttribute('title');\n\t\n\t      $scope.selectTab = function(e) {\n\t        e.preventDefault();\n\t        tabsCtrl.select(tabCtrl.$scope, true);\n\t      };\n\t      if (!$attrs.ngClick) {\n\t        $element.on('click', function(event) {\n\t          $scope.$apply(function() {\n\t            $scope.selectTab(event);\n\t          });\n\t        });\n\t      }\n\t\n\t      $scope.isHidden = function() {\n\t        if ($attrs.hidden === 'true' || $attrs.hidden === true) return true;\n\t        return false;\n\t      };\n\t\n\t      $scope.getIconOn = function() {\n\t        return $scope.iconOn || $scope.icon;\n\t      };\n\t      $scope.getIconOff = function() {\n\t        return $scope.iconOff || $scope.icon;\n\t      };\n\t\n\t      $scope.isTabActive = function() {\n\t        return tabsCtrl.selectedTab() === tabCtrl.$scope;\n\t      };\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 84 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionTabs\n\t * @module ionic\n\t * @delegate ionic.service:$ionicTabsDelegate\n\t * @restrict E\n\t * @codepen odqCz\n\t *\n\t * @description\n\t * Powers a multi-tabbed interface with a Tab Bar and a set of \"pages\" that can be tabbed\n\t * through.\n\t *\n\t * Assign any [tabs class](/docs/components#tabs) to the element to define\n\t * its look and feel.\n\t *\n\t * For iOS, tabs will appear at the bottom of the screen. For Android, tabs will be at the top\n\t * of the screen, below the nav-bar. This follows each OS's design specification, but can be\n\t * configured with the {@link ionic.provider:$ionicConfigProvider}.\n\t *\n\t * See the {@link ionic.directive:ionTab} directive's documentation for more details on\n\t * individual tabs.\n\t *\n\t * Note: do not place ion-tabs inside of an ion-content element; it has been known to cause a\n\t * certain CSS bug.\n\t *\n\t * @usage\n\t * ```html\n\t * <ion-tabs class=\"tabs-positive tabs-icon-top\">\n\t *\n\t *   <ion-tab title=\"Home\" icon-on=\"ion-ios-filing\" icon-off=\"ion-ios-filing-outline\">\n\t *     <!-- Tab 1 content -->\n\t *   </ion-tab>\n\t *\n\t *   <ion-tab title=\"About\" icon-on=\"ion-ios-clock\" icon-off=\"ion-ios-clock-outline\">\n\t *     <!-- Tab 2 content -->\n\t *   </ion-tab>\n\t *\n\t *   <ion-tab title=\"Settings\" icon-on=\"ion-ios-gear\" icon-off=\"ion-ios-gear-outline\">\n\t *     <!-- Tab 3 content -->\n\t *   </ion-tab>\n\t *\n\t * </ion-tabs>\n\t * ```\n\t *\n\t * @param {string=} delegate-handle The handle used to identify these tabs\n\t * with {@link ionic.service:$ionicTabsDelegate}.\n\t */\n\t\n\tIonicModule\n\t.directive('ionTabs', [\n\t  '$ionicTabsDelegate',\n\t  '$ionicConfig',\n\tfunction($ionicTabsDelegate, $ionicConfig) {\n\t  return {\n\t    restrict: 'E',\n\t    scope: true,\n\t    controller: '$ionicTabs',\n\t    compile: function(tElement) {\n\t      //We cannot use regular transclude here because it breaks element.data()\n\t      //inheritance on compile\n\t      var innerElement = jqLite('<div class=\"tab-nav tabs\">');\n\t      innerElement.append(tElement.contents());\n\t\n\t      tElement.append(innerElement)\n\t              .addClass('tabs-' + $ionicConfig.tabs.position() + ' tabs-' + $ionicConfig.tabs.style());\n\t\n\t      return { pre: prelink, post: postLink };\n\t      function prelink($scope, $element, $attr, tabsCtrl) {\n\t        var deregisterInstance = $ionicTabsDelegate._registerInstance(\n\t          tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope\n\t        );\n\t\n\t        tabsCtrl.$scope = $scope;\n\t        tabsCtrl.$element = $element;\n\t        tabsCtrl.$tabsElement = jqLite($element[0].querySelector('.tabs'));\n\t\n\t        $scope.$watch(function() { return $element[0].className; }, function(value) {\n\t          var isTabsTop = value.indexOf('tabs-top') !== -1;\n\t          var isHidden = value.indexOf('tabs-item-hide') !== -1;\n\t          $scope.$hasTabs = !isTabsTop && !isHidden;\n\t          $scope.$hasTabsTop = isTabsTop && !isHidden;\n\t          $scope.$emit('$ionicTabs.top', $scope.$hasTabsTop);\n\t        });\n\t\n\t        function emitLifecycleEvent(ev, data) {\n\t          ev.stopPropagation();\n\t          var previousSelectedTab = tabsCtrl.previousSelectedTab();\n\t          if (previousSelectedTab) {\n\t            previousSelectedTab.$broadcast(ev.name.replace('NavView', 'Tabs'), data);\n\t          }\n\t        }\n\t\n\t        $scope.$on('$ionicNavView.beforeLeave', emitLifecycleEvent);\n\t        $scope.$on('$ionicNavView.afterLeave', emitLifecycleEvent);\n\t        $scope.$on('$ionicNavView.leave', emitLifecycleEvent);\n\t\n\t        $scope.$on('$destroy', function() {\n\t          // variable to inform child tabs that they're all being blown away\n\t          // used so that while destorying an individual tab, each one\n\t          // doesn't select the next tab as the active one, which causes unnecessary\n\t          // loading of tab views when each will eventually all go away anyway\n\t          $scope.$tabsDestroy = true;\n\t          deregisterInstance();\n\t          tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null;\n\t          delete $scope.$hasTabs;\n\t          delete $scope.$hasTabsTop;\n\t        });\n\t      }\n\t\n\t      function postLink($scope, $element, $attr, tabsCtrl) {\n\t        if (!tabsCtrl.selectedTab()) {\n\t          // all the tabs have been added\n\t          // but one hasn't been selected yet\n\t          tabsCtrl.select(0);\n\t        }\n\t      }\n\t    }\n\t  };\n\t}]);\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\n\t/**\r\n\t* @ngdoc directive\r\n\t* @name ionTitle\r\n\t* @module ionic\r\n\t* @restrict E\r\n\t*\r\n\t* Used for titles in header and nav bars. New in 1.2\r\n\t*\r\n\t* Identical to <div class=\"title\"> but with future compatibility for Ionic 2\r\n\t*\r\n\t* @usage\r\n\t*\r\n\t* ```html\r\n\t* <ion-nav-bar>\r\n\t*   <ion-title>Hello</ion-title>\r\n\t* <ion-nav-bar>\r\n\t* ```\r\n\t*/\r\n\tIonicModule\r\n\t.directive('ionTitle', [function() {\r\n\t  return {\r\n\t    restrict: 'E',\r\n\t    compile: function(element) {\r\n\t      element.addClass('title');\r\n\t    }\r\n\t  };\r\n\t}]);\r\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionToggle\n\t * @module ionic\n\t * @codepen tfAzj\n\t * @restrict E\n\t *\n\t * @description\n\t * A toggle is an animated switch which binds a given model to a boolean.\n\t *\n\t * Allows dragging of the switch's nub.\n\t *\n\t * The toggle behaves like any [AngularJS checkbox](http://docs.angularjs.org/api/ng/input/input[checkbox]) otherwise.\n\t *\n\t * @param toggle-class {string=} Sets the CSS class on the inner `label.toggle` element created by the directive.\n\t *\n\t * @usage\n\t * Below is an example of a toggle directive which is wired up to the `airplaneMode` model\n\t * and has the `toggle-calm` CSS class assigned to the inner element.\n\t *\n\t * ```html\n\t * <ion-toggle ng-model=\"airplaneMode\" toggle-class=\"toggle-calm\">Airplane Mode</ion-toggle>\n\t * ```\n\t */\n\tIonicModule\n\t.directive('ionToggle', [\n\t  '$timeout',\n\t  '$ionicConfig',\n\tfunction($timeout, $ionicConfig) {\n\t\n\t  return {\n\t    restrict: 'E',\n\t    replace: true,\n\t    require: '?ngModel',\n\t    transclude: true,\n\t    template:\n\t      '<div class=\"item item-toggle\">' +\n\t        '<div ng-transclude></div>' +\n\t        '<label class=\"toggle\">' +\n\t          '<input type=\"checkbox\">' +\n\t          '<div class=\"track\">' +\n\t            '<div class=\"handle\"></div>' +\n\t          '</div>' +\n\t        '</label>' +\n\t      '</div>',\n\t\n\t    compile: function(element, attr) {\n\t      var input = element.find('input');\n\t      forEach({\n\t        'name': attr.name,\n\t        'ng-value': attr.ngValue,\n\t        'ng-model': attr.ngModel,\n\t        'ng-checked': attr.ngChecked,\n\t        'ng-disabled': attr.ngDisabled,\n\t        'ng-true-value': attr.ngTrueValue,\n\t        'ng-false-value': attr.ngFalseValue,\n\t        'ng-change': attr.ngChange,\n\t        'ng-required': attr.ngRequired,\n\t        'required': attr.required\n\t      }, function(value, name) {\n\t        if (isDefined(value)) {\n\t          input.attr(name, value);\n\t        }\n\t      });\n\t\n\t      if (attr.toggleClass) {\n\t        element[0].getElementsByTagName('label')[0].classList.add(attr.toggleClass);\n\t      }\n\t\n\t      element.addClass('toggle-' + $ionicConfig.form.toggle());\n\t\n\t      return function($scope, $element) {\n\t        var el = $element[0].getElementsByTagName('label')[0];\n\t        var checkbox = el.children[0];\n\t        var track = el.children[1];\n\t        var handle = track.children[0];\n\t\n\t        var ngModelController = jqLite(checkbox).controller('ngModel');\n\t\n\t        $scope.toggle = new ionic.views.Toggle({\n\t          el: el,\n\t          track: track,\n\t          checkbox: checkbox,\n\t          handle: handle,\n\t          onChange: function() {\n\t            if (ngModelController) {\n\t              ngModelController.$setViewValue(checkbox.checked);\n\t              $scope.$apply();\n\t            }\n\t          }\n\t        });\n\t\n\t        $scope.$on('$destroy', function() {\n\t          $scope.toggle.destroy();\n\t        });\n\t      };\n\t    }\n\t\n\t  };\n\t}]);\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports) {\n\n\t/**\n\t * @ngdoc directive\n\t * @name ionView\n\t * @module ionic\n\t * @restrict E\n\t * @parent ionNavView\n\t *\n\t * @description\n\t * A container for view content and any navigational and header bar information. When a view\n\t * enters and exits its parent {@link ionic.directive:ionNavView}, the view also emits view\n\t * information, such as its title, whether the back button should be displayed or not, whether the\n\t * corresponding {@link ionic.directive:ionNavBar} should be displayed or not, which transition the view\n\t * should use to animate, and which direction to animate.\n\t *\n\t * *Views are cached to improve performance.* When a view is navigated away from, its element is\n\t * left in the DOM, and its scope is disconnected from the `$watch` cycle. When navigating to a\n\t * view that is already cached, its scope is reconnected, and the existing element, which was\n\t * left in the DOM, becomes active again. This can be disabled, or the maximum number of cached\n\t * views changed in {@link ionic.provider:$ionicConfigProvider}, in the view's `$state` configuration, or\n\t * as an attribute on the view itself (see below).\n\t *\n\t * @usage\n\t * Below is an example where our page will load with a {@link ionic.directive:ionNavBar} containing\n\t * \"My Page\" as the title.\n\t *\n\t * ```html\n\t * <ion-nav-bar></ion-nav-bar>\n\t * <ion-nav-view>\n\t *   <ion-view view-title=\"My Page\">\n\t *     <ion-content>\n\t *       Hello!\n\t *     </ion-content>\n\t *   </ion-view>\n\t * </ion-nav-view>\n\t * ```\n\t *\n\t * ## View LifeCycle and Events\n\t *\n\t * Views can be cached, which means ***controllers normally only load once***, which may\n\t * affect your controller logic. To know when a view has entered or left, events\n\t * have been added that are emitted from the view's scope. These events also\n\t * contain data about the view, such as the title and whether the back button should\n\t * show. Also contained is transition data, such as the transition type and\n\t * direction that will be or was used.\n\t *\n\t * <table class=\"table\">\n\t *  <tr>\n\t *   <td><code>$ionicView.loaded</code></td>\n\t *   <td>The view has loaded. This event only happens once per\n\t * view being created and added to the DOM. If a view leaves but is cached,\n\t * then this event will not fire again on a subsequent viewing. The loaded event\n\t * is good place to put your setup code for the view; however, it is not the\n\t * recommended event to listen to when a view becomes active.</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td><code>$ionicView.enter</code></td>\n\t *   <td>The view has fully entered and is now the active view.\n\t * This event will fire, whether it was the first load or a cached view.</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td><code>$ionicView.leave</code></td>\n\t *   <td>The view has finished leaving and is no longer the\n\t * active view. This event will fire, whether it is cached or destroyed.</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td><code>$ionicView.beforeEnter</code></td>\n\t *   <td>The view is about to enter and become the active view.</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td><code>$ionicView.beforeLeave</code></td>\n\t *   <td>The view is about to leave and no longer be the active view.</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td><code>$ionicView.afterEnter</code></td>\n\t *   <td>The view has fully entered and is now the active view.</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td><code>$ionicView.afterLeave</code></td>\n\t *   <td>The view has finished leaving and is no longer the active view.</td>\n\t *  </tr>\n\t *  <tr>\n\t *   <td><code>$ionicView.unloaded</code></td>\n\t *   <td>The view's controller has been destroyed and its element has been\n\t * removed from the DOM.</td>\n\t *  </tr>\n\t * </table>\n\t *\n\t * ## Caching\n\t *\n\t * Caching can be disabled and enabled in multiple ways. By default, Ionic will\n\t * cache a maximum of 10 views. You can optionally choose to disable caching at\n\t * either an individual view basis, or by global configuration. Please see the\n\t * _Caching_ section in {@link ionic.directive:ionNavView} for more info.\n\t *\n\t * @param {string=} view-title A text-only title to display on the parent {@link ionic.directive:ionNavBar}.\n\t * For an HTML title, such as an image, see {@link ionic.directive:ionNavTitle} instead.\n\t * @param {boolean=} cache-view If this view should be allowed to be cached or not.\n\t * Please see the _Caching_ section in {@link ionic.directive:ionNavView} for\n\t * more info. Default `true`\n\t * @param {boolean=} can-swipe-back If this view should be allowed to use the swipe to go back gesture or not.\n\t * This does not enable the swipe to go back feature if it is not available for the platform it's running\n\t * from, or there isn't a previous view. Default `true`\n\t * @param {boolean=} hide-back-button Whether to hide the back button on the parent\n\t * {@link ionic.directive:ionNavBar} by default.\n\t * @param {boolean=} hide-nav-bar Whether to hide the parent\n\t * {@link ionic.directive:ionNavBar} by default.\n\t */\n\tIonicModule\n\t.directive('ionView', function() {\n\t  return {\n\t    restrict: 'EA',\n\t    priority: 1000,\n\t    controller: '$ionicView',\n\t    compile: function(tElement) {\n\t      tElement.addClass('pane');\n\t      tElement[0].removeAttribute('title');\n\t      return function link($scope, $element, $attrs, viewCtrl) {\n\t        viewCtrl.init();\n\t      };\n\t    }\n\t  };\n\t});\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/angular-ionic.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap f7d57e32578d658fa0df\n **/","require('./node_modules/ionic-sdk/js/angular/service/decorators/angular-ios9-uiwebview.patch');\nrequire('./node_modules/ionic-sdk/js/angular/main');\nrequire('./node_modules/ionic-sdk/js/angular/service/decorators/compile');\nrequire('./node_modules/ionic-sdk/js/angular/service/decorators/location');\nrequire('./node_modules/ionic-sdk/js/angular/service/actionSheet');\nrequire('./node_modules/ionic-sdk/js/angular/service/angularOverrides');\nrequire('./node_modules/ionic-sdk/js/angular/service/backdrop');\nrequire('./node_modules/ionic-sdk/js/angular/service/bind');\nrequire('./node_modules/ionic-sdk/js/angular/service/body');\nrequire('./node_modules/ionic-sdk/js/angular/service/clickBlock');\nrequire('./node_modules/ionic-sdk/js/angular/service/gesture');\nrequire('./node_modules/ionic-sdk/js/angular/service/history');\nrequire('./node_modules/ionic-sdk/js/angular/service/ionicConfig');\nrequire('./node_modules/ionic-sdk/js/angular/service/loading');\nrequire('./node_modules/ionic-sdk/js/angular/service/modal');\nrequire('./node_modules/ionic-sdk/js/angular/service/navBarDelegate');\nrequire('./node_modules/ionic-sdk/js/angular/service/navViewDelegate');\nrequire('./node_modules/ionic-sdk/js/angular/service/platform');\nrequire('./node_modules/ionic-sdk/js/angular/service/popover');\nrequire('./node_modules/ionic-sdk/js/angular/service/popup');\nrequire('./node_modules/ionic-sdk/js/angular/service/position');\nrequire('./node_modules/ionic-sdk/js/angular/service/scrollDelegate');\nrequire('./node_modules/ionic-sdk/js/angular/service/sideMenuDelegate');\nrequire('./node_modules/ionic-sdk/js/angular/service/slideBoxDelegate');\nrequire('./node_modules/ionic-sdk/js/angular/service/tabsDelegate');\nrequire('./node_modules/ionic-sdk/js/angular/service/templateCache');\nrequire('./node_modules/ionic-sdk/js/angular/service/templateLoader');\nrequire('./node_modules/ionic-sdk/js/angular/service/viewService');\nrequire('./node_modules/ionic-sdk/js/angular/service/viewSwitcher');\nrequire('./node_modules/ionic-sdk/js/angular/controller/headerBarController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/infiniteScrollController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/listController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/navBarController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/navViewController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/refresherController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/scrollController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/sideMenuController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/spinnerController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/tabController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/tabsController');\nrequire('./node_modules/ionic-sdk/js/angular/controller/viewController');\nrequire('./node_modules/ionic-sdk/js/angular/directive/actionSheet');\nrequire('./node_modules/ionic-sdk/js/angular/directive/checkbox');\nrequire('./node_modules/ionic-sdk/js/angular/directive/collectionRepeat');\nrequire('./node_modules/ionic-sdk/js/angular/directive/content');\nrequire('./node_modules/ionic-sdk/js/angular/directive/exposeAsideWhen');\nrequire('./node_modules/ionic-sdk/js/angular/directive/gesture');\nrequire('./node_modules/ionic-sdk/js/angular/directive/headerFooterBar');\nrequire('./node_modules/ionic-sdk/js/angular/directive/infiniteScroll');\nrequire('./node_modules/ionic-sdk/js/angular/directive/input');\nrequire('./node_modules/ionic-sdk/js/angular/directive/itemDeleteButton');\nrequire('./node_modules/ionic-sdk/js/angular/directive/itemFloatingLabel');\nrequire('./node_modules/ionic-sdk/js/angular/directive/item');\nrequire('./node_modules/ionic-sdk/js/angular/directive/itemOptionButton');\nrequire('./node_modules/ionic-sdk/js/angular/directive/itemReorderButton');\nrequire('./node_modules/ionic-sdk/js/angular/directive/keyboardAttach');\nrequire('./node_modules/ionic-sdk/js/angular/directive/list');\nrequire('./node_modules/ionic-sdk/js/angular/directive/menuClose');\nrequire('./node_modules/ionic-sdk/js/angular/directive/menuToggle');\nrequire('./node_modules/ionic-sdk/js/angular/directive/modal');\nrequire('./node_modules/ionic-sdk/js/angular/directive/modalView');\nrequire('./node_modules/ionic-sdk/js/angular/directive/navBackButton');\nrequire('./node_modules/ionic-sdk/js/angular/directive/navBar');\nrequire('./node_modules/ionic-sdk/js/angular/directive/navButtons');\nrequire('./node_modules/ionic-sdk/js/angular/directive/navDirection');\nrequire('./node_modules/ionic-sdk/js/angular/directive/navTitle');\nrequire('./node_modules/ionic-sdk/js/angular/directive/navTransition');\nrequire('./node_modules/ionic-sdk/js/angular/directive/navView');\nrequire('./node_modules/ionic-sdk/js/angular/directive/ngClick');\nrequire('./node_modules/ionic-sdk/js/angular/directive/pane');\nrequire('./node_modules/ionic-sdk/js/angular/directive/popover');\nrequire('./node_modules/ionic-sdk/js/angular/directive/popoverView');\nrequire('./node_modules/ionic-sdk/js/angular/directive/radio');\nrequire('./node_modules/ionic-sdk/js/angular/directive/refresher');\nrequire('./node_modules/ionic-sdk/js/angular/directive/scroll');\nrequire('./node_modules/ionic-sdk/js/angular/directive/sideMenuContent');\nrequire('./node_modules/ionic-sdk/js/angular/directive/sideMenu');\nrequire('./node_modules/ionic-sdk/js/angular/directive/sideMenus');\nrequire('./node_modules/ionic-sdk/js/angular/directive/slideBox');\nrequire('./node_modules/ionic-sdk/js/angular/directive/slides');\nrequire('./node_modules/ionic-sdk/js/angular/directive/spinner');\nrequire('./node_modules/ionic-sdk/js/angular/directive/tab');\nrequire('./node_modules/ionic-sdk/js/angular/directive/tabNav');\nrequire('./node_modules/ionic-sdk/js/angular/directive/tabs');\nrequire('./node_modules/ionic-sdk/js/angular/directive/title');\nrequire('./node_modules/ionic-sdk/js/angular/directive/toggle');\nrequire('./node_modules/ionic-sdk/js/angular/directive/view');\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./entry.js\n ** module id = 0\n ** module chunks = 0\n **/","/**\n * ==================  angular-ios9-uiwebview.patch.js v1.1.1 ==================\n *\n * This patch works around iOS9 UIWebView regression that causes infinite digest\n * errors in Angular.\n *\n * The patch can be applied to Angular 1.2.0  1.4.5. Newer versions of Angular\n * have the workaround baked in.\n *\n * To apply this patch load/bundle this file with your application and add a\n * dependency on the \"ngIOS9UIWebViewPatch\" module to your main app module.\n *\n * For example:\n *\n * ```\n * angular.module('myApp', ['ngRoute'])`\n * ```\n *\n * becomes\n *\n * ```\n * angular.module('myApp', ['ngRoute', 'ngIOS9UIWebViewPatch'])\n * ```\n *\n *\n * More info:\n * - https://openradar.appspot.com/22186109\n * - https://github.com/angular/angular.js/issues/12241\n * - https://github.com/driftyco/ionic/issues/4082\n *\n *\n * @license AngularJS\n * (c) 2010-2015 Google, Inc. http://angularjs.org\n * License: MIT\n */\n\nangular.module('ngIOS9UIWebViewPatch', ['ng']).config(['$provide', function($provide) {\n  'use strict';\n\n  $provide.decorator('$browser', ['$delegate', '$window', function($delegate, $window) {\n\n    if (isIOS9UIWebView($window.navigator.userAgent)) {\n      return applyIOS9Shim($delegate);\n    }\n\n    return $delegate;\n\n    function isIOS9UIWebView(userAgent) {\n      return /(iPhone|iPad|iPod).* OS 9_\\d/.test(userAgent) && !/Version\\/9\\./.test(userAgent);\n    }\n\n    function applyIOS9Shim(browser) {\n      var pendingLocationUrl = null;\n      var originalUrlFn = browser.url;\n\n      browser.url = function() {\n        if (arguments.length) {\n          pendingLocationUrl = arguments[0];\n          return originalUrlFn.apply(browser, arguments);\n        }\n\n        return pendingLocationUrl || originalUrlFn.apply(browser, arguments);\n      };\n\n      window.addEventListener('popstate', clearPendingLocationUrl, false);\n      window.addEventListener('hashchange', clearPendingLocationUrl, false);\n\n      function clearPendingLocationUrl() {\n        pendingLocationUrl = null;\n      }\n\n      return browser;\n    }\n  }]);\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/decorators/angular-ios9-uiwebview.patch.js\n ** module id = 1\n ** module chunks = 0\n **/","/* eslint no-unused-vars:0 */\nvar IonicModule = angular.module('ionic', ['ngAnimate', 'ngSanitize', 'ui.router', 'ngIOS9UIWebViewPatch']),\n  extend = angular.extend,\n  forEach = angular.forEach,\n  isDefined = angular.isDefined,\n  isNumber = angular.isNumber,\n  isString = angular.isString,\n  jqLite = angular.element,\n  noop = angular.noop;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/main.js\n ** module id = 2\n ** module chunks = 0\n **/","/**\n * @private\n * Parts of Ionic requires that $scope data is attached to the element.\n * We do not want to disable adding $scope data to the $element when\n * $compileProvider.debugInfoEnabled(false) is used.\n */\nIonicModule.config(['$provide', function($provide) {\n  $provide.decorator('$compile', ['$delegate', function($compile) {\n     $compile.$$addScopeInfo = function $$addScopeInfo($element, scope, isolated, noTemplate) {\n       var dataName = isolated ? (noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope') : '$scope';\n       $element.data(dataName, scope);\n     };\n     return $compile;\n  }]);\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/decorators/compile.js\n ** module id = 3\n ** module chunks = 0\n **/","/**\n * @private\n */\nIonicModule.config([\n  '$provide',\nfunction($provide) {\n  function $LocationDecorator($location, $timeout) {\n\n    $location.__hash = $location.hash;\n    //Fix: when window.location.hash is set, the scrollable area\n    //found nearest to body's scrollTop is set to scroll to an element\n    //with that ID.\n    $location.hash = function(value) {\n      if (isDefined(value) && value.length > 0) {\n        $timeout(function() {\n          var scroll = document.querySelector('.scroll-content');\n          if (scroll) {\n            scroll.scrollTop = 0;\n          }\n        }, 0, false);\n      }\n      return $location.__hash(value);\n    };\n\n    return $location;\n  }\n\n  $provide.decorator('$location', ['$delegate', '$timeout', $LocationDecorator]);\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/decorators/location.js\n ** module id = 4\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicActionSheet\n * @module ionic\n * @description\n * The Action Sheet is a slide-up pane that lets the user choose from a set of options.\n * Dangerous options are highlighted in red and made obvious.\n *\n * There are easy ways to cancel out of the action sheet, such as tapping the backdrop or even\n * hitting escape on the keyboard for desktop testing.\n *\n * ![Action Sheet](http://ionicframework.com.s3.amazonaws.com/docs/controllers/actionSheet.gif)\n *\n * @usage\n * To trigger an Action Sheet in your code, use the $ionicActionSheet service in your angular controllers:\n *\n * ```js\n * angular.module('mySuperApp', ['ionic'])\n * .controller(function($scope, $ionicActionSheet, $timeout) {\n *\n *  // Triggered on a button click, or some other target\n *  $scope.show = function() {\n *\n *    // Show the action sheet\n *    var hideSheet = $ionicActionSheet.show({\n *      buttons: [\n *        { text: '<b>Share</b> This' },\n *        { text: 'Move' }\n *      ],\n *      destructiveText: 'Delete',\n *      titleText: 'Modify your album',\n *      cancelText: 'Cancel',\n *      cancel: function() {\n          // add cancel code..\n        },\n *      buttonClicked: function(index) {\n *        return true;\n *      }\n *    });\n *\n *    // For example's sake, hide the sheet after two seconds\n *    $timeout(function() {\n *      hideSheet();\n *    }, 2000);\n *\n *  };\n * });\n * ```\n *\n */\nIonicModule\n.factory('$ionicActionSheet', [\n  '$rootScope',\n  '$compile',\n  '$animate',\n  '$timeout',\n  '$ionicTemplateLoader',\n  '$ionicPlatform',\n  '$ionicBody',\n  'IONIC_BACK_PRIORITY',\nfunction($rootScope, $compile, $animate, $timeout, $ionicTemplateLoader, $ionicPlatform, $ionicBody, IONIC_BACK_PRIORITY) {\n\n  return {\n    show: actionSheet\n  };\n\n  /**\n   * @ngdoc method\n   * @name $ionicActionSheet#show\n   * @description\n   * Load and return a new action sheet.\n   *\n   * A new isolated scope will be created for the\n   * action sheet and the new element will be appended into the body.\n   *\n   * @param {object} options The options for this ActionSheet. Properties:\n   *\n   *  - `[Object]` `buttons` Which buttons to show.  Each button is an object with a `text` field.\n   *  - `{string}` `titleText` The title to show on the action sheet.\n   *  - `{string=}` `cancelText` the text for a 'cancel' button on the action sheet.\n   *  - `{string=}` `destructiveText` The text for a 'danger' on the action sheet.\n   *  - `{function=}` `cancel` Called if the cancel button is pressed, the backdrop is tapped or\n   *     the hardware back button is pressed.\n   *  - `{function=}` `buttonClicked` Called when one of the non-destructive buttons is clicked,\n   *     with the index of the button that was clicked and the button object. Return true to close\n   *     the action sheet, or false to keep it opened.\n   *  - `{function=}` `destructiveButtonClicked` Called when the destructive button is clicked.\n   *     Return true to close the action sheet, or false to keep it opened.\n   *  -  `{boolean=}` `cancelOnStateChange` Whether to cancel the actionSheet when navigating\n   *     to a new state.  Default true.\n   *  - `{string}` `cssClass` The custom CSS class name.\n   *\n   * @returns {function} `hideSheet` A function which, when called, hides & cancels the action sheet.\n   */\n  function actionSheet(opts) {\n    var scope = $rootScope.$new(true);\n\n    extend(scope, {\n      cancel: noop,\n      destructiveButtonClicked: noop,\n      buttonClicked: noop,\n      $deregisterBackButton: noop,\n      buttons: [],\n      cancelOnStateChange: true\n    }, opts || {});\n\n    function textForIcon(text) {\n      if (text && /icon/.test(text)) {\n        scope.$actionSheetHasIcon = true;\n      }\n    }\n\n    for (var x = 0; x < scope.buttons.length; x++) {\n      textForIcon(scope.buttons[x].text);\n    }\n    textForIcon(scope.cancelText);\n    textForIcon(scope.destructiveText);\n\n    // Compile the template\n    var element = scope.element = $compile('<ion-action-sheet ng-class=\"cssClass\" buttons=\"buttons\"></ion-action-sheet>')(scope);\n\n    // Grab the sheet element for animation\n    var sheetEl = jqLite(element[0].querySelector('.action-sheet-wrapper'));\n\n    var stateChangeListenDone = scope.cancelOnStateChange ?\n      $rootScope.$on('$stateChangeSuccess', function() { scope.cancel(); }) :\n      noop;\n\n    // removes the actionSheet from the screen\n    scope.removeSheet = function(done) {\n      if (scope.removed) return;\n\n      scope.removed = true;\n      sheetEl.removeClass('action-sheet-up');\n      $timeout(function() {\n        // wait to remove this due to a 300ms delay native\n        // click which would trigging whatever was underneath this\n        $ionicBody.removeClass('action-sheet-open');\n      }, 400);\n      scope.$deregisterBackButton();\n      stateChangeListenDone();\n\n      $animate.removeClass(element, 'active').then(function() {\n        scope.$destroy();\n        element.remove();\n        // scope.cancel.$scope is defined near the bottom\n        scope.cancel.$scope = sheetEl = null;\n        (done || noop)(opts.buttons);\n      });\n    };\n\n    scope.showSheet = function(done) {\n      if (scope.removed) return;\n\n      $ionicBody.append(element)\n                .addClass('action-sheet-open');\n\n      $animate.addClass(element, 'active').then(function() {\n        if (scope.removed) return;\n        (done || noop)();\n      });\n      $timeout(function() {\n        if (scope.removed) return;\n        sheetEl.addClass('action-sheet-up');\n      }, 20, false);\n    };\n\n    // registerBackButtonAction returns a callback to deregister the action\n    scope.$deregisterBackButton = $ionicPlatform.registerBackButtonAction(\n      function() {\n        $timeout(scope.cancel);\n      },\n      IONIC_BACK_PRIORITY.actionSheet\n    );\n\n    // called when the user presses the cancel button\n    scope.cancel = function() {\n      // after the animation is out, call the cancel callback\n      scope.removeSheet(opts.cancel);\n    };\n\n    scope.buttonClicked = function(index) {\n      // Check if the button click event returned true, which means\n      // we can close the action sheet\n      if (opts.buttonClicked(index, opts.buttons[index]) === true) {\n        scope.removeSheet();\n      }\n    };\n\n    scope.destructiveButtonClicked = function() {\n      // Check if the destructive button click event returned true, which means\n      // we can close the action sheet\n      if (opts.destructiveButtonClicked() === true) {\n        scope.removeSheet();\n      }\n    };\n\n    scope.showSheet();\n\n    // Expose the scope on $ionicActionSheet's return value for the sake\n    // of testing it.\n    scope.cancel.$scope = scope;\n\n    return scope.cancel;\n  }\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/actionSheet.js\n ** module id = 5\n ** module chunks = 0\n **/","\njqLite.prototype.addClass = function(cssClasses) {\n  var x, y, cssClass, el, splitClasses, existingClasses;\n  if (cssClasses && cssClasses != 'ng-scope' && cssClasses != 'ng-isolate-scope') {\n    for (x = 0; x < this.length; x++) {\n      el = this[x];\n      if (el.setAttribute) {\n\n        if (cssClasses.indexOf(' ') < 0 && el.classList.add) {\n          el.classList.add(cssClasses);\n        } else {\n          existingClasses = (' ' + (el.getAttribute('class') || '') + ' ')\n            .replace(/[\\n\\t]/g, \" \");\n          splitClasses = cssClasses.split(' ');\n\n          for (y = 0; y < splitClasses.length; y++) {\n            cssClass = splitClasses[y].trim();\n            if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {\n              existingClasses += cssClass + ' ';\n            }\n          }\n          el.setAttribute('class', existingClasses.trim());\n        }\n      }\n    }\n  }\n  return this;\n};\n\njqLite.prototype.removeClass = function(cssClasses) {\n  var x, y, splitClasses, cssClass, el;\n  if (cssClasses) {\n    for (x = 0; x < this.length; x++) {\n      el = this[x];\n      if (el.getAttribute) {\n        if (cssClasses.indexOf(' ') < 0 && el.classList.remove) {\n          el.classList.remove(cssClasses);\n        } else {\n          splitClasses = cssClasses.split(' ');\n\n          for (y = 0; y < splitClasses.length; y++) {\n            cssClass = splitClasses[y];\n            el.setAttribute('class', (\n                (\" \" + (el.getAttribute('class') || '') + \" \")\n                .replace(/[\\n\\t]/g, \" \")\n                .replace(\" \" + cssClass.trim() + \" \", \" \")).trim()\n            );\n          }\n        }\n      }\n    }\n  }\n  return this;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/angularOverrides.js\n ** module id = 6\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicBackdrop\n * @module ionic\n * @description\n * Shows and hides a backdrop over the UI.  Appears behind popups, loading,\n * and other overlays.\n *\n * Often, multiple UI components require a backdrop, but only one backdrop is\n * ever needed in the DOM at a time.\n *\n * Therefore, each component that requires the backdrop to be shown calls\n * `$ionicBackdrop.retain()` when it wants the backdrop, then `$ionicBackdrop.release()`\n * when it is done with the backdrop.\n *\n * For each time `retain` is called, the backdrop will be shown until `release` is called.\n *\n * For example, if `retain` is called three times, the backdrop will be shown until `release`\n * is called three times.\n *\n * **Notes:**\n * - The backdrop service will broadcast 'backdrop.shown' and 'backdrop.hidden' events from the root scope,\n * this is useful for alerting native components not in html.\n *\n * @usage\n *\n * ```js\n * function MyController($scope, $ionicBackdrop, $timeout, $rootScope) {\n *   //Show a backdrop for one second\n *   $scope.action = function() {\n *     $ionicBackdrop.retain();\n *     $timeout(function() {\n *       $ionicBackdrop.release();\n *     }, 1000);\n *   };\n *\n *   // Execute action on backdrop disappearing\n *   $scope.$on('backdrop.hidden', function() {\n *     // Execute action\n *   });\n *\n *   // Execute action on backdrop appearing\n *   $scope.$on('backdrop.shown', function() {\n *     // Execute action\n *   });\n *\n * }\n * ```\n */\nIonicModule\n.factory('$ionicBackdrop', [\n  '$document', '$timeout', '$$rAF', '$rootScope',\nfunction($document, $timeout, $$rAF, $rootScope) {\n\n  var el = jqLite('<div class=\"backdrop\">');\n  var backdropHolds = 0;\n\n  $document[0].body.appendChild(el[0]);\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $ionicBackdrop#retain\n     * @description Retains the backdrop.\n     */\n    retain: retain,\n    /**\n     * @ngdoc method\n     * @name $ionicBackdrop#release\n     * @description\n     * Releases the backdrop.\n     */\n    release: release,\n\n    getElement: getElement,\n\n    // exposed for testing\n    _element: el\n  };\n\n  function retain() {\n    backdropHolds++;\n    if (backdropHolds === 1) {\n      el.addClass('visible');\n      $rootScope.$broadcast('backdrop.shown');\n      $$rAF(function() {\n        // If we're still at >0 backdropHolds after async...\n        if (backdropHolds >= 1) el.addClass('active');\n      });\n    }\n  }\n  function release() {\n    if (backdropHolds === 1) {\n      el.removeClass('active');\n      $rootScope.$broadcast('backdrop.hidden');\n      $timeout(function() {\n        // If we're still at 0 backdropHolds after async...\n        if (backdropHolds === 0) el.removeClass('visible');\n      }, 400, false);\n    }\n    backdropHolds = Math.max(0, backdropHolds - 1);\n  }\n\n  function getElement() {\n    return el;\n  }\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/backdrop.js\n ** module id = 7\n ** module chunks = 0\n **/","/**\n * @private\n */\nIonicModule\n.factory('$ionicBind', ['$parse', '$interpolate', function($parse, $interpolate) {\n  var LOCAL_REGEXP = /^\\s*([@=&])(\\??)\\s*(\\w*)\\s*$/;\n  return function(scope, attrs, bindDefinition) {\n    forEach(bindDefinition || {}, function(definition, scopeName) {\n      //Adapted from angular.js $compile\n      var match = definition.match(LOCAL_REGEXP) || [],\n        attrName = match[3] || scopeName,\n        mode = match[1], // @, =, or &\n        parentGet,\n        unwatch;\n\n      switch (mode) {\n        case '@':\n          if (!attrs[attrName]) {\n            return;\n          }\n          attrs.$observe(attrName, function(value) {\n            scope[scopeName] = value;\n          });\n          // we trigger an interpolation to ensure\n          // the value is there for use immediately\n          if (attrs[attrName]) {\n            scope[scopeName] = $interpolate(attrs[attrName])(scope);\n          }\n          break;\n\n        case '=':\n          if (!attrs[attrName]) {\n            return;\n          }\n          unwatch = scope.$watch(attrs[attrName], function(value) {\n            scope[scopeName] = value;\n          });\n          //Destroy parent scope watcher when this scope is destroyed\n          scope.$on('$destroy', unwatch);\n          break;\n\n        case '&':\n          /* jshint -W044 */\n          if (attrs[attrName] && attrs[attrName].match(RegExp(scopeName + '\\(.*?\\)'))) {\n            throw new Error('& expression binding \"' + scopeName + '\" looks like it will recursively call \"' +\n                          attrs[attrName] + '\" and cause a stack overflow! Please choose a different scopeName.');\n          }\n          parentGet = $parse(attrs[attrName]);\n          scope[scopeName] = function(locals) {\n            return parentGet(scope, locals);\n          };\n          break;\n      }\n    });\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/bind.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicBody\n * @module ionic\n * @description An angular utility service to easily and efficiently\n * add and remove CSS classes from the document's body element.\n */\nIonicModule\n.factory('$ionicBody', ['$document', function($document) {\n  return {\n    /**\n     * @ngdoc method\n     * @name $ionicBody#addClass\n     * @description Add a class to the document's body element.\n     * @param {string} class Each argument will be added to the body element.\n     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n     */\n    addClass: function() {\n      for (var x = 0; x < arguments.length; x++) {\n        $document[0].body.classList.add(arguments[x]);\n      }\n      return this;\n    },\n    /**\n     * @ngdoc method\n     * @name $ionicBody#removeClass\n     * @description Remove a class from the document's body element.\n     * @param {string} class Each argument will be removed from the body element.\n     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n     */\n    removeClass: function() {\n      for (var x = 0; x < arguments.length; x++) {\n        $document[0].body.classList.remove(arguments[x]);\n      }\n      return this;\n    },\n    /**\n     * @ngdoc method\n     * @name $ionicBody#enableClass\n     * @description Similar to the `add` method, except the first parameter accepts a boolean\n     * value determining if the class should be added or removed. Rather than writing user code,\n     * such as \"if true then add the class, else then remove the class\", this method can be\n     * given a true or false value which reduces redundant code.\n     * @param {boolean} shouldEnableClass A true/false value if the class should be added or removed.\n     * @param {string} class Each remaining argument would be added or removed depending on\n     * the first argument.\n     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n     */\n    enableClass: function(shouldEnableClass) {\n      var args = Array.prototype.slice.call(arguments).slice(1);\n      if (shouldEnableClass) {\n        this.addClass.apply(this, args);\n      } else {\n        this.removeClass.apply(this, args);\n      }\n      return this;\n    },\n    /**\n     * @ngdoc method\n     * @name $ionicBody#append\n     * @description Append a child to the document's body.\n     * @param {element} element The element to be appended to the body. The passed in element\n     * can be either a jqLite element, or a DOM element.\n     * @returns {$ionicBody} The $ionicBody service so methods can be chained.\n     */\n    append: function(ele) {\n      $document[0].body.appendChild(ele.length ? ele[0] : ele);\n      return this;\n    },\n    /**\n     * @ngdoc method\n     * @name $ionicBody#get\n     * @description Get the document's body element.\n     * @returns {element} Returns the document's body element.\n     */\n    get: function() {\n      return $document[0].body;\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/body.js\n ** module id = 9\n ** module chunks = 0\n **/","IonicModule\n.factory('$ionicClickBlock', [\n  '$document',\n  '$ionicBody',\n  '$timeout',\nfunction($document, $ionicBody, $timeout) {\n  var CSS_HIDE = 'click-block-hide';\n  var cbEle, fallbackTimer, pendingShow;\n\n  function preventClick(ev) {\n    ev.preventDefault();\n    ev.stopPropagation();\n  }\n\n  function addClickBlock() {\n    if (pendingShow) {\n      if (cbEle) {\n        cbEle.classList.remove(CSS_HIDE);\n      } else {\n        cbEle = $document[0].createElement('div');\n        cbEle.className = 'click-block';\n        $ionicBody.append(cbEle);\n        cbEle.addEventListener('touchstart', preventClick);\n        cbEle.addEventListener('mousedown', preventClick);\n      }\n      pendingShow = false;\n    }\n  }\n\n  function removeClickBlock() {\n    cbEle && cbEle.classList.add(CSS_HIDE);\n  }\n\n  return {\n    show: function(autoExpire) {\n      pendingShow = true;\n      $timeout.cancel(fallbackTimer);\n      fallbackTimer = $timeout(this.hide, autoExpire || 310, false);\n      addClickBlock();\n    },\n    hide: function() {\n      pendingShow = false;\n      $timeout.cancel(fallbackTimer);\n      removeClickBlock();\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/clickBlock.js\n ** module id = 10\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicGesture\n * @module ionic\n * @description An angular service exposing ionic\n * {@link ionic.utility:ionic.EventController}'s gestures.\n */\nIonicModule\n.factory('$ionicGesture', [function() {\n  return {\n    /**\n     * @ngdoc method\n     * @name $ionicGesture#on\n     * @description Add an event listener for a gesture on an element. See {@link ionic.utility:ionic.EventController#onGesture}.\n     * @param {string} eventType The gesture event to listen for.\n     * @param {function(e)} callback The function to call when the gesture\n     * happens.\n     * @param {element} $element The angular element to listen for the event on.\n     * @param {object} options object.\n     * @returns {ionic.Gesture} The gesture object (use this to remove the gesture later on).\n     */\n    on: function(eventType, cb, $element, options) {\n      return window.ionic.onGesture(eventType, cb, $element[0], options);\n    },\n    /**\n     * @ngdoc method\n     * @name $ionicGesture#off\n     * @description Remove an event listener for a gesture on an element. See {@link ionic.utility:ionic.EventController#offGesture}.\n     * @param {ionic.Gesture} gesture The gesture that should be removed.\n     * @param {string} eventType The gesture event to remove the listener for.\n     * @param {function(e)} callback The listener to remove.\n     */\n    off: function(gesture, eventType, cb) {\n      return window.ionic.offGesture(gesture, eventType, cb);\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/gesture.js\n ** module id = 11\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicHistory\n * @module ionic\n * @description\n * $ionicHistory keeps track of views as the user navigates through an app. Similar to the way a\n * browser behaves, an Ionic app is able to keep track of the previous view, the current view, and\n * the forward view (if there is one).  However, a typical web browser only keeps track of one\n * history stack in a linear fashion.\n *\n * Unlike a traditional browser environment, apps and webapps have parallel independent histories,\n * such as with tabs. Should a user navigate few pages deep on one tab, and then switch to a new\n * tab and back, the back button relates not to the previous tab, but to the previous pages\n * visited within _that_ tab.\n *\n * `$ionicHistory` facilitates this parallel history architecture.\n */\n\nIonicModule\n.factory('$ionicHistory', [\n  '$rootScope',\n  '$state',\n  '$location',\n  '$window',\n  '$timeout',\n  '$ionicViewSwitcher',\n  '$ionicNavViewDelegate',\nfunction($rootScope, $state, $location, $window, $timeout, $ionicViewSwitcher, $ionicNavViewDelegate) {\n\n  // history actions while navigating views\n  var ACTION_INITIAL_VIEW = 'initialView';\n  var ACTION_NEW_VIEW = 'newView';\n  var ACTION_MOVE_BACK = 'moveBack';\n  var ACTION_MOVE_FORWARD = 'moveForward';\n\n  // direction of navigation\n  var DIRECTION_BACK = 'back';\n  var DIRECTION_FORWARD = 'forward';\n  var DIRECTION_ENTER = 'enter';\n  var DIRECTION_EXIT = 'exit';\n  var DIRECTION_SWAP = 'swap';\n  var DIRECTION_NONE = 'none';\n\n  var stateChangeCounter = 0;\n  var lastStateId, nextViewOptions, deregisterStateChangeListener, nextViewExpireTimer, forcedNav;\n\n  var viewHistory = {\n    histories: { root: { historyId: 'root', parentHistoryId: null, stack: [], cursor: -1 } },\n    views: {},\n    backView: null,\n    forwardView: null,\n    currentView: null\n  };\n\n  var View = function() {};\n  View.prototype.initialize = function(data) {\n    if (data) {\n      for (var name in data) this[name] = data[name];\n      return this;\n    }\n    return null;\n  };\n  View.prototype.go = function() {\n\n    if (this.stateName) {\n      return $state.go(this.stateName, this.stateParams);\n    }\n\n    if (this.url && this.url !== $location.url()) {\n\n      if (viewHistory.backView === this) {\n        return $window.history.go(-1);\n      } else if (viewHistory.forwardView === this) {\n        return $window.history.go(1);\n      }\n\n      $location.url(this.url);\n    }\n\n    return null;\n  };\n  View.prototype.destroy = function() {\n    if (this.scope) {\n      this.scope.$destroy && this.scope.$destroy();\n      this.scope = null;\n    }\n  };\n\n\n  function getViewById(viewId) {\n    return (viewId ? viewHistory.views[ viewId ] : null);\n  }\n\n  function getBackView(view) {\n    return (view ? getViewById(view.backViewId) : null);\n  }\n\n  function getForwardView(view) {\n    return (view ? getViewById(view.forwardViewId) : null);\n  }\n\n  function getHistoryById(historyId) {\n    return (historyId ? viewHistory.histories[ historyId ] : null);\n  }\n\n  function getHistory(scope) {\n    var histObj = getParentHistoryObj(scope);\n\n    if (!viewHistory.histories[ histObj.historyId ]) {\n      // this history object exists in parent scope, but doesn't\n      // exist in the history data yet\n      viewHistory.histories[ histObj.historyId ] = {\n        historyId: histObj.historyId,\n        parentHistoryId: getParentHistoryObj(histObj.scope.$parent).historyId,\n        stack: [],\n        cursor: -1\n      };\n    }\n    return getHistoryById(histObj.historyId);\n  }\n\n  function getParentHistoryObj(scope) {\n    var parentScope = scope;\n    while (parentScope) {\n      if (parentScope.hasOwnProperty('$historyId')) {\n        // this parent scope has a historyId\n        return { historyId: parentScope.$historyId, scope: parentScope };\n      }\n      // nothing found keep climbing up\n      parentScope = parentScope.$parent;\n    }\n    // no history for the parent, use the root\n    return { historyId: 'root', scope: $rootScope };\n  }\n\n  function setNavViews(viewId) {\n    viewHistory.currentView = getViewById(viewId);\n    viewHistory.backView = getBackView(viewHistory.currentView);\n    viewHistory.forwardView = getForwardView(viewHistory.currentView);\n  }\n\n  function getCurrentStateId() {\n    var id;\n    if ($state && $state.current && $state.current.name) {\n      id = $state.current.name;\n      if ($state.params) {\n        for (var key in $state.params) {\n          if ($state.params.hasOwnProperty(key) && $state.params[key]) {\n            id += \"_\" + key + \"=\" + $state.params[key];\n          }\n        }\n      }\n      return id;\n    }\n    // if something goes wrong make sure its got a unique stateId\n    return ionic.Utils.nextUid();\n  }\n\n  function getCurrentStateParams() {\n    var rtn;\n    if ($state && $state.params) {\n      for (var key in $state.params) {\n        if ($state.params.hasOwnProperty(key)) {\n          rtn = rtn || {};\n          rtn[key] = $state.params[key];\n        }\n      }\n    }\n    return rtn;\n  }\n\n\n  return {\n\n    register: function(parentScope, viewLocals) {\n\n      var currentStateId = getCurrentStateId(),\n          hist = getHistory(parentScope),\n          currentView = viewHistory.currentView,\n          backView = viewHistory.backView,\n          forwardView = viewHistory.forwardView,\n          viewId = null,\n          action = null,\n          direction = DIRECTION_NONE,\n          historyId = hist.historyId,\n          url = $location.url(),\n          tmp, x, ele;\n\n      if (lastStateId !== currentStateId) {\n        lastStateId = currentStateId;\n        stateChangeCounter++;\n      }\n\n      if (forcedNav) {\n        // we've previously set exactly what to do\n        viewId = forcedNav.viewId;\n        action = forcedNav.action;\n        direction = forcedNav.direction;\n        forcedNav = null;\n\n      } else if (backView && backView.stateId === currentStateId) {\n        // they went back one, set the old current view as a forward view\n        viewId = backView.viewId;\n        historyId = backView.historyId;\n        action = ACTION_MOVE_BACK;\n        if (backView.historyId === currentView.historyId) {\n          // went back in the same history\n          direction = DIRECTION_BACK;\n\n        } else if (currentView) {\n          direction = DIRECTION_EXIT;\n\n          tmp = getHistoryById(backView.historyId);\n          if (tmp && tmp.parentHistoryId === currentView.historyId) {\n            direction = DIRECTION_ENTER;\n\n          } else {\n            tmp = getHistoryById(currentView.historyId);\n            if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {\n              direction = DIRECTION_SWAP;\n            }\n          }\n        }\n\n      } else if (forwardView && forwardView.stateId === currentStateId) {\n        // they went to the forward one, set the forward view to no longer a forward view\n        viewId = forwardView.viewId;\n        historyId = forwardView.historyId;\n        action = ACTION_MOVE_FORWARD;\n        if (forwardView.historyId === currentView.historyId) {\n          direction = DIRECTION_FORWARD;\n\n        } else if (currentView) {\n          direction = DIRECTION_EXIT;\n\n          if (currentView.historyId === hist.parentHistoryId) {\n            direction = DIRECTION_ENTER;\n\n          } else {\n            tmp = getHistoryById(currentView.historyId);\n            if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {\n              direction = DIRECTION_SWAP;\n            }\n          }\n        }\n\n        tmp = getParentHistoryObj(parentScope);\n        if (forwardView.historyId && tmp.scope) {\n          // if a history has already been created by the forward view then make sure it stays the same\n          tmp.scope.$historyId = forwardView.historyId;\n          historyId = forwardView.historyId;\n        }\n\n      } else if (currentView && currentView.historyId !== historyId &&\n                hist.cursor > -1 && hist.stack.length > 0 && hist.cursor < hist.stack.length &&\n                hist.stack[hist.cursor].stateId === currentStateId) {\n        // they just changed to a different history and the history already has views in it\n        var switchToView = hist.stack[hist.cursor];\n        viewId = switchToView.viewId;\n        historyId = switchToView.historyId;\n        action = ACTION_MOVE_BACK;\n        direction = DIRECTION_SWAP;\n\n        tmp = getHistoryById(currentView.historyId);\n        if (tmp && tmp.parentHistoryId === historyId) {\n          direction = DIRECTION_EXIT;\n\n        } else {\n          tmp = getHistoryById(historyId);\n          if (tmp && tmp.parentHistoryId === currentView.historyId) {\n            direction = DIRECTION_ENTER;\n          }\n        }\n\n        // if switching to a different history, and the history of the view we're switching\n        // to has an existing back view from a different history than itself, then\n        // it's back view would be better represented using the current view as its back view\n        tmp = getViewById(switchToView.backViewId);\n        if (tmp && switchToView.historyId !== tmp.historyId) {\n          hist.stack[hist.cursor].backViewId = currentView.viewId;\n        }\n\n      } else {\n\n        // create an element from the viewLocals template\n        ele = $ionicViewSwitcher.createViewEle(viewLocals);\n        if (this.isAbstractEle(ele, viewLocals)) {\n          console.log('VIEW', 'abstractView', DIRECTION_NONE, viewHistory.currentView);\n          return {\n            action: 'abstractView',\n            direction: DIRECTION_NONE,\n            ele: ele\n          };\n        }\n\n        // set a new unique viewId\n        viewId = ionic.Utils.nextUid();\n\n        if (currentView) {\n          // set the forward view if there is a current view (ie: if its not the first view)\n          currentView.forwardViewId = viewId;\n\n          action = ACTION_NEW_VIEW;\n\n          // check if there is a new forward view within the same history\n          if (forwardView && currentView.stateId !== forwardView.stateId &&\n             currentView.historyId === forwardView.historyId) {\n            // they navigated to a new view but the stack already has a forward view\n            // since its a new view remove any forwards that existed\n            tmp = getHistoryById(forwardView.historyId);\n            if (tmp) {\n              // the forward has a history\n              for (x = tmp.stack.length - 1; x >= forwardView.index; x--) {\n                // starting from the end destroy all forwards in this history from this point\n                var stackItem = tmp.stack[x];\n                stackItem && stackItem.destroy && stackItem.destroy();\n                tmp.stack.splice(x);\n              }\n              historyId = forwardView.historyId;\n            }\n          }\n\n          // its only moving forward if its in the same history\n          if (hist.historyId === currentView.historyId) {\n            direction = DIRECTION_FORWARD;\n\n          } else if (currentView.historyId !== hist.historyId) {\n            direction = DIRECTION_ENTER;\n\n            tmp = getHistoryById(currentView.historyId);\n            if (tmp && tmp.parentHistoryId === hist.parentHistoryId) {\n              direction = DIRECTION_SWAP;\n\n            } else {\n              tmp = getHistoryById(tmp.parentHistoryId);\n              if (tmp && tmp.historyId === hist.historyId) {\n                direction = DIRECTION_EXIT;\n              }\n            }\n          }\n\n        } else {\n          // there's no current view, so this must be the initial view\n          action = ACTION_INITIAL_VIEW;\n        }\n\n        if (stateChangeCounter < 2) {\n          // views that were spun up on the first load should not animate\n          direction = DIRECTION_NONE;\n        }\n\n        // add the new view\n        viewHistory.views[viewId] = this.createView({\n          viewId: viewId,\n          index: hist.stack.length,\n          historyId: hist.historyId,\n          backViewId: (currentView && currentView.viewId ? currentView.viewId : null),\n          forwardViewId: null,\n          stateId: currentStateId,\n          stateName: this.currentStateName(),\n          stateParams: getCurrentStateParams(),\n          url: url,\n          canSwipeBack: canSwipeBack(ele, viewLocals)\n        });\n\n        // add the new view to this history's stack\n        hist.stack.push(viewHistory.views[viewId]);\n      }\n\n      deregisterStateChangeListener && deregisterStateChangeListener();\n      $timeout.cancel(nextViewExpireTimer);\n      if (nextViewOptions) {\n        if (nextViewOptions.disableAnimate) direction = DIRECTION_NONE;\n        if (nextViewOptions.disableBack) viewHistory.views[viewId].backViewId = null;\n        if (nextViewOptions.historyRoot) {\n          for (x = 0; x < hist.stack.length; x++) {\n            if (hist.stack[x].viewId === viewId) {\n              hist.stack[x].index = 0;\n              hist.stack[x].backViewId = hist.stack[x].forwardViewId = null;\n            } else {\n              delete viewHistory.views[hist.stack[x].viewId];\n            }\n          }\n          hist.stack = [viewHistory.views[viewId]];\n        }\n        nextViewOptions = null;\n      }\n\n      setNavViews(viewId);\n\n      if (viewHistory.backView && historyId == viewHistory.backView.historyId && currentStateId == viewHistory.backView.stateId && url == viewHistory.backView.url) {\n        for (x = 0; x < hist.stack.length; x++) {\n          if (hist.stack[x].viewId == viewId) {\n            action = 'dupNav';\n            direction = DIRECTION_NONE;\n            if (x > 0) {\n              hist.stack[x - 1].forwardViewId = null;\n            }\n            viewHistory.forwardView = null;\n            viewHistory.currentView.index = viewHistory.backView.index;\n            viewHistory.currentView.backViewId = viewHistory.backView.backViewId;\n            viewHistory.backView = getBackView(viewHistory.backView);\n            hist.stack.splice(x, 1);\n            break;\n          }\n        }\n      }\n\n      console.log('VIEW', action, direction, viewHistory.currentView);\n\n      hist.cursor = viewHistory.currentView.index;\n\n      return {\n        viewId: viewId,\n        action: action,\n        direction: direction,\n        historyId: historyId,\n        enableBack: this.enabledBack(viewHistory.currentView),\n        isHistoryRoot: (viewHistory.currentView.index === 0),\n        ele: ele\n      };\n    },\n\n    registerHistory: function(scope) {\n      scope.$historyId = ionic.Utils.nextUid();\n    },\n\n    createView: function(data) {\n      var newView = new View();\n      return newView.initialize(data);\n    },\n\n    getViewById: getViewById,\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#viewHistory\n     * @description The app's view history data, such as all the views and histories, along\n     * with how they are ordered and linked together within the navigation stack.\n     * @returns {object} Returns an object containing the apps view history data.\n     */\n    viewHistory: function() {\n      return viewHistory;\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#currentView\n     * @description The app's current view.\n     * @returns {object} Returns the current view.\n     */\n    currentView: function(view) {\n      if (arguments.length) {\n        viewHistory.currentView = view;\n      }\n      return viewHistory.currentView;\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#currentHistoryId\n     * @description The ID of the history stack which is the parent container of the current view.\n     * @returns {string} Returns the current history ID.\n     */\n    currentHistoryId: function() {\n      return viewHistory.currentView ? viewHistory.currentView.historyId : null;\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#currentTitle\n     * @description Gets and sets the current view's title.\n     * @param {string=} val The title to update the current view with.\n     * @returns {string} Returns the current view's title.\n     */\n    currentTitle: function(val) {\n      if (viewHistory.currentView) {\n        if (arguments.length) {\n          viewHistory.currentView.title = val;\n        }\n        return viewHistory.currentView.title;\n      }\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#backView\n     * @description Returns the view that was before the current view in the history stack.\n     * If the user navigated from View A to View B, then View A would be the back view, and\n     * View B would be the current view.\n     * @returns {object} Returns the back view.\n     */\n    backView: function(view) {\n      if (arguments.length) {\n        viewHistory.backView = view;\n      }\n      return viewHistory.backView;\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#backTitle\n     * @description Gets the back view's title.\n     * @returns {string} Returns the back view's title.\n     */\n    backTitle: function(view) {\n      var backView = (view && getViewById(view.backViewId)) || viewHistory.backView;\n      return backView && backView.title;\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#forwardView\n     * @description Returns the view that was in front of the current view in the history stack.\n     * A forward view would exist if the user navigated from View A to View B, then\n     * navigated back to View A. At this point then View B would be the forward view, and View\n     * A would be the current view.\n     * @returns {object} Returns the forward view.\n     */\n    forwardView: function(view) {\n      if (arguments.length) {\n        viewHistory.forwardView = view;\n      }\n      return viewHistory.forwardView;\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#currentStateName\n     * @description Returns the current state name.\n     * @returns {string}\n     */\n    currentStateName: function() {\n      return ($state && $state.current ? $state.current.name : null);\n    },\n\n    isCurrentStateNavView: function(navView) {\n      return !!($state && $state.current && $state.current.views && $state.current.views[navView]);\n    },\n\n    goToHistoryRoot: function(historyId) {\n      if (historyId) {\n        var hist = getHistoryById(historyId);\n        if (hist && hist.stack.length) {\n          if (viewHistory.currentView && viewHistory.currentView.viewId === hist.stack[0].viewId) {\n            return;\n          }\n          forcedNav = {\n            viewId: hist.stack[0].viewId,\n            action: ACTION_MOVE_BACK,\n            direction: DIRECTION_BACK\n          };\n          hist.stack[0].go();\n        }\n      }\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#goBack\n     * @param {number=} backCount Optional negative integer setting how many views to go\n     * back. By default it'll go back one view by using the value `-1`. To go back two\n     * views you would use `-2`. If the number goes farther back than the number of views\n     * in the current history's stack then it'll go to the first view in the current history's\n     * stack. If the number is zero or greater then it'll do nothing. It also does not\n     * cross history stacks, meaning it can only go as far back as the current history.\n     * @description Navigates the app to the back view, if a back view exists.\n     */\n    goBack: function(backCount) {\n      if (isDefined(backCount) && backCount !== -1) {\n        if (backCount > -1) return;\n\n        var currentHistory = viewHistory.histories[this.currentHistoryId()];\n        var newCursor = currentHistory.cursor + backCount + 1;\n        if (newCursor < 1) {\n          newCursor = 1;\n        }\n\n        currentHistory.cursor = newCursor;\n        setNavViews(currentHistory.stack[newCursor].viewId);\n\n        var cursor = newCursor - 1;\n        var clearStateIds = [];\n        var fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);\n        while (fwdView) {\n          clearStateIds.push(fwdView.stateId || fwdView.viewId);\n          cursor++;\n          if (cursor >= currentHistory.stack.length) break;\n          fwdView = getViewById(currentHistory.stack[cursor].forwardViewId);\n        }\n\n        var self = this;\n        if (clearStateIds.length) {\n          $timeout(function() {\n            self.clearCache(clearStateIds);\n          }, 600);\n        }\n      }\n\n      viewHistory.backView && viewHistory.backView.go();\n    },\n\n\n    enabledBack: function(view) {\n      var backView = getBackView(view);\n      return !!(backView && backView.historyId === view.historyId);\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#clearHistory\n     * @description Clears out the app's entire history, except for the current view.\n     */\n    clearHistory: function() {\n      var\n      histories = viewHistory.histories,\n      currentView = viewHistory.currentView;\n\n      if (histories) {\n        for (var historyId in histories) {\n\n          if (histories[historyId].stack) {\n            histories[historyId].stack = [];\n            histories[historyId].cursor = -1;\n          }\n\n          if (currentView && currentView.historyId === historyId) {\n            currentView.backViewId = currentView.forwardViewId = null;\n            histories[historyId].stack.push(currentView);\n          } else if (histories[historyId].destroy) {\n            histories[historyId].destroy();\n          }\n\n        }\n      }\n\n      for (var viewId in viewHistory.views) {\n        if (viewId !== currentView.viewId) {\n          delete viewHistory.views[viewId];\n        }\n      }\n\n      if (currentView) {\n        setNavViews(currentView.viewId);\n      }\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#clearCache\n\t * @return promise\n     * @description Removes all cached views within every {@link ionic.directive:ionNavView}.\n     * This both removes the view element from the DOM, and destroy it's scope.\n     */\n    clearCache: function(stateIds) {\n      return $timeout(function() {\n        $ionicNavViewDelegate._instances.forEach(function(instance) {\n          instance.clearCache(stateIds);\n        });\n      });\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicHistory#nextViewOptions\n     * @description Sets options for the next view. This method can be useful to override\n     * certain view/transition defaults right before a view transition happens. For example,\n     * the {@link ionic.directive:menuClose} directive uses this method internally to ensure\n     * an animated view transition does not happen when a side menu is open, and also sets\n     * the next view as the root of its history stack. After the transition these options\n     * are set back to null.\n     *\n     * Available options:\n     *\n     * * `disableAnimate`: Do not animate the next transition.\n     * * `disableBack`: The next view should forget its back view, and set it to null.\n     * * `historyRoot`: The next view should become the root view in its history stack.\n     *\n     * ```js\n     * $ionicHistory.nextViewOptions({\n     *   disableAnimate: true,\n     *   disableBack: true\n     * });\n     * ```\n     */\n    nextViewOptions: function(opts) {\n      deregisterStateChangeListener && deregisterStateChangeListener();\n      if (arguments.length) {\n        $timeout.cancel(nextViewExpireTimer);\n        if (opts === null) {\n          nextViewOptions = opts;\n        } else {\n          nextViewOptions = nextViewOptions || {};\n          extend(nextViewOptions, opts);\n          if (nextViewOptions.expire) {\n              deregisterStateChangeListener = $rootScope.$on('$stateChangeSuccess', function() {\n                nextViewExpireTimer = $timeout(function() {\n                  nextViewOptions = null;\n                  }, nextViewOptions.expire);\n              });\n          }\n        }\n      }\n      return nextViewOptions;\n    },\n\n    isAbstractEle: function(ele, viewLocals) {\n      if (viewLocals && viewLocals.$$state && viewLocals.$$state.self['abstract']) {\n        return true;\n      }\n      return !!(ele && (isAbstractTag(ele) || isAbstractTag(ele.children())));\n    },\n\n    isActiveScope: function(scope) {\n      if (!scope) return false;\n\n      var climbScope = scope;\n      var currentHistoryId = this.currentHistoryId();\n      var foundHistoryId;\n\n      while (climbScope) {\n        if (climbScope.$$disconnected) {\n          return false;\n        }\n\n        if (!foundHistoryId && climbScope.hasOwnProperty('$historyId')) {\n          foundHistoryId = true;\n        }\n\n        if (currentHistoryId) {\n          if (climbScope.hasOwnProperty('$historyId') && currentHistoryId == climbScope.$historyId) {\n            return true;\n          }\n          if (climbScope.hasOwnProperty('$activeHistoryId')) {\n            if (currentHistoryId == climbScope.$activeHistoryId) {\n              if (climbScope.hasOwnProperty('$historyId')) {\n                return true;\n              }\n              if (!foundHistoryId) {\n                return true;\n              }\n            }\n          }\n        }\n\n        if (foundHistoryId && climbScope.hasOwnProperty('$activeHistoryId')) {\n          foundHistoryId = false;\n        }\n\n        climbScope = climbScope.$parent;\n      }\n\n      return currentHistoryId ? currentHistoryId == 'root' : true;\n    }\n\n  };\n\n  function isAbstractTag(ele) {\n    return ele && ele.length && /ion-side-menus|ion-tabs/i.test(ele[0].tagName);\n  }\n\n  function canSwipeBack(ele, viewLocals) {\n    if (viewLocals && viewLocals.$$state && viewLocals.$$state.self.canSwipeBack === false) {\n      return false;\n    }\n    if (ele && ele.attr('can-swipe-back') === 'false') {\n      return false;\n    }\n    return true;\n  }\n\n}])\n\n.run([\n  '$rootScope',\n  '$state',\n  '$location',\n  '$document',\n  '$ionicPlatform',\n  '$ionicHistory',\n  'IONIC_BACK_PRIORITY',\nfunction($rootScope, $state, $location, $document, $ionicPlatform, $ionicHistory, IONIC_BACK_PRIORITY) {\n\n  // always reset the keyboard state when change stage\n  $rootScope.$on('$ionicView.beforeEnter', function() {\n    ionic.keyboard && ionic.keyboard.hide && ionic.keyboard.hide();\n  });\n\n  $rootScope.$on('$ionicHistory.change', function(e, data) {\n    if (!data) return null;\n\n    var viewHistory = $ionicHistory.viewHistory();\n\n    var hist = (data.historyId ? viewHistory.histories[ data.historyId ] : null);\n    if (hist && hist.cursor > -1 && hist.cursor < hist.stack.length) {\n      // the history they're going to already exists\n      // go to it's last view in its stack\n      var view = hist.stack[ hist.cursor ];\n      return view.go(data);\n    }\n\n    // this history does not have a URL, but it does have a uiSref\n    // figure out its URL from the uiSref\n    if (!data.url && data.uiSref) {\n      data.url = $state.href(data.uiSref);\n    }\n\n    if (data.url) {\n      // don't let it start with a #, messes with $location.url()\n      if (data.url.indexOf('#') === 0) {\n        data.url = data.url.replace('#', '');\n      }\n      if (data.url !== $location.url()) {\n        // we've got a good URL, ready GO!\n        $location.url(data.url);\n      }\n    }\n  });\n\n  $rootScope.$ionicGoBack = function(backCount) {\n    $ionicHistory.goBack(backCount);\n  };\n\n  // Set the document title when a new view is shown\n  $rootScope.$on('$ionicView.afterEnter', function(ev, data) {\n    if (data && data.title) {\n      $document[0].title = data.title;\n    }\n  });\n\n  // Triggered when devices with a hardware back button (Android) is clicked by the user\n  // This is a Cordova/Phonegap platform specifc method\n  function onHardwareBackButton(e) {\n    var backView = $ionicHistory.backView();\n    if (backView) {\n      // there is a back view, go to it\n      backView.go();\n    } else {\n      // there is no back view, so close the app instead\n      ionic.Platform.exitApp();\n    }\n    e.preventDefault();\n    return false;\n  }\n  $ionicPlatform.registerBackButtonAction(\n    onHardwareBackButton,\n    IONIC_BACK_PRIORITY.view\n  );\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/history.js\n ** module id = 12\n ** module chunks = 0\n **/","/**\r\n * @ngdoc provider\r\n * @name $ionicConfigProvider\r\n * @module ionic\r\n * @description\r\n * Ionic automatically takes platform configurations into account to adjust things like what\r\n * transition style to use and whether tab icons should show on the top or bottom. For example,\r\n * iOS will move forward by transitioning the entering view from right to center and the leaving\r\n * view from center to left. However, Android will transition with the entering view going from\r\n * bottom to center, covering the previous view, which remains stationary. It should be noted\r\n * that when a platform is not iOS or Android, then it'll default to iOS. So if you are\r\n * developing on a desktop browser, it's going to take on iOS default configs.\r\n *\r\n * These configs can be changed using the `$ionicConfigProvider` during the configuration phase\r\n * of your app. Additionally, `$ionicConfig` can also set and get config values during the run\r\n * phase and within the app itself.\r\n *\r\n * By default, all base config variables are set to `'platform'`, which means it'll take on the\r\n * default config of the platform on which it's running. Config variables can be set at this\r\n * level so all platforms follow the same setting, rather than its platform config.\r\n * The following code would set the same config variable for all platforms:\r\n *\r\n * ```js\r\n * $ionicConfigProvider.views.maxCache(10);\r\n * ```\r\n *\r\n * Additionally, each platform can have it's own config within the `$ionicConfigProvider.platform`\r\n * property. The config below would only apply to Android devices.\r\n *\r\n * ```js\r\n * $ionicConfigProvider.platform.android.views.maxCache(5);\r\n * ```\r\n *\r\n * @usage\r\n * ```js\r\n * var myApp = angular.module('reallyCoolApp', ['ionic']);\r\n *\r\n * myApp.config(function($ionicConfigProvider) {\r\n *   $ionicConfigProvider.views.maxCache(5);\r\n *\r\n *   // note that you can also chain configs\r\n *   $ionicConfigProvider.backButton.text('Go Back').icon('ion-chevron-left');\r\n * });\r\n * ```\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#views.transition\r\n * @description Animation style when transitioning between views. Default `platform`.\r\n *\r\n * @param {string} transition Which style of view transitioning to use.\r\n *\r\n * * `platform`: Dynamically choose the correct transition style depending on the platform\r\n * the app is running from. If the platform is not `ios` or `android` then it will default\r\n * to `ios`.\r\n * * `ios`: iOS style transition.\r\n * * `android`: Android style transition.\r\n * * `none`: Do not perform animated transitions.\r\n *\r\n * @returns {string} value\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#views.maxCache\r\n * @description  Maximum number of view elements to cache in the DOM. When the max number is\r\n * exceeded, the view with the longest time period since it was accessed is removed. Views that\r\n * stay in the DOM cache the view's scope, current state, and scroll position. The scope is\r\n * disconnected from the `$watch` cycle when it is cached and reconnected when it enters again.\r\n * When the maximum cache is `0`, the leaving view's element will be removed from the DOM after\r\n * each view transition, and the next time the same view is shown, it will have to re-compile,\r\n * attach to the DOM, and link the element again. This disables caching, in effect.\r\n * @param {number} maxNumber Maximum number of views to retain. Default `10`.\r\n * @returns {number} How many views Ionic will hold onto until the a view is removed.\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#views.forwardCache\r\n * @description  By default, when navigating, views that were recently visited are cached, and\r\n * the same instance data and DOM elements are referenced when navigating back. However, when\r\n * navigating back in the history, the \"forward\" views are removed from the cache. If you\r\n * navigate forward to the same view again, it'll create a new DOM element and controller\r\n * instance. Basically, any forward views are reset each time. Set this config to `true` to have\r\n * forward views cached and not reset on each load.\r\n * @param {boolean} value\r\n * @returns {boolean}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#scrolling.jsScrolling\r\n * @description  Whether to use JS or Native scrolling. Defaults to native scrolling. Setting this to\r\n * `true` has the same effect as setting each `ion-content` to have `overflow-scroll='false'`.\r\n * @param {boolean} value Defaults to `false` as of Ionic 1.2\r\n * @returns {boolean}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#backButton.icon\r\n * @description Back button icon.\r\n * @param {string} value\r\n * @returns {string}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#backButton.text\r\n * @description Back button text.\r\n * @param {string} value Defaults to `Back`.\r\n * @returns {string}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#backButton.previousTitleText\r\n * @description If the previous title text should become the back button text. This\r\n * is the default for iOS.\r\n * @param {boolean} value\r\n * @returns {boolean}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#form.checkbox\r\n * @description Checkbox style. Android defaults to `square` and iOS defaults to `circle`.\r\n * @param {string} value\r\n * @returns {string}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#form.toggle\r\n * @description Toggle item style. Android defaults to `small` and iOS defaults to `large`.\r\n * @param {string} value\r\n * @returns {string}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#spinner.icon\r\n * @description Default spinner icon to use.\r\n * @param {string} value Can be: `android`, `ios`, `ios-small`, `bubbles`, `circles`, `crescent`,\r\n * `dots`, `lines`, `ripple`, or `spiral`.\r\n * @returns {string}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#tabs.style\r\n * @description Tab style. Android defaults to `striped` and iOS defaults to `standard`.\r\n * @param {string} value Available values include `striped` and `standard`.\r\n * @returns {string}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#tabs.position\r\n * @description Tab position. Android defaults to `top` and iOS defaults to `bottom`.\r\n * @param {string} value Available values include `top` and `bottom`.\r\n * @returns {string}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#templates.maxPrefetch\r\n * @description Sets the maximum number of templates to prefetch from the templateUrls defined in\r\n * $stateProvider.state. If set to `0`, the user will have to wait\r\n * for a template to be fetched the first time when navigating to a new page. Default `30`.\r\n * @param {integer} value Max number of template to prefetch from the templateUrls defined in\r\n * `$stateProvider.state()`.\r\n * @returns {integer}\r\n */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#navBar.alignTitle\r\n * @description Which side of the navBar to align the title. Default `center`.\r\n *\r\n * @param {string} value side of the navBar to align the title.\r\n *\r\n * * `platform`: Dynamically choose the correct title style depending on the platform\r\n * the app is running from. If the platform is `ios`, it will default to `center`.\r\n * If the platform is `android`, it will default to `left`. If the platform is not\r\n * `ios` or `android`, it will default to `center`.\r\n *\r\n * * `left`: Left align the title in the navBar\r\n * * `center`: Center align the title in the navBar\r\n * * `right`: Right align the title in the navBar.\r\n *\r\n * @returns {string} value\r\n */\r\n\r\n/**\r\n  * @ngdoc method\r\n  * @name $ionicConfigProvider#navBar.positionPrimaryButtons\r\n  * @description Which side of the navBar to align the primary navBar buttons. Default `left`.\r\n  *\r\n  * @param {string} value side of the navBar to align the primary navBar buttons.\r\n  *\r\n  * * `platform`: Dynamically choose the correct title style depending on the platform\r\n  * the app is running from. If the platform is `ios`, it will default to `left`.\r\n  * If the platform is `android`, it will default to `right`. If the platform is not\r\n  * `ios` or `android`, it will default to `left`.\r\n  *\r\n  * * `left`: Left align the primary navBar buttons in the navBar\r\n  * * `right`: Right align the primary navBar buttons in the navBar.\r\n  *\r\n  * @returns {string} value\r\n  */\r\n\r\n/**\r\n * @ngdoc method\r\n * @name $ionicConfigProvider#navBar.positionSecondaryButtons\r\n * @description Which side of the navBar to align the secondary navBar buttons. Default `right`.\r\n *\r\n * @param {string} value side of the navBar to align the secondary navBar buttons.\r\n *\r\n * * `platform`: Dynamically choose the correct title style depending on the platform\r\n * the app is running from. If the platform is `ios`, it will default to `right`.\r\n * If the platform is `android`, it will default to `right`. If the platform is not\r\n * `ios` or `android`, it will default to `right`.\r\n *\r\n * * `left`: Left align the secondary navBar buttons in the navBar\r\n * * `right`: Right align the secondary navBar buttons in the navBar.\r\n *\r\n * @returns {string} value\r\n */\r\n\r\nIonicModule\r\n.provider('$ionicConfig', function() {\r\n\r\n  var provider = this;\r\n  provider.platform = {};\r\n  var PLATFORM = 'platform';\r\n\r\n  var configProperties = {\r\n    views: {\r\n      maxCache: PLATFORM,\r\n      forwardCache: PLATFORM,\r\n      transition: PLATFORM,\r\n      swipeBackEnabled: PLATFORM,\r\n      swipeBackHitWidth: PLATFORM\r\n    },\r\n    navBar: {\r\n      alignTitle: PLATFORM,\r\n      positionPrimaryButtons: PLATFORM,\r\n      positionSecondaryButtons: PLATFORM,\r\n      transition: PLATFORM\r\n    },\r\n    backButton: {\r\n      icon: PLATFORM,\r\n      text: PLATFORM,\r\n      previousTitleText: PLATFORM\r\n    },\r\n    form: {\r\n      checkbox: PLATFORM,\r\n      toggle: PLATFORM\r\n    },\r\n    scrolling: {\r\n      jsScrolling: PLATFORM\r\n    },\r\n    spinner: {\r\n      icon: PLATFORM\r\n    },\r\n    tabs: {\r\n      style: PLATFORM,\r\n      position: PLATFORM\r\n    },\r\n    templates: {\r\n      maxPrefetch: PLATFORM\r\n    },\r\n    platform: {}\r\n  };\r\n  createConfig(configProperties, provider, '');\r\n\r\n\r\n\r\n  // Default\r\n  // -------------------------\r\n  setPlatformConfig('default', {\r\n\r\n    views: {\r\n      maxCache: 10,\r\n      forwardCache: false,\r\n      transition: 'ios',\r\n      swipeBackEnabled: true,\r\n      swipeBackHitWidth: 45\r\n    },\r\n\r\n    navBar: {\r\n      alignTitle: 'center',\r\n      positionPrimaryButtons: 'left',\r\n      positionSecondaryButtons: 'right',\r\n      transition: 'view'\r\n    },\r\n\r\n    backButton: {\r\n      icon: 'ion-ios-arrow-back',\r\n      text: 'Back',\r\n      previousTitleText: true\r\n    },\r\n\r\n    form: {\r\n      checkbox: 'circle',\r\n      toggle: 'large'\r\n    },\r\n\r\n    scrolling: {\r\n      jsScrolling: true\r\n    },\r\n\r\n    spinner: {\r\n      icon: 'ios'\r\n    },\r\n\r\n    tabs: {\r\n      style: 'standard',\r\n      position: 'bottom'\r\n    },\r\n\r\n    templates: {\r\n      maxPrefetch: 30\r\n    }\r\n\r\n  });\r\n\r\n\r\n\r\n  // iOS (it is the default already)\r\n  // -------------------------\r\n  setPlatformConfig('ios', {});\r\n\r\n\r\n\r\n  // Android\r\n  // -------------------------\r\n  setPlatformConfig('android', {\r\n\r\n    views: {\r\n      transition: 'android',\r\n      swipeBackEnabled: false\r\n    },\r\n\r\n    navBar: {\r\n      alignTitle: 'left',\r\n      positionPrimaryButtons: 'right',\r\n      positionSecondaryButtons: 'right'\r\n    },\r\n\r\n    backButton: {\r\n      icon: 'ion-android-arrow-back',\r\n      text: false,\r\n      previousTitleText: false\r\n    },\r\n\r\n    form: {\r\n      checkbox: 'square',\r\n      toggle: 'small'\r\n    },\r\n\r\n    spinner: {\r\n      icon: 'android'\r\n    },\r\n\r\n    tabs: {\r\n      style: 'striped',\r\n      position: 'top'\r\n    },\r\n\r\n    scrolling: {\r\n      jsScrolling: false\r\n    }\r\n  });\r\n\r\n  // Windows Phone\r\n  // -------------------------\r\n  setPlatformConfig('windowsphone', {\r\n    //scrolling: {\r\n    //  jsScrolling: false\r\n    //}\r\n    spinner: {\r\n      icon: 'android'\r\n    }\r\n  });\r\n\r\n\r\n  provider.transitions = {\r\n    views: {},\r\n    navBar: {}\r\n  };\r\n\r\n\r\n  // iOS Transitions\r\n  // -----------------------\r\n  provider.transitions.views.ios = function(enteringEle, leavingEle, direction, shouldAnimate) {\r\n\r\n    function setStyles(ele, opacity, x, boxShadowOpacity) {\r\n      var css = {};\r\n      css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;\r\n      css.opacity = opacity;\r\n      if (boxShadowOpacity > -1) {\r\n        css.boxShadow = '0 0 10px rgba(0,0,0,' + (d.shouldAnimate ? boxShadowOpacity * 0.45 : 0.3) + ')';\r\n      }\r\n      css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';\r\n      ionic.DomUtil.cachedStyles(ele, css);\r\n    }\r\n\r\n    var d = {\r\n      run: function(step) {\r\n        if (direction == 'forward') {\r\n          setStyles(enteringEle, 1, (1 - step) * 99, 1 - step); // starting at 98% prevents a flicker\r\n          setStyles(leavingEle, (1 - 0.1 * step), step * -33, -1);\r\n\r\n        } else if (direction == 'back') {\r\n          setStyles(enteringEle, (1 - 0.1 * (1 - step)), (1 - step) * -33, -1);\r\n          setStyles(leavingEle, 1, step * 100, 1 - step);\r\n\r\n        } else {\r\n          // swap, enter, exit\r\n          setStyles(enteringEle, 1, 0, -1);\r\n          setStyles(leavingEle, 0, 0, -1);\r\n        }\r\n      },\r\n      shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')\r\n    };\r\n\r\n    return d;\r\n  };\r\n\r\n  provider.transitions.navBar.ios = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {\r\n\r\n    function setStyles(ctrl, opacity, titleX, backTextX) {\r\n      var css = {};\r\n      css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : '0ms';\r\n      css.opacity = opacity === 1 ? '' : opacity;\r\n\r\n      ctrl.setCss('buttons-left', css);\r\n      ctrl.setCss('buttons-right', css);\r\n      ctrl.setCss('back-button', css);\r\n\r\n      css[ionic.CSS.TRANSFORM] = 'translate3d(' + backTextX + 'px,0,0)';\r\n      ctrl.setCss('back-text', css);\r\n\r\n      css[ionic.CSS.TRANSFORM] = 'translate3d(' + titleX + 'px,0,0)';\r\n      ctrl.setCss('title', css);\r\n    }\r\n\r\n    function enter(ctrlA, ctrlB, step) {\r\n      if (!ctrlA || !ctrlB) return;\r\n      var titleX = (ctrlA.titleTextX() + ctrlA.titleWidth()) * (1 - step);\r\n      var backTextX = (ctrlB && (ctrlB.titleTextX() - ctrlA.backButtonTextLeft()) * (1 - step)) || 0;\r\n      setStyles(ctrlA, step, titleX, backTextX);\r\n    }\r\n\r\n    function leave(ctrlA, ctrlB, step) {\r\n      if (!ctrlA || !ctrlB) return;\r\n      var titleX = (-(ctrlA.titleTextX() - ctrlB.backButtonTextLeft()) - (ctrlA.titleLeftRight())) * step;\r\n      setStyles(ctrlA, 1 - step, titleX, 0);\r\n    }\r\n\r\n    var d = {\r\n      run: function(step) {\r\n        var enteringHeaderCtrl = enteringHeaderBar.controller();\r\n        var leavingHeaderCtrl = leavingHeaderBar && leavingHeaderBar.controller();\r\n        if (d.direction == 'back') {\r\n          leave(enteringHeaderCtrl, leavingHeaderCtrl, 1 - step);\r\n          enter(leavingHeaderCtrl, enteringHeaderCtrl, 1 - step);\r\n        } else {\r\n          enter(enteringHeaderCtrl, leavingHeaderCtrl, step);\r\n          leave(leavingHeaderCtrl, enteringHeaderCtrl, step);\r\n        }\r\n      },\r\n      direction: direction,\r\n      shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')\r\n    };\r\n\r\n    return d;\r\n  };\r\n\r\n\r\n  // Android Transitions\r\n  // -----------------------\r\n\r\n  provider.transitions.views.android = function(enteringEle, leavingEle, direction, shouldAnimate) {\r\n    shouldAnimate = shouldAnimate && (direction == 'forward' || direction == 'back');\r\n\r\n    function setStyles(ele, x) {\r\n      var css = {};\r\n      css[ionic.CSS.TRANSITION_DURATION] = d.shouldAnimate ? '' : 0;\r\n      css[ionic.CSS.TRANSFORM] = 'translate3d(' + x + '%,0,0)';\r\n      ionic.DomUtil.cachedStyles(ele, css);\r\n    }\r\n\r\n    var d = {\r\n      run: function(step) {\r\n        if (direction == 'forward') {\r\n          setStyles(enteringEle, (1 - step) * 99); // starting at 98% prevents a flicker\r\n          setStyles(leavingEle, step * -100);\r\n\r\n        } else if (direction == 'back') {\r\n          setStyles(enteringEle, (1 - step) * -100);\r\n          setStyles(leavingEle, step * 100);\r\n\r\n        } else {\r\n          // swap, enter, exit\r\n          setStyles(enteringEle, 0);\r\n          setStyles(leavingEle, 0);\r\n        }\r\n      },\r\n      shouldAnimate: shouldAnimate\r\n    };\r\n\r\n    return d;\r\n  };\r\n\r\n  provider.transitions.navBar.android = function(enteringHeaderBar, leavingHeaderBar, direction, shouldAnimate) {\r\n\r\n    function setStyles(ctrl, opacity) {\r\n      if (!ctrl) return;\r\n      var css = {};\r\n      css.opacity = opacity === 1 ? '' : opacity;\r\n\r\n      ctrl.setCss('buttons-left', css);\r\n      ctrl.setCss('buttons-right', css);\r\n      ctrl.setCss('back-button', css);\r\n      ctrl.setCss('back-text', css);\r\n      ctrl.setCss('title', css);\r\n    }\r\n\r\n    return {\r\n      run: function(step) {\r\n        setStyles(enteringHeaderBar.controller(), step);\r\n        setStyles(leavingHeaderBar && leavingHeaderBar.controller(), 1 - step);\r\n      },\r\n      shouldAnimate: shouldAnimate && (direction == 'forward' || direction == 'back')\r\n    };\r\n  };\r\n\r\n\r\n  // No Transition\r\n  // -----------------------\r\n\r\n  provider.transitions.views.none = function(enteringEle, leavingEle) {\r\n    return {\r\n      run: function(step) {\r\n        provider.transitions.views.android(enteringEle, leavingEle, false, false).run(step);\r\n      },\r\n      shouldAnimate: false\r\n    };\r\n  };\r\n\r\n  provider.transitions.navBar.none = function(enteringHeaderBar, leavingHeaderBar) {\r\n    return {\r\n      run: function(step) {\r\n        provider.transitions.navBar.ios(enteringHeaderBar, leavingHeaderBar, false, false).run(step);\r\n        provider.transitions.navBar.android(enteringHeaderBar, leavingHeaderBar, false, false).run(step);\r\n      },\r\n      shouldAnimate: false\r\n    };\r\n  };\r\n\r\n\r\n  // private: used to set platform configs\r\n  function setPlatformConfig(platformName, platformConfigs) {\r\n    configProperties.platform[platformName] = platformConfigs;\r\n    provider.platform[platformName] = {};\r\n\r\n    addConfig(configProperties, configProperties.platform[platformName]);\r\n\r\n    createConfig(configProperties.platform[platformName], provider.platform[platformName], '');\r\n  }\r\n\r\n\r\n  // private: used to recursively add new platform configs\r\n  function addConfig(configObj, platformObj) {\r\n    for (var n in configObj) {\r\n      if (n != PLATFORM && configObj.hasOwnProperty(n)) {\r\n        if (angular.isObject(configObj[n])) {\r\n          if (!isDefined(platformObj[n])) {\r\n            platformObj[n] = {};\r\n          }\r\n          addConfig(configObj[n], platformObj[n]);\r\n\r\n        } else if (!isDefined(platformObj[n])) {\r\n          platformObj[n] = null;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // private: create methods for each config to get/set\r\n  function createConfig(configObj, providerObj, platformPath) {\r\n    forEach(configObj, function(value, namespace) {\r\n\r\n      if (angular.isObject(configObj[namespace])) {\r\n        // recursively drill down the config object so we can create a method for each one\r\n        providerObj[namespace] = {};\r\n        createConfig(configObj[namespace], providerObj[namespace], platformPath + '.' + namespace);\r\n\r\n      } else {\r\n        // create a method for the provider/config methods that will be exposed\r\n        providerObj[namespace] = function(newValue) {\r\n          if (arguments.length) {\r\n            configObj[namespace] = newValue;\r\n            return providerObj;\r\n          }\r\n          if (configObj[namespace] == PLATFORM) {\r\n            // if the config is set to 'platform', then get this config's platform value\r\n            var platformConfig = stringObj(configProperties.platform, ionic.Platform.platform() + platformPath + '.' + namespace);\r\n            if (platformConfig || platformConfig === false) {\r\n              return platformConfig;\r\n            }\r\n            // didnt find a specific platform config, now try the default\r\n            return stringObj(configProperties.platform, 'default' + platformPath + '.' + namespace);\r\n          }\r\n          return configObj[namespace];\r\n        };\r\n      }\r\n\r\n    });\r\n  }\r\n\r\n  function stringObj(obj, str) {\r\n    str = str.split(\".\");\r\n    for (var i = 0; i < str.length; i++) {\r\n      if (obj && isDefined(obj[str[i]])) {\r\n        obj = obj[str[i]];\r\n      } else {\r\n        return null;\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  provider.setPlatformConfig = setPlatformConfig;\r\n\r\n\r\n  // private: Service definition for internal Ionic use\r\n  /**\r\n   * @ngdoc service\r\n   * @name $ionicConfig\r\n   * @module ionic\r\n   * @private\r\n   */\r\n  provider.$get = function() {\r\n    return provider;\r\n  };\r\n})\r\n// Fix for URLs in Cordova apps on Windows Phone\r\n// http://blogs.msdn.com/b/msdn_answers/archive/2015/02/10/\r\n// running-cordova-apps-on-windows-and-windows-phone-8-1-using-ionic-angularjs-and-other-frameworks.aspx\r\n.config(['$compileProvider', function($compileProvider) {\r\n  $compileProvider.aHrefSanitizationWhitelist(/^\\s*(https?|sms|tel|geo|ftp|mailto|file|ghttps?|ms-appx-web|ms-appx|x-wmapp0):/);\r\n  $compileProvider.imgSrcSanitizationWhitelist(/^\\s*(https?|ftp|file|content|blob|ms-appx|ms-appx-web|x-wmapp0):|data:image\\//);\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/ionicConfig.js\n ** module id = 13\n ** module chunks = 0\n **/","\r\nvar LOADING_TPL =\r\n  '<div class=\"loading-container\">' +\r\n    '<div class=\"loading\">' +\r\n    '</div>' +\r\n  '</div>';\r\n\r\nvar LOADING_HIDE_DEPRECATED = '$ionicLoading instance.hide() has been deprecated. Use $ionicLoading.hide().';\r\nvar LOADING_SHOW_DEPRECATED = '$ionicLoading instance.show() has been deprecated. Use $ionicLoading.show().';\r\nvar LOADING_SET_DEPRECATED = '$ionicLoading instance.setContent() has been deprecated. Use $ionicLoading.show({ template: \\'my content\\' }).';\r\n\r\n/**\r\n * @ngdoc service\r\n * @name $ionicLoading\r\n * @module ionic\r\n * @description\r\n * An overlay that can be used to indicate activity while blocking user\r\n * interaction.\r\n *\r\n * @usage\r\n * ```js\r\n * angular.module('LoadingApp', ['ionic'])\r\n * .controller('LoadingCtrl', function($scope, $ionicLoading) {\r\n *   $scope.show = function() {\r\n *     $ionicLoading.show({\r\n *       template: 'Loading...'\r\n *     });\r\n *   };\r\n *   $scope.hide = function(){\r\n *     $ionicLoading.hide();\r\n *   };\r\n * });\r\n * ```\r\n */\r\n/**\r\n * @ngdoc object\r\n * @name $ionicLoadingConfig\r\n * @module ionic\r\n * @description\r\n * Set the default options to be passed to the {@link ionic.service:$ionicLoading} service.\r\n *\r\n * @usage\r\n * ```js\r\n * var app = angular.module('myApp', ['ionic'])\r\n * app.constant('$ionicLoadingConfig', {\r\n *   template: 'Default Loading Template...'\r\n * });\r\n * app.controller('AppCtrl', function($scope, $ionicLoading) {\r\n *   $scope.showLoading = function() {\r\n *     $ionicLoading.show(); //options default to values in $ionicLoadingConfig\r\n *   };\r\n * });\r\n * ```\r\n */\r\nIonicModule\r\n.constant('$ionicLoadingConfig', {\r\n  template: '<ion-spinner></ion-spinner>'\r\n})\r\n.factory('$ionicLoading', [\r\n  '$ionicLoadingConfig',\r\n  '$ionicBody',\r\n  '$ionicTemplateLoader',\r\n  '$ionicBackdrop',\r\n  '$timeout',\r\n  '$q',\r\n  '$log',\r\n  '$compile',\r\n  '$ionicPlatform',\r\n  '$rootScope',\r\n  'IONIC_BACK_PRIORITY',\r\nfunction($ionicLoadingConfig, $ionicBody, $ionicTemplateLoader, $ionicBackdrop, $timeout, $q, $log, $compile, $ionicPlatform, $rootScope, IONIC_BACK_PRIORITY) {\r\n\r\n  var loaderInstance;\r\n  //default values\r\n  var deregisterBackAction = noop;\r\n  var deregisterStateListener1 = noop;\r\n  var deregisterStateListener2 = noop;\r\n  var loadingShowDelay = $q.when();\r\n\r\n  return {\r\n    /**\r\n     * @ngdoc method\r\n     * @name $ionicLoading#show\r\n     * @description Shows a loading indicator. If the indicator is already shown,\r\n     * it will set the options given and keep the indicator shown. Note: While this\r\n     * function still returns an $ionicLoading instance for backwards compatiblity,\r\n     * its use has been deprecated.\r\n     * @param {object} opts The options for the loading indicator. Available properties:\r\n     *  - `{string=}` `template` The html content of the indicator.\r\n     *  - `{string=}` `templateUrl` The url of an html template to load as the content of the indicator.\r\n     *  - `{object=}` `scope` The scope to be a child of. Default: creates a child of $rootScope.\r\n     *  - `{boolean=}` `noBackdrop` Whether to hide the backdrop. By default it will be shown.\r\n     *  - `{boolean=}` `hideOnStateChange` Whether to hide the loading spinner when navigating\r\n     *    to a new state. Default false.\r\n     *  - `{number=}` `delay` How many milliseconds to delay showing the indicator. By default there is no delay.\r\n     *  - `{number=}` `duration` How many milliseconds to wait until automatically\r\n     *  hiding the indicator. By default, the indicator will be shown until `.hide()` is called.\r\n     */\r\n    show: showLoader,\r\n    /**\r\n     * @ngdoc method\r\n     * @name $ionicLoading#hide\r\n     * @description Hides the loading indicator, if shown.\r\n     */\r\n    hide: hideLoader,\r\n    /**\r\n     * @private for testing\r\n     */\r\n    _getLoader: getLoader\r\n  };\r\n\r\n  function getLoader() {\r\n    if (!loaderInstance) {\r\n      loaderInstance = $ionicTemplateLoader.compile({\r\n        template: LOADING_TPL,\r\n        appendTo: $ionicBody.get()\r\n      })\r\n      .then(function(self) {\r\n        self.show = function(options) {\r\n          var templatePromise = options.templateUrl ?\r\n            $ionicTemplateLoader.load(options.templateUrl) :\r\n            //options.content: deprecated\r\n            $q.when(options.template || options.content || '');\r\n\r\n          self.scope = options.scope || self.scope;\r\n\r\n          if (!self.isShown) {\r\n            //options.showBackdrop: deprecated\r\n            self.hasBackdrop = !options.noBackdrop && options.showBackdrop !== false;\r\n            if (self.hasBackdrop) {\r\n              $ionicBackdrop.retain();\r\n              $ionicBackdrop.getElement().addClass('backdrop-loading');\r\n            }\r\n          }\r\n\r\n          if (options.duration) {\r\n            $timeout.cancel(self.durationTimeout);\r\n            self.durationTimeout = $timeout(\r\n              angular.bind(self, self.hide),\r\n              +options.duration\r\n            );\r\n          }\r\n\r\n          deregisterBackAction();\r\n          //Disable hardware back button while loading\r\n          deregisterBackAction = $ionicPlatform.registerBackButtonAction(\r\n            noop,\r\n            IONIC_BACK_PRIORITY.loading\r\n          );\r\n\r\n          templatePromise.then(function(html) {\r\n            if (html) {\r\n              var loading = self.element.children();\r\n              loading.html(html);\r\n              $compile(loading.contents())(self.scope);\r\n            }\r\n\r\n            //Don't show until template changes\r\n            if (self.isShown) {\r\n              self.element.addClass('visible');\r\n              ionic.requestAnimationFrame(function() {\r\n                if (self.isShown) {\r\n                  self.element.addClass('active');\r\n                  $ionicBody.addClass('loading-active');\r\n                }\r\n              });\r\n            }\r\n          });\r\n\r\n          self.isShown = true;\r\n        };\r\n        self.hide = function() {\r\n\r\n          deregisterBackAction();\r\n          if (self.isShown) {\r\n            if (self.hasBackdrop) {\r\n              $ionicBackdrop.release();\r\n              $ionicBackdrop.getElement().removeClass('backdrop-loading');\r\n            }\r\n            self.element.removeClass('active');\r\n            $ionicBody.removeClass('loading-active');\r\n            self.element.removeClass('visible');\r\n            ionic.requestAnimationFrame(function() {\r\n              !self.isShown && self.element.removeClass('visible');\r\n            });\r\n          }\r\n          $timeout.cancel(self.durationTimeout);\r\n          self.isShown = false;\r\n          var loading = self.element.children();\r\n          loading.html(\"\");\r\n        };\r\n\r\n        return self;\r\n      });\r\n    }\r\n    return loaderInstance;\r\n  }\r\n\r\n  function showLoader(options) {\r\n    options = extend({}, $ionicLoadingConfig || {}, options || {});\r\n    var delay = options.delay || options.showDelay || 0;\r\n\r\n    deregisterStateListener1();\r\n    deregisterStateListener2();\r\n    if (options.hideOnStateChange) {\r\n      deregisterStateListener1 = $rootScope.$on('$stateChangeSuccess', hideLoader);\r\n      deregisterStateListener2 = $rootScope.$on('$stateChangeError', hideLoader);\r\n    }\r\n\r\n    //If loading.show() was called previously, cancel it and show with our new options\r\n    $timeout.cancel(loadingShowDelay);\r\n    loadingShowDelay = $timeout(noop, delay);\r\n    loadingShowDelay.then(getLoader).then(function(loader) {\r\n      return loader.show(options);\r\n    });\r\n\r\n    return {\r\n      hide: function deprecatedHide() {\r\n        $log.error(LOADING_HIDE_DEPRECATED);\r\n        return hideLoader.apply(this, arguments);\r\n      },\r\n      show: function deprecatedShow() {\r\n        $log.error(LOADING_SHOW_DEPRECATED);\r\n        return showLoader.apply(this, arguments);\r\n      },\r\n      setContent: function deprecatedSetContent(content) {\r\n        $log.error(LOADING_SET_DEPRECATED);\r\n        return getLoader().then(function(loader) {\r\n          loader.show({ template: content });\r\n        });\r\n      }\r\n    };\r\n  }\r\n\r\n  function hideLoader() {\r\n    deregisterStateListener1();\r\n    deregisterStateListener2();\r\n    $timeout.cancel(loadingShowDelay);\r\n    getLoader().then(function(loader) {\r\n      loader.hide();\r\n    });\r\n  }\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/loading.js\n ** module id = 14\n ** module chunks = 0\n **/","/**\r\n * @ngdoc service\r\n * @name $ionicModal\r\n * @module ionic\r\n * @description\r\n *\r\n * Related: {@link ionic.controller:ionicModal ionicModal controller}.\r\n *\r\n * The Modal is a content pane that can go over the user's main view\r\n * temporarily.  Usually used for making a choice or editing an item.\r\n *\r\n * Put the content of the modal inside of an `<ion-modal-view>` element.\r\n *\r\n * **Notes:**\r\n * - A modal will broadcast 'modal.shown', 'modal.hidden', and 'modal.removed' events from its originating\r\n * scope, passing in itself as an event argument. Both the modal.removed and modal.hidden events are\r\n * called when the modal is removed.\r\n *\r\n * - This example assumes your modal is in your main index file or another template file. If it is in its own\r\n * template file, remove the script tags and call it by file name.\r\n *\r\n * @usage\r\n * ```html\r\n * <script id=\"my-modal.html\" type=\"text/ng-template\">\r\n *   <ion-modal-view>\r\n *     <ion-header-bar>\r\n *       <h1 class=\"title\">My Modal title</h1>\r\n *     </ion-header-bar>\r\n *     <ion-content>\r\n *       Hello!\r\n *     </ion-content>\r\n *   </ion-modal-view>\r\n * </script>\r\n * ```\r\n * ```js\r\n * angular.module('testApp', ['ionic'])\r\n * .controller('MyController', function($scope, $ionicModal) {\r\n *   $ionicModal.fromTemplateUrl('my-modal.html', {\r\n *     scope: $scope,\r\n *     animation: 'slide-in-up'\r\n *   }).then(function(modal) {\r\n *     $scope.modal = modal;\r\n *   });\r\n *   $scope.openModal = function() {\r\n *     $scope.modal.show();\r\n *   };\r\n *   $scope.closeModal = function() {\r\n *     $scope.modal.hide();\r\n *   };\r\n *   //Cleanup the modal when we're done with it!\r\n *   $scope.$on('$destroy', function() {\r\n *     $scope.modal.remove();\r\n *   });\r\n *   // Execute action on hide modal\r\n *   $scope.$on('modal.hidden', function() {\r\n *     // Execute action\r\n *   });\r\n *   // Execute action on remove modal\r\n *   $scope.$on('modal.removed', function() {\r\n *     // Execute action\r\n *   });\r\n * });\r\n * ```\r\n */\r\nIonicModule\r\n.factory('$ionicModal', [\r\n  '$rootScope',\r\n  '$ionicBody',\r\n  '$compile',\r\n  '$timeout',\r\n  '$ionicPlatform',\r\n  '$ionicTemplateLoader',\r\n  '$$q',\r\n  '$log',\r\n  '$ionicClickBlock',\r\n  '$window',\r\n  'IONIC_BACK_PRIORITY',\r\nfunction($rootScope, $ionicBody, $compile, $timeout, $ionicPlatform, $ionicTemplateLoader, $$q, $log, $ionicClickBlock, $window, IONIC_BACK_PRIORITY) {\r\n\r\n  /**\r\n   * @ngdoc controller\r\n   * @name ionicModal\r\n   * @module ionic\r\n   * @description\r\n   * Instantiated by the {@link ionic.service:$ionicModal} service.\r\n   *\r\n   * Be sure to call [remove()](#remove) when you are done with each modal\r\n   * to clean it up and avoid memory leaks.\r\n   *\r\n   * Note: a modal will broadcast 'modal.shown', 'modal.hidden', and 'modal.removed' events from its originating\r\n   * scope, passing in itself as an event argument. Note: both modal.removed and modal.hidden are\r\n   * called when the modal is removed.\r\n   */\r\n  var ModalView = ionic.views.Modal.inherit({\r\n    /**\r\n     * @ngdoc method\r\n     * @name ionicModal#initialize\r\n     * @description Creates a new modal controller instance.\r\n     * @param {object} options An options object with the following properties:\r\n     *  - `{object=}` `scope` The scope to be a child of.\r\n     *    Default: creates a child of $rootScope.\r\n     *  - `{string=}` `animation` The animation to show & hide with.\r\n     *    Default: 'slide-in-up'\r\n     *  - `{boolean=}` `focusFirstInput` Whether to autofocus the first input of\r\n     *    the modal when shown. Will only show the keyboard on iOS, to force the keyboard to show\r\n     *    on Android, please use the [Ionic keyboard plugin](https://github.com/driftyco/ionic-plugin-keyboard#keyboardshow).\r\n     *    Default: false.\r\n     *  - `{boolean=}` `backdropClickToClose` Whether to close the modal on clicking the backdrop.\r\n     *    Default: true.\r\n     *  - `{boolean=}` `hardwareBackButtonClose` Whether the modal can be closed using the hardware\r\n     *    back button on Android and similar devices.  Default: true.\r\n     */\r\n    initialize: function(opts) {\r\n      ionic.views.Modal.prototype.initialize.call(this, opts);\r\n      this.animation = opts.animation || 'slide-in-up';\r\n    },\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ionicModal#show\r\n     * @description Show this modal instance.\r\n     * @returns {promise} A promise which is resolved when the modal is finished animating in.\r\n     */\r\n    show: function(target) {\r\n      var self = this;\r\n\r\n      if (self.scope.$$destroyed) {\r\n        $log.error('Cannot call ' + self.viewType + '.show() after remove(). Please create a new ' + self.viewType + ' instance.');\r\n        return $$q.when();\r\n      }\r\n\r\n      // on iOS, clicks will sometimes bleed through/ghost click on underlying\r\n      // elements\r\n      $ionicClickBlock.show(600);\r\n      stack.add(self);\r\n\r\n      var modalEl = jqLite(self.modalEl);\r\n\r\n      self.el.classList.remove('hide');\r\n      $timeout(function() {\r\n        if (!self._isShown) return;\r\n        $ionicBody.addClass(self.viewType + '-open');\r\n      }, 400, false);\r\n\r\n      if (!self.el.parentElement) {\r\n        modalEl.addClass(self.animation);\r\n        $ionicBody.append(self.el);\r\n      }\r\n\r\n      // if modal was closed while the keyboard was up, reset scroll view on\r\n      // next show since we can only resize it once it's visible\r\n      var scrollCtrl = modalEl.data('$$ionicScrollController');\r\n      scrollCtrl && scrollCtrl.resize();\r\n\r\n      if (target && self.positionView) {\r\n        self.positionView(target, modalEl);\r\n        // set up a listener for in case the window size changes\r\n\r\n        self._onWindowResize = function() {\r\n          if (self._isShown) self.positionView(target, modalEl);\r\n        };\r\n        ionic.on('resize', self._onWindowResize, window);\r\n      }\r\n\r\n      modalEl.addClass('ng-enter active')\r\n             .removeClass('ng-leave ng-leave-active');\r\n\r\n      self._isShown = true;\r\n      self._deregisterBackButton = $ionicPlatform.registerBackButtonAction(\r\n        self.hardwareBackButtonClose ? angular.bind(self, self.hide) : noop,\r\n        IONIC_BACK_PRIORITY.modal\r\n      );\r\n\r\n      ionic.views.Modal.prototype.show.call(self);\r\n\r\n      $timeout(function() {\r\n        if (!self._isShown) return;\r\n        modalEl.addClass('ng-enter-active');\r\n        ionic.trigger('resize');\r\n        self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.shown', self);\r\n        self.el.classList.add('active');\r\n        self.scope.$broadcast('$ionicHeader.align');\r\n        self.scope.$broadcast('$ionicFooter.align');\r\n      }, 20);\r\n\r\n      return $timeout(function() {\r\n        if (!self._isShown) return;\r\n        self.$el.on('touchmove', function(e) {\r\n          //Don't allow scrolling while open by dragging on backdrop\r\n          var isInScroll = ionic.DomUtil.getParentOrSelfWithClass(e.target, 'scroll');\r\n          if (!isInScroll) {\r\n            e.preventDefault();\r\n          }\r\n        });\r\n        //After animating in, allow hide on backdrop click\r\n        self.$el.on('click', function(e) {\r\n          if (self.backdropClickToClose && e.target === self.el && stack.isHighest(self)) {\r\n            self.hide();\r\n          }\r\n        });\r\n      }, 400);\r\n    },\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ionicModal#hide\r\n     * @description Hide this modal instance.\r\n     * @returns {promise} A promise which is resolved when the modal is finished animating out.\r\n     */\r\n    hide: function() {\r\n      var self = this;\r\n      var modalEl = jqLite(self.modalEl);\r\n\r\n      // on iOS, clicks will sometimes bleed through/ghost click on underlying\r\n      // elements\r\n      $ionicClickBlock.show(600);\r\n      stack.remove(self);\r\n\r\n      self.el.classList.remove('active');\r\n      modalEl.addClass('ng-leave');\r\n\r\n      $timeout(function() {\r\n        if (self._isShown) return;\r\n        modalEl.addClass('ng-leave-active')\r\n               .removeClass('ng-enter ng-enter-active active');\r\n      }, 20, false);\r\n\r\n      self.$el.off('click');\r\n      self._isShown = false;\r\n      self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.hidden', self);\r\n      self._deregisterBackButton && self._deregisterBackButton();\r\n\r\n      ionic.views.Modal.prototype.hide.call(self);\r\n\r\n      // clean up event listeners\r\n      if (self.positionView) {\r\n        ionic.off('resize', self._onWindowResize, window);\r\n      }\r\n\r\n      return $timeout(function() {\r\n        $ionicBody.removeClass(self.viewType + '-open');\r\n        self.el.classList.add('hide');\r\n      }, self.hideDelay || 320);\r\n    },\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ionicModal#remove\r\n     * @description Remove this modal instance from the DOM and clean up.\r\n     * @returns {promise} A promise which is resolved when the modal is finished animating out.\r\n     */\r\n    remove: function() {\r\n      var self = this;\r\n      self.scope.$parent && self.scope.$parent.$broadcast(self.viewType + '.removed', self);\r\n\r\n      return self.hide().then(function() {\r\n        self.scope.$destroy();\r\n        self.$el.remove();\r\n      });\r\n    },\r\n\r\n    /**\r\n     * @ngdoc method\r\n     * @name ionicModal#isShown\r\n     * @returns boolean Whether this modal is currently shown.\r\n     */\r\n    isShown: function() {\r\n      return !!this._isShown;\r\n    }\r\n  });\r\n\r\n  var createModal = function(templateString, options) {\r\n    // Create a new scope for the modal\r\n    var scope = options.scope && options.scope.$new() || $rootScope.$new(true);\r\n\r\n    options.viewType = options.viewType || 'modal';\r\n\r\n    extend(scope, {\r\n      $hasHeader: false,\r\n      $hasSubheader: false,\r\n      $hasFooter: false,\r\n      $hasSubfooter: false,\r\n      $hasTabs: false,\r\n      $hasTabsTop: false\r\n    });\r\n\r\n    // Compile the template\r\n    var element = $compile('<ion-' + options.viewType + '>' + templateString + '</ion-' + options.viewType + '>')(scope);\r\n\r\n    options.$el = element;\r\n    options.el = element[0];\r\n    options.modalEl = options.el.querySelector('.' + options.viewType);\r\n    var modal = new ModalView(options);\r\n\r\n    modal.scope = scope;\r\n\r\n    // If this wasn't a defined scope, we can assign the viewType to the isolated scope\r\n    // we created\r\n    if (!options.scope) {\r\n      scope[ options.viewType ] = modal;\r\n    }\r\n\r\n    return modal;\r\n  };\r\n\r\n  var modalStack = [];\r\n  var stack = {\r\n    add: function(modal) {\r\n      modalStack.push(modal);\r\n    },\r\n    remove: function(modal) {\r\n      var index = modalStack.indexOf(modal);\r\n      if (index > -1 && index < modalStack.length) {\r\n        modalStack.splice(index, 1);\r\n      }\r\n    },\r\n    isHighest: function(modal) {\r\n      var index = modalStack.indexOf(modal);\r\n      return (index > -1 && index === modalStack.length - 1);\r\n    }\r\n  };\r\n\r\n  return {\r\n    /**\r\n     * @ngdoc method\r\n     * @name $ionicModal#fromTemplate\r\n     * @param {string} templateString The template string to use as the modal's\r\n     * content.\r\n     * @param {object} options Options to be passed {@link ionic.controller:ionicModal#initialize ionicModal#initialize} method.\r\n     * @returns {object} An instance of an {@link ionic.controller:ionicModal}\r\n     * controller.\r\n     */\r\n    fromTemplate: function(templateString, options) {\r\n      var modal = createModal(templateString, options || {});\r\n      return modal;\r\n    },\r\n    /**\r\n     * @ngdoc method\r\n     * @name $ionicModal#fromTemplateUrl\r\n     * @param {string} templateUrl The url to load the template from.\r\n     * @param {object} options Options to be passed {@link ionic.controller:ionicModal#initialize ionicModal#initialize} method.\r\n     * options object.\r\n     * @returns {promise} A promise that will be resolved with an instance of\r\n     * an {@link ionic.controller:ionicModal} controller.\r\n     */\r\n    fromTemplateUrl: function(url, options, _) {\r\n      var cb;\r\n      //Deprecated: allow a callback as second parameter. Now we return a promise.\r\n      if (angular.isFunction(options)) {\r\n        cb = options;\r\n        options = _;\r\n      }\r\n      return $ionicTemplateLoader.load(url).then(function(templateString) {\r\n        var modal = createModal(templateString, options || {});\r\n        cb && cb(modal);\r\n        return modal;\r\n      });\r\n    },\r\n\r\n    stack: stack\r\n  };\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/modal.js\n ** module id = 15\n ** module chunks = 0\n **/","\n/**\n * @ngdoc service\n * @name $ionicNavBarDelegate\n * @module ionic\n * @description\n * Delegate for controlling the {@link ionic.directive:ionNavBar} directive.\n *\n * @usage\n *\n * ```html\n * <body ng-controller=\"MyCtrl\">\n *   <ion-nav-bar>\n *     <button ng-click=\"setNavTitle('banana')\">\n *       Set title to banana!\n *     </button>\n *   </ion-nav-bar>\n * </body>\n * ```\n * ```js\n * function MyCtrl($scope, $ionicNavBarDelegate) {\n *   $scope.setNavTitle = function(title) {\n *     $ionicNavBarDelegate.title(title);\n *   }\n * }\n * ```\n */\nIonicModule\n.service('$ionicNavBarDelegate', ionic.DelegateService([\n  /**\n   * @ngdoc method\n   * @name $ionicNavBarDelegate#align\n   * @description Aligns the title with the buttons in a given direction.\n   * @param {string=} direction The direction to the align the title text towards.\n   * Available: 'left', 'right', 'center'. Default: 'center'.\n   */\n  'align',\n  /**\n   * @ngdoc method\n   * @name $ionicNavBarDelegate#showBackButton\n   * @description\n   * Set/get whether the {@link ionic.directive:ionNavBackButton} is shown\n   * (if it exists and there is a previous view that can be navigated to).\n   * @param {boolean=} show Whether to show the back button.\n   * @returns {boolean} Whether the back button is shown.\n   */\n  'showBackButton',\n  /**\n   * @ngdoc method\n   * @name $ionicNavBarDelegate#showBar\n   * @description\n   * Set/get whether the {@link ionic.directive:ionNavBar} is shown.\n   * @param {boolean} show Whether to show the bar.\n   * @returns {boolean} Whether the bar is shown.\n   */\n  'showBar',\n  /**\n   * @ngdoc method\n   * @name $ionicNavBarDelegate#title\n   * @description\n   * Set the title for the {@link ionic.directive:ionNavBar}.\n   * @param {string} title The new title to show.\n   */\n  'title',\n\n  // DEPRECATED, as of v1.0.0-beta14 -------\n  'changeTitle',\n  'setTitle',\n  'getTitle',\n  'back',\n  'getPreviousTitle'\n  // END DEPRECATED -------\n]));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/navBarDelegate.js\n ** module id = 16\n ** module chunks = 0\n **/","\nIonicModule\n.service('$ionicNavViewDelegate', ionic.DelegateService([\n  'clearCache'\n]));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/navViewDelegate.js\n ** module id = 17\n ** module chunks = 0\n **/","\n/**\n * @ngdoc service\n * @name $ionicPlatform\n * @module ionic\n * @description\n * An angular abstraction of {@link ionic.utility:ionic.Platform}.\n *\n * Used to detect the current platform, as well as do things like override the\n * Android back button in PhoneGap/Cordova.\n */\nIonicModule\n.constant('IONIC_BACK_PRIORITY', {\n  view: 100,\n  sideMenu: 150,\n  modal: 200,\n  actionSheet: 300,\n  popup: 400,\n  loading: 500\n})\n.provider('$ionicPlatform', function() {\n  return {\n    $get: ['$q', '$ionicScrollDelegate', function($q, $ionicScrollDelegate) {\n      var self = {\n\n        /**\n         * @ngdoc method\n         * @name $ionicPlatform#onHardwareBackButton\n         * @description\n         * Some platforms have a hardware back button, so this is one way to\n         * bind to it.\n         * @param {function} callback the callback to trigger when this event occurs\n         */\n        onHardwareBackButton: function(cb) {\n          ionic.Platform.ready(function() {\n            document.addEventListener('backbutton', cb, false);\n          });\n        },\n\n        /**\n         * @ngdoc method\n         * @name $ionicPlatform#offHardwareBackButton\n         * @description\n         * Remove an event listener for the backbutton.\n         * @param {function} callback The listener function that was\n         * originally bound.\n         */\n        offHardwareBackButton: function(fn) {\n          ionic.Platform.ready(function() {\n            document.removeEventListener('backbutton', fn);\n          });\n        },\n\n        /**\n         * @ngdoc method\n         * @name $ionicPlatform#registerBackButtonAction\n         * @description\n         * Register a hardware back button action. Only one action will execute\n         * when the back button is clicked, so this method decides which of\n         * the registered back button actions has the highest priority.\n         *\n         * For example, if an actionsheet is showing, the back button should\n         * close the actionsheet, but it should not also go back a page view\n         * or close a modal which may be open.\n         *\n         * The priorities for the existing back button hooks are as follows:\n         *   Return to previous view = 100\n         *   Close side menu = 150\n         *   Dismiss modal = 200\n         *   Close action sheet = 300\n         *   Dismiss popup = 400\n         *   Dismiss loading overlay = 500\n         *\n         * Your back button action will override each of the above actions\n         * whose priority is less than the priority you provide. For example,\n         * an action assigned a priority of 101 will override the 'return to\n         * previous view' action, but not any of the other actions.\n         *\n         * @param {function} callback Called when the back button is pressed,\n         * if this listener is the highest priority.\n         * @param {number} priority Only the highest priority will execute.\n         * @param {*=} actionId The id to assign this action. Default: a\n         * random unique id.\n         * @returns {function} A function that, when called, will deregister\n         * this backButtonAction.\n         */\n        $backButtonActions: {},\n        registerBackButtonAction: function(fn, priority, actionId) {\n\n          if (!self._hasBackButtonHandler) {\n            // add a back button listener if one hasn't been setup yet\n            self.$backButtonActions = {};\n            self.onHardwareBackButton(self.hardwareBackButtonClick);\n            self._hasBackButtonHandler = true;\n          }\n\n          var action = {\n            id: (actionId ? actionId : ionic.Utils.nextUid()),\n            priority: (priority ? priority : 0),\n            fn: fn\n          };\n          self.$backButtonActions[action.id] = action;\n\n          // return a function to de-register this back button action\n          return function() {\n            delete self.$backButtonActions[action.id];\n          };\n        },\n\n        /**\n         * @private\n         */\n        hardwareBackButtonClick: function(e) {\n          // loop through all the registered back button actions\n          // and only run the last one of the highest priority\n          var priorityAction, actionId;\n          for (actionId in self.$backButtonActions) {\n            if (!priorityAction || self.$backButtonActions[actionId].priority >= priorityAction.priority) {\n              priorityAction = self.$backButtonActions[actionId];\n            }\n          }\n          if (priorityAction) {\n            priorityAction.fn(e);\n            return priorityAction;\n          }\n        },\n\n        is: function(type) {\n          return ionic.Platform.is(type);\n        },\n\n        /**\n         * @ngdoc method\n         * @name $ionicPlatform#on\n         * @description\n         * Add Cordova event listeners, such as `pause`, `resume`, `volumedownbutton`, `batterylow`,\n         * `offline`, etc. More information about available event types can be found in\n         * [Cordova's event documentation](https://cordova.apache.org/docs/en/edge/cordova_events_events.md.html#Events).\n         * @param {string} type Cordova [event type](https://cordova.apache.org/docs/en/edge/cordova_events_events.md.html#Events).\n         * @param {function} callback Called when the Cordova event is fired.\n         * @returns {function} Returns a deregistration function to remove the event listener.\n         */\n        on: function(type, cb) {\n          ionic.Platform.ready(function() {\n            document.addEventListener(type, cb, false);\n          });\n          return function() {\n            ionic.Platform.ready(function() {\n              document.removeEventListener(type, cb);\n            });\n          };\n        },\n\n        /**\n         * @ngdoc method\n         * @name $ionicPlatform#ready\n         * @description\n         * Trigger a callback once the device is ready,\n         * or immediately if the device is already ready.\n         * @param {function=} callback The function to call.\n         * @returns {promise} A promise which is resolved when the device is ready.\n         */\n        ready: function(cb) {\n          var q = $q.defer();\n\n          ionic.Platform.ready(function() {\n            q.resolve();\n            cb && cb();\n          });\n\n          return q.promise;\n        }\n      };\n\n      window.addEventListener('statusTap', function() {\n        $ionicScrollDelegate.scrollTop(true);\n      });\n\n      return self;\n    }]\n  };\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/platform.js\n ** module id = 18\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicPopover\n * @module ionic\n * @description\n *\n * Related: {@link ionic.controller:ionicPopover ionicPopover controller}.\n *\n * The Popover is a view that floats above an apps content. Popovers provide an\n * easy way to present or gather information from the user and are\n * commonly used in the following situations:\n *\n * - Show more info about the current view\n * - Select a commonly used tool or configuration\n * - Present a list of actions to perform inside one of your views\n *\n * Put the content of the popover inside of an `<ion-popover-view>` element.\n *\n * @usage\n * ```html\n * <p>\n *   <button ng-click=\"openPopover($event)\">Open Popover</button>\n * </p>\n *\n * <script id=\"my-popover.html\" type=\"text/ng-template\">\n *   <ion-popover-view>\n *     <ion-header-bar>\n *       <h1 class=\"title\">My Popover Title</h1>\n *     </ion-header-bar>\n *     <ion-content>\n *       Hello!\n *     </ion-content>\n *   </ion-popover-view>\n * </script>\n * ```\n * ```js\n * angular.module('testApp', ['ionic'])\n * .controller('MyController', function($scope, $ionicPopover) {\n *\n *   // .fromTemplate() method\n *   var template = '<ion-popover-view><ion-header-bar> <h1 class=\"title\">My Popover Title</h1> </ion-header-bar> <ion-content> Hello! </ion-content></ion-popover-view>';\n *\n *   $scope.popover = $ionicPopover.fromTemplate(template, {\n *     scope: $scope\n *   });\n *\n *   // .fromTemplateUrl() method\n *   $ionicPopover.fromTemplateUrl('my-popover.html', {\n *     scope: $scope\n *   }).then(function(popover) {\n *     $scope.popover = popover;\n *   });\n *\n *\n *   $scope.openPopover = function($event) {\n *     $scope.popover.show($event);\n *   };\n *   $scope.closePopover = function() {\n *     $scope.popover.hide();\n *   };\n *   //Cleanup the popover when we're done with it!\n *   $scope.$on('$destroy', function() {\n *     $scope.popover.remove();\n *   });\n *   // Execute action on hide popover\n *   $scope.$on('popover.hidden', function() {\n *     // Execute action\n *   });\n *   // Execute action on remove popover\n *   $scope.$on('popover.removed', function() {\n *     // Execute action\n *   });\n * });\n * ```\n */\n\n\nIonicModule\n.factory('$ionicPopover', ['$ionicModal', '$ionicPosition', '$document', '$window',\nfunction($ionicModal, $ionicPosition, $document, $window) {\n\n  var POPOVER_BODY_PADDING = 6;\n\n  var POPOVER_OPTIONS = {\n    viewType: 'popover',\n    hideDelay: 1,\n    animation: 'none',\n    positionView: positionView\n  };\n\n  function positionView(target, popoverEle) {\n    var targetEle = jqLite(target.target || target);\n    var buttonOffset = $ionicPosition.offset(targetEle);\n    var popoverWidth = popoverEle.prop('offsetWidth');\n    var popoverHeight = popoverEle.prop('offsetHeight');\n    // Use innerWidth and innerHeight, because clientWidth and clientHeight\n    // doesn't work consistently for body on all platforms\n    var bodyWidth = $window.innerWidth;\n    var bodyHeight = $window.innerHeight;\n\n    var popoverCSS = {\n      left: buttonOffset.left + buttonOffset.width / 2 - popoverWidth / 2\n    };\n    var arrowEle = jqLite(popoverEle[0].querySelector('.popover-arrow'));\n\n    if (popoverCSS.left < POPOVER_BODY_PADDING) {\n      popoverCSS.left = POPOVER_BODY_PADDING;\n    } else if (popoverCSS.left + popoverWidth + POPOVER_BODY_PADDING > bodyWidth) {\n      popoverCSS.left = bodyWidth - popoverWidth - POPOVER_BODY_PADDING;\n    }\n\n    // If the popover when popped down stretches past bottom of screen,\n    // make it pop up if there's room above\n    if (buttonOffset.top + buttonOffset.height + popoverHeight > bodyHeight &&\n        buttonOffset.top - popoverHeight > 0) {\n      popoverCSS.top = buttonOffset.top - popoverHeight;\n      popoverEle.addClass('popover-bottom');\n    } else {\n      popoverCSS.top = buttonOffset.top + buttonOffset.height;\n      popoverEle.removeClass('popover-bottom');\n    }\n\n    arrowEle.css({\n      left: buttonOffset.left + buttonOffset.width / 2 -\n        arrowEle.prop('offsetWidth') / 2 - popoverCSS.left + 'px'\n    });\n\n    popoverEle.css({\n      top: popoverCSS.top + 'px',\n      left: popoverCSS.left + 'px',\n      marginLeft: '0',\n      opacity: '1'\n    });\n\n  }\n\n  /**\n   * @ngdoc controller\n   * @name ionicPopover\n   * @module ionic\n   * @description\n   * Instantiated by the {@link ionic.service:$ionicPopover} service.\n   *\n   * Be sure to call [remove()](#remove) when you are done with each popover\n   * to clean it up and avoid memory leaks.\n   *\n   * Note: a popover will broadcast 'popover.shown', 'popover.hidden', and 'popover.removed' events from its originating\n   * scope, passing in itself as an event argument. Both the popover.removed and popover.hidden events are\n   * called when the popover is removed.\n   */\n\n  /**\n   * @ngdoc method\n   * @name ionicPopover#initialize\n   * @description Creates a new popover controller instance.\n   * @param {object} options An options object with the following properties:\n   *  - `{object=}` `scope` The scope to be a child of.\n   *    Default: creates a child of $rootScope.\n   *  - `{boolean=}` `focusFirstInput` Whether to autofocus the first input of\n   *    the popover when shown.  Default: false.\n   *  - `{boolean=}` `backdropClickToClose` Whether to close the popover on clicking the backdrop.\n   *    Default: true.\n   *  - `{boolean=}` `hardwareBackButtonClose` Whether the popover can be closed using the hardware\n   *    back button on Android and similar devices.  Default: true.\n   */\n\n  /**\n   * @ngdoc method\n   * @name ionicPopover#show\n   * @description Show this popover instance.\n   * @param {$event} $event The $event or target element which the popover should align\n   * itself next to.\n   * @returns {promise} A promise which is resolved when the popover is finished animating in.\n   */\n\n  /**\n   * @ngdoc method\n   * @name ionicPopover#hide\n   * @description Hide this popover instance.\n   * @returns {promise} A promise which is resolved when the popover is finished animating out.\n   */\n\n  /**\n   * @ngdoc method\n   * @name ionicPopover#remove\n   * @description Remove this popover instance from the DOM and clean up.\n   * @returns {promise} A promise which is resolved when the popover is finished animating out.\n   */\n\n  /**\n   * @ngdoc method\n   * @name ionicPopover#isShown\n   * @returns boolean Whether this popover is currently shown.\n   */\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $ionicPopover#fromTemplate\n     * @param {string} templateString The template string to use as the popovers's\n     * content.\n     * @param {object} options Options to be passed to the initialize method.\n     * @returns {object} An instance of an {@link ionic.controller:ionicPopover}\n     * controller (ionicPopover is built on top of $ionicPopover).\n     */\n    fromTemplate: function(templateString, options) {\n      return $ionicModal.fromTemplate(templateString, ionic.Utils.extend({}, POPOVER_OPTIONS, options));\n    },\n    /**\n     * @ngdoc method\n     * @name $ionicPopover#fromTemplateUrl\n     * @param {string} templateUrl The url to load the template from.\n     * @param {object} options Options to be passed to the initialize method.\n     * @returns {promise} A promise that will be resolved with an instance of\n     * an {@link ionic.controller:ionicPopover} controller (ionicPopover is built on top of $ionicPopover).\n     */\n    fromTemplateUrl: function(url, options) {\n      return $ionicModal.fromTemplateUrl(url, ionic.Utils.extend({}, POPOVER_OPTIONS, options));\n    }\n  };\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/popover.js\n ** module id = 19\n ** module chunks = 0\n **/","\nvar POPUP_TPL =\n  '<div class=\"popup-container\" ng-class=\"cssClass\">' +\n    '<div class=\"popup\">' +\n      '<div class=\"popup-head\">' +\n        '<h3 class=\"popup-title\" ng-bind-html=\"title\"></h3>' +\n        '<h5 class=\"popup-sub-title\" ng-bind-html=\"subTitle\" ng-if=\"subTitle\"></h5>' +\n      '</div>' +\n      '<div class=\"popup-body\">' +\n      '</div>' +\n      '<div class=\"popup-buttons\" ng-show=\"buttons.length\">' +\n        '<button ng-repeat=\"button in buttons\" ng-click=\"$buttonTapped(button, $event)\" class=\"button\" ng-class=\"button.type || \\'button-default\\'\" ng-bind-html=\"button.text\"></button>' +\n      '</div>' +\n    '</div>' +\n  '</div>';\n\n/**\n * @ngdoc service\n * @name $ionicPopup\n * @module ionic\n * @restrict E\n * @codepen zkmhJ\n * @description\n *\n * The Ionic Popup service allows programmatically creating and showing popup\n * windows that require the user to respond in order to continue.\n *\n * The popup system has support for more flexible versions of the built in `alert()`, `prompt()`,\n * and `confirm()` functions that users are used to, in addition to allowing popups with completely\n * custom content and look.\n *\n * An input can be given an `autofocus` attribute so it automatically receives focus when\n * the popup first shows. However, depending on certain use-cases this can cause issues with\n * the tap/click system, which is why Ionic prefers using the `autofocus` attribute as\n * an opt-in feature and not the default.\n *\n * @usage\n * A few basic examples, see below for details about all of the options available.\n *\n * ```js\n *angular.module('mySuperApp', ['ionic'])\n *.controller('PopupCtrl',function($scope, $ionicPopup, $timeout) {\n *\n * // Triggered on a button click, or some other target\n * $scope.showPopup = function() {\n *   $scope.data = {};\n *\n *   // An elaborate, custom popup\n *   var myPopup = $ionicPopup.show({\n *     template: '<input type=\"password\" ng-model=\"data.wifi\">',\n *     title: 'Enter Wi-Fi Password',\n *     subTitle: 'Please use normal things',\n *     scope: $scope,\n *     buttons: [\n *       { text: 'Cancel' },\n *       {\n *         text: '<b>Save</b>',\n *         type: 'button-positive',\n *         onTap: function(e) {\n *           if (!$scope.data.wifi) {\n *             //don't allow the user to close unless he enters wifi password\n *             e.preventDefault();\n *           } else {\n *             return $scope.data.wifi;\n *           }\n *         }\n *       }\n *     ]\n *   });\n *\n *   myPopup.then(function(res) {\n *     console.log('Tapped!', res);\n *   });\n *\n *   $timeout(function() {\n *      myPopup.close(); //close the popup after 3 seconds for some reason\n *   }, 3000);\n *  };\n *\n *  // A confirm dialog\n *  $scope.showConfirm = function() {\n *    var confirmPopup = $ionicPopup.confirm({\n *      title: 'Consume Ice Cream',\n *      template: 'Are you sure you want to eat this ice cream?'\n *    });\n *\n *    confirmPopup.then(function(res) {\n *      if(res) {\n *        console.log('You are sure');\n *      } else {\n *        console.log('You are not sure');\n *      }\n *    });\n *  };\n *\n *  // An alert dialog\n *  $scope.showAlert = function() {\n *    var alertPopup = $ionicPopup.alert({\n *      title: 'Don\\'t eat that!',\n *      template: 'It might taste good'\n *    });\n *\n *    alertPopup.then(function(res) {\n *      console.log('Thank you for not eating my delicious ice cream cone');\n *    });\n *  };\n *});\n *```\n */\n\nIonicModule\n.factory('$ionicPopup', [\n  '$ionicTemplateLoader',\n  '$ionicBackdrop',\n  '$q',\n  '$timeout',\n  '$rootScope',\n  '$ionicBody',\n  '$compile',\n  '$ionicPlatform',\n  '$ionicModal',\n  'IONIC_BACK_PRIORITY',\nfunction($ionicTemplateLoader, $ionicBackdrop, $q, $timeout, $rootScope, $ionicBody, $compile, $ionicPlatform, $ionicModal, IONIC_BACK_PRIORITY) {\n  //TODO allow this to be configured\n  var config = {\n    stackPushDelay: 75\n  };\n  var popupStack = [];\n\n  var $ionicPopup = {\n    /**\n     * @ngdoc method\n     * @description\n     * Show a complex popup. This is the master show function for all popups.\n     *\n     * A complex popup has a `buttons` array, with each button having a `text` and `type`\n     * field, in addition to an `onTap` function.  The `onTap` function, called when\n     * the corresponding button on the popup is tapped, will by default close the popup\n     * and resolve the popup promise with its return value.  If you wish to prevent the\n     * default and keep the popup open on button tap, call `event.preventDefault()` on the\n     * passed in tap event.  Details below.\n     *\n     * @name $ionicPopup#show\n     * @param {object} options The options for the new popup, of the form:\n     *\n     * ```\n     * {\n     *   title: '', // String. The title of the popup.\n     *   cssClass: '', // String, The custom CSS class name\n     *   subTitle: '', // String (optional). The sub-title of the popup.\n     *   template: '', // String (optional). The html template to place in the popup body.\n     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup   body.\n     *   scope: null, // Scope (optional). A scope to link to the popup content.\n     *   buttons: [{ // Array[Object] (optional). Buttons to place in the popup footer.\n     *     text: 'Cancel',\n     *     type: 'button-default',\n     *     onTap: function(e) {\n     *       // e.preventDefault() will stop the popup from closing when tapped.\n     *       e.preventDefault();\n     *     }\n     *   }, {\n     *     text: 'OK',\n     *     type: 'button-positive',\n     *     onTap: function(e) {\n     *       // Returning a value will cause the promise to resolve with the given value.\n     *       return scope.data.response;\n     *     }\n     *   }]\n     * }\n     * ```\n     *\n     * @returns {object} A promise which is resolved when the popup is closed. Has an additional\n     * `close` function, which can be used to programmatically close the popup.\n     */\n    show: showPopup,\n\n    /**\n     * @ngdoc method\n     * @name $ionicPopup#alert\n     * @description Show a simple alert popup with a message and one button that the user can\n     * tap to close the popup.\n     *\n     * @param {object} options The options for showing the alert, of the form:\n     *\n     * ```\n     * {\n     *   title: '', // String. The title of the popup.\n     *   cssClass: '', // String, The custom CSS class name\n     *   subTitle: '', // String (optional). The sub-title of the popup.\n     *   template: '', // String (optional). The html template to place in the popup body.\n     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup   body.\n     *   okText: '', // String (default: 'OK'). The text of the OK button.\n     *   okType: '', // String (default: 'button-positive'). The type of the OK button.\n     * }\n     * ```\n     *\n     * @returns {object} A promise which is resolved when the popup is closed. Has one additional\n     * function `close`, which can be called with any value to programmatically close the popup\n     * with the given value.\n     */\n    alert: showAlert,\n\n    /**\n     * @ngdoc method\n     * @name $ionicPopup#confirm\n     * @description\n     * Show a simple confirm popup with a Cancel and OK button.\n     *\n     * Resolves the promise with true if the user presses the OK button, and false if the\n     * user presses the Cancel button.\n     *\n     * @param {object} options The options for showing the confirm popup, of the form:\n     *\n     * ```\n     * {\n     *   title: '', // String. The title of the popup.\n     *   cssClass: '', // String, The custom CSS class name\n     *   subTitle: '', // String (optional). The sub-title of the popup.\n     *   template: '', // String (optional). The html template to place in the popup body.\n     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup   body.\n     *   cancelText: '', // String (default: 'Cancel'). The text of the Cancel button.\n     *   cancelType: '', // String (default: 'button-default'). The type of the Cancel button.\n     *   okText: '', // String (default: 'OK'). The text of the OK button.\n     *   okType: '', // String (default: 'button-positive'). The type of the OK button.\n     * }\n     * ```\n     *\n     * @returns {object} A promise which is resolved when the popup is closed. Has one additional\n     * function `close`, which can be called with any value to programmatically close the popup\n     * with the given value.\n     */\n    confirm: showConfirm,\n\n    /**\n     * @ngdoc method\n     * @name $ionicPopup#prompt\n     * @description Show a simple prompt popup, which has an input, OK button, and Cancel button.\n     * Resolves the promise with the value of the input if the user presses OK, and with undefined\n     * if the user presses Cancel.\n     *\n     * ```javascript\n     *  $ionicPopup.prompt({\n     *    title: 'Password Check',\n     *    template: 'Enter your secret password',\n     *    inputType: 'password',\n     *    inputPlaceholder: 'Your password'\n     *  }).then(function(res) {\n     *    console.log('Your password is', res);\n     *  });\n     * ```\n     * @param {object} options The options for showing the prompt popup, of the form:\n     *\n     * ```\n     * {\n     *   title: '', // String. The title of the popup.\n     *   cssClass: '', // String, The custom CSS class name\n     *   subTitle: '', // String (optional). The sub-title of the popup.\n     *   template: '', // String (optional). The html template to place in the popup body.\n     *   templateUrl: '', // String (optional). The URL of an html template to place in the popup body.\n     *   inputType: // String (default: 'text'). The type of input to use\n     *   defaultText: // String (default: ''). The initial value placed into the input.\n     *   maxLength: // Integer (default: null). Specify a maxlength attribute for the input.\n     *   inputPlaceholder: // String (default: ''). A placeholder to use for the input.\n     *   cancelText: // String (default: 'Cancel'. The text of the Cancel button.\n     *   cancelType: // String (default: 'button-default'). The type of the Cancel button.\n     *   okText: // String (default: 'OK'). The text of the OK button.\n     *   okType: // String (default: 'button-positive'). The type of the OK button.\n     * }\n     * ```\n     *\n     * @returns {object} A promise which is resolved when the popup is closed. Has one additional\n     * function `close`, which can be called with any value to programmatically close the popup\n     * with the given value.\n     */\n    prompt: showPrompt,\n    /**\n     * @private for testing\n     */\n    _createPopup: createPopup,\n    _popupStack: popupStack\n  };\n\n  return $ionicPopup;\n\n  function createPopup(options) {\n    options = extend({\n      scope: null,\n      title: '',\n      buttons: []\n    }, options || {});\n\n    var self = {};\n    self.scope = (options.scope || $rootScope).$new();\n    self.element = jqLite(POPUP_TPL);\n    self.responseDeferred = $q.defer();\n\n    $ionicBody.get().appendChild(self.element[0]);\n    $compile(self.element)(self.scope);\n\n    extend(self.scope, {\n      title: options.title,\n      buttons: options.buttons,\n      subTitle: options.subTitle,\n      cssClass: options.cssClass,\n      $buttonTapped: function(button, event) {\n        var result = (button.onTap || noop).apply(self, [event]);\n        event = event.originalEvent || event; //jquery events\n\n        if (!event.defaultPrevented) {\n          self.responseDeferred.resolve(result);\n        }\n      }\n    });\n\n    $q.when(\n      options.templateUrl ?\n      $ionicTemplateLoader.load(options.templateUrl) :\n        (options.template || options.content || '')\n    ).then(function(template) {\n      var popupBody = jqLite(self.element[0].querySelector('.popup-body'));\n      if (template) {\n        popupBody.html(template);\n        $compile(popupBody.contents())(self.scope);\n      } else {\n        popupBody.remove();\n      }\n    });\n\n    self.show = function() {\n      if (self.isShown || self.removed) return;\n\n      $ionicModal.stack.add(self);\n      self.isShown = true;\n      ionic.requestAnimationFrame(function() {\n        //if hidden while waiting for raf, don't show\n        if (!self.isShown) return;\n\n        self.element.removeClass('popup-hidden');\n        self.element.addClass('popup-showing active');\n        focusInput(self.element);\n      });\n    };\n\n    self.hide = function(callback) {\n      callback = callback || noop;\n      if (!self.isShown) return callback();\n\n      $ionicModal.stack.remove(self);\n      self.isShown = false;\n      self.element.removeClass('active');\n      self.element.addClass('popup-hidden');\n      $timeout(callback, 250, false);\n    };\n\n    self.remove = function() {\n      if (self.removed) return;\n\n      self.hide(function() {\n        self.element.remove();\n        self.scope.$destroy();\n      });\n\n      self.removed = true;\n    };\n\n    return self;\n  }\n\n  function onHardwareBackButton() {\n    var last = popupStack[popupStack.length - 1];\n    last && last.responseDeferred.resolve();\n  }\n\n  function showPopup(options) {\n    var popup = $ionicPopup._createPopup(options);\n    var showDelay = 0;\n\n    if (popupStack.length > 0) {\n      showDelay = config.stackPushDelay;\n      $timeout(popupStack[popupStack.length - 1].hide, showDelay, false);\n    } else {\n      //Add popup-open & backdrop if this is first popup\n      $ionicBody.addClass('popup-open');\n      $ionicBackdrop.retain();\n      //only show the backdrop on the first popup\n      $ionicPopup._backButtonActionDone = $ionicPlatform.registerBackButtonAction(\n        onHardwareBackButton,\n        IONIC_BACK_PRIORITY.popup\n      );\n    }\n\n    // Expose a 'close' method on the returned promise\n    popup.responseDeferred.promise.close = function popupClose(result) {\n      if (!popup.removed) popup.responseDeferred.resolve(result);\n    };\n    //DEPRECATED: notify the promise with an object with a close method\n    popup.responseDeferred.notify({ close: popup.responseDeferred.close });\n\n    doShow();\n\n    return popup.responseDeferred.promise;\n\n    function doShow() {\n      popupStack.push(popup);\n      $timeout(popup.show, showDelay, false);\n\n      popup.responseDeferred.promise.then(function(result) {\n        var index = popupStack.indexOf(popup);\n        if (index !== -1) {\n          popupStack.splice(index, 1);\n        }\n\n        popup.remove();\n\n        if (popupStack.length > 0) {\n          popupStack[popupStack.length - 1].show();\n        } else {\n          $ionicBackdrop.release();\n          //Remove popup-open & backdrop if this is last popup\n          $timeout(function() {\n            // wait to remove this due to a 300ms delay native\n            // click which would trigging whatever was underneath this\n            if (!popupStack.length) {\n              $ionicBody.removeClass('popup-open');\n            }\n          }, 400, false);\n          ($ionicPopup._backButtonActionDone || noop)();\n        }\n\n\n        return result;\n      });\n\n    }\n\n  }\n\n  function focusInput(element) {\n    var focusOn = element[0].querySelector('[autofocus]');\n    if (focusOn) {\n      focusOn.focus();\n    }\n  }\n\n  function showAlert(opts) {\n    return showPopup(extend({\n      buttons: [{\n        text: opts.okText || 'OK',\n        type: opts.okType || 'button-positive',\n        onTap: function() {\n          return true;\n        }\n      }]\n    }, opts || {}));\n  }\n\n  function showConfirm(opts) {\n    return showPopup(extend({\n      buttons: [{\n        text: opts.cancelText || 'Cancel',\n        type: opts.cancelType || 'button-default',\n        onTap: function() { return false; }\n      }, {\n        text: opts.okText || 'OK',\n        type: opts.okType || 'button-positive',\n        onTap: function() { return true; }\n      }]\n    }, opts || {}));\n  }\n\n  function showPrompt(opts) {\n    var scope = $rootScope.$new(true);\n    scope.data = {};\n    scope.data.fieldtype = opts.inputType ? opts.inputType : 'text';\n    scope.data.response = opts.defaultText ? opts.defaultText : '';\n    scope.data.placeholder = opts.inputPlaceholder ? opts.inputPlaceholder : '';\n    scope.data.maxlength = opts.maxLength ? parseInt(opts.maxLength) : '';\n    var text = '';\n    if (opts.template && /<[a-z][\\s\\S]*>/i.test(opts.template) === false) {\n      text = '<span>' + opts.template + '</span>';\n      delete opts.template;\n    }\n    return showPopup(extend({\n      template: text + '<input ng-model=\"data.response\" '\n        + 'type=\"{{ data.fieldtype }}\"'\n        + 'maxlength=\"{{ data.maxlength }}\"'\n        + 'placeholder=\"{{ data.placeholder }}\"'\n        + '>',\n      scope: scope,\n      buttons: [{\n        text: opts.cancelText || 'Cancel',\n        type: opts.cancelType || 'button-default',\n        onTap: function() {}\n      }, {\n        text: opts.okText || 'OK',\n        type: opts.okType || 'button-positive',\n        onTap: function() {\n          return scope.data.response || '';\n        }\n      }]\n    }, opts || {}));\n  }\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/popup.js\n ** module id = 20\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicPosition\n * @module ionic\n * @description\n * A set of utility methods that can be use to retrieve position of DOM elements.\n * It is meant to be used where we need to absolute-position DOM elements in\n * relation to other, existing elements (this is the case for tooltips, popovers, etc.).\n *\n * Adapted from [AngularUI Bootstrap](https://github.com/angular-ui/bootstrap/blob/master/src/position/position.js),\n * ([license](https://github.com/angular-ui/bootstrap/blob/master/LICENSE))\n */\nIonicModule\n.factory('$ionicPosition', ['$document', '$window', function($document, $window) {\n\n  function getStyle(el, cssprop) {\n    if (el.currentStyle) { //IE\n      return el.currentStyle[cssprop];\n    } else if ($window.getComputedStyle) {\n      return $window.getComputedStyle(el)[cssprop];\n    }\n    // finally try and get inline style\n    return el.style[cssprop];\n  }\n\n  /**\n   * Checks if a given element is statically positioned\n   * @param element - raw DOM element\n   */\n  function isStaticPositioned(element) {\n    return (getStyle(element, 'position') || 'static') === 'static';\n  }\n\n  /**\n   * returns the closest, non-statically positioned parentOffset of a given element\n   * @param element\n   */\n  var parentOffsetEl = function(element) {\n    var docDomEl = $document[0];\n    var offsetParent = element.offsetParent || docDomEl;\n    while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {\n      offsetParent = offsetParent.offsetParent;\n    }\n    return offsetParent || docDomEl;\n  };\n\n  return {\n    /**\n     * @ngdoc method\n     * @name $ionicPosition#position\n     * @description Get the current coordinates of the element, relative to the offset parent.\n     * Read-only equivalent of [jQuery's position function](http://api.jquery.com/position/).\n     * @param {element} element The element to get the position of.\n     * @returns {object} Returns an object containing the properties top, left, width and height.\n     */\n    position: function(element) {\n      var elBCR = this.offset(element);\n      var offsetParentBCR = { top: 0, left: 0 };\n      var offsetParentEl = parentOffsetEl(element[0]);\n      if (offsetParentEl != $document[0]) {\n        offsetParentBCR = this.offset(jqLite(offsetParentEl));\n        offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;\n        offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;\n      }\n\n      var boundingClientRect = element[0].getBoundingClientRect();\n      return {\n        width: boundingClientRect.width || element.prop('offsetWidth'),\n        height: boundingClientRect.height || element.prop('offsetHeight'),\n        top: elBCR.top - offsetParentBCR.top,\n        left: elBCR.left - offsetParentBCR.left\n      };\n    },\n\n    /**\n     * @ngdoc method\n     * @name $ionicPosition#offset\n     * @description Get the current coordinates of the element, relative to the document.\n     * Read-only equivalent of [jQuery's offset function](http://api.jquery.com/offset/).\n     * @param {element} element The element to get the offset of.\n     * @returns {object} Returns an object containing the properties top, left, width and height.\n     */\n    offset: function(element) {\n      var boundingClientRect = element[0].getBoundingClientRect();\n      return {\n        width: boundingClientRect.width || element.prop('offsetWidth'),\n        height: boundingClientRect.height || element.prop('offsetHeight'),\n        top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),\n        left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)\n      };\n    }\n\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/position.js\n ** module id = 21\n ** module chunks = 0\n **/","\n/**\n * @ngdoc service\n * @name $ionicScrollDelegate\n * @module ionic\n * @description\n * Delegate for controlling scrollViews (created by\n * {@link ionic.directive:ionContent} and\n * {@link ionic.directive:ionScroll} directives).\n *\n * Methods called directly on the $ionicScrollDelegate service will control all scroll\n * views.  Use the {@link ionic.service:$ionicScrollDelegate#$getByHandle $getByHandle}\n * method to control specific scrollViews.\n *\n * @usage\n *\n * ```html\n * <body ng-controller=\"MainCtrl\">\n *   <ion-content>\n *     <button ng-click=\"scrollTop()\">Scroll to Top!</button>\n *   </ion-content>\n * </body>\n * ```\n * ```js\n * function MainCtrl($scope, $ionicScrollDelegate) {\n *   $scope.scrollTop = function() {\n *     $ionicScrollDelegate.scrollTop();\n *   };\n * }\n * ```\n *\n * Example of advanced usage, with two scroll areas using `delegate-handle`\n * for fine control.\n *\n * ```html\n * <body ng-controller=\"MainCtrl\">\n *   <ion-content delegate-handle=\"mainScroll\">\n *     <button ng-click=\"scrollMainToTop()\">\n *       Scroll content to top!\n *     </button>\n *     <ion-scroll delegate-handle=\"small\" style=\"height: 100px;\">\n *       <button ng-click=\"scrollSmallToTop()\">\n *         Scroll small area to top!\n *       </button>\n *     </ion-scroll>\n *   </ion-content>\n * </body>\n * ```\n * ```js\n * function MainCtrl($scope, $ionicScrollDelegate) {\n *   $scope.scrollMainToTop = function() {\n *     $ionicScrollDelegate.$getByHandle('mainScroll').scrollTop();\n *   };\n *   $scope.scrollSmallToTop = function() {\n *     $ionicScrollDelegate.$getByHandle('small').scrollTop();\n *   };\n * }\n * ```\n */\nIonicModule\n.service('$ionicScrollDelegate', ionic.DelegateService([\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#resize\n   * @description Tell the scrollView to recalculate the size of its container.\n   */\n  'resize',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#scrollTop\n   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n   */\n  'scrollTop',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#scrollBottom\n   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n   */\n  'scrollBottom',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#scrollTo\n   * @param {number} left The x-value to scroll to.\n   * @param {number} top The y-value to scroll to.\n   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n   */\n  'scrollTo',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#scrollBy\n   * @param {number} left The x-offset to scroll by.\n   * @param {number} top The y-offset to scroll by.\n   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n   */\n  'scrollBy',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#zoomTo\n   * @param {number} level Level to zoom to.\n   * @param {boolean=} animate Whether to animate the zoom.\n   * @param {number=} originLeft Zoom in at given left coordinate.\n   * @param {number=} originTop Zoom in at given top coordinate.\n   */\n  'zoomTo',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#zoomBy\n   * @param {number} factor The factor to zoom by.\n   * @param {boolean=} animate Whether to animate the zoom.\n   * @param {number=} originLeft Zoom in at given left coordinate.\n   * @param {number=} originTop Zoom in at given top coordinate.\n   */\n  'zoomBy',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#getScrollPosition\n   * @returns {object} The scroll position of this view, with the following properties:\n   *  - `{number}` `left` The distance the user has scrolled from the left (starts at 0).\n   *  - `{number}` `top` The distance the user has scrolled from the top (starts at 0).\n   */\n  'getScrollPosition',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#anchorScroll\n   * @description Tell the scrollView to scroll to the element with an id\n   * matching window.location.hash.\n   *\n   * If no matching element is found, it will scroll to top.\n   *\n   * @param {boolean=} shouldAnimate Whether the scroll should animate.\n   */\n  'anchorScroll',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#freezeScroll\n   * @description Does not allow this scroll view to scroll either x or y.\n   * @param {boolean=} shouldFreeze Should this scroll view be prevented from scrolling or not.\n   * @returns {boolean} If the scroll view is being prevented from scrolling or not.\n   */\n  'freezeScroll',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#freezeAllScrolls\n   * @description Does not allow any of the app's scroll views to scroll either x or y.\n   * @param {boolean=} shouldFreeze Should all app scrolls be prevented from scrolling or not.\n   */\n  'freezeAllScrolls',\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#getScrollView\n   * @returns {object} The scrollView associated with this delegate.\n   */\n  'getScrollView'\n  /**\n   * @ngdoc method\n   * @name $ionicScrollDelegate#$getByHandle\n   * @param {string} handle\n   * @returns `delegateInstance` A delegate instance that controls only the\n   * scrollViews with `delegate-handle` matching the given handle.\n   *\n   * Example: `$ionicScrollDelegate.$getByHandle('my-handle').scrollTop();`\n   */\n]));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/scrollDelegate.js\n ** module id = 22\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicSideMenuDelegate\n * @module ionic\n *\n * @description\n * Delegate for controlling the {@link ionic.directive:ionSideMenus} directive.\n *\n * Methods called directly on the $ionicSideMenuDelegate service will control all side\n * menus.  Use the {@link ionic.service:$ionicSideMenuDelegate#$getByHandle $getByHandle}\n * method to control specific ionSideMenus instances.\n *\n * @usage\n *\n * ```html\n * <body ng-controller=\"MainCtrl\">\n *   <ion-side-menus>\n *     <ion-side-menu-content>\n *       Content!\n *       <button ng-click=\"toggleLeftSideMenu()\">\n *         Toggle Left Side Menu\n *       </button>\n *     </ion-side-menu-content>\n *     <ion-side-menu side=\"left\">\n *       Left Menu!\n *     <ion-side-menu>\n *   </ion-side-menus>\n * </body>\n * ```\n * ```js\n * function MainCtrl($scope, $ionicSideMenuDelegate) {\n *   $scope.toggleLeftSideMenu = function() {\n *     $ionicSideMenuDelegate.toggleLeft();\n *   };\n * }\n * ```\n */\nIonicModule\n.service('$ionicSideMenuDelegate', ionic.DelegateService([\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#toggleLeft\n   * @description Toggle the left side menu (if it exists).\n   * @param {boolean=} isOpen Whether to open or close the menu.\n   * Default: Toggles the menu.\n   */\n  'toggleLeft',\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#toggleRight\n   * @description Toggle the right side menu (if it exists).\n   * @param {boolean=} isOpen Whether to open or close the menu.\n   * Default: Toggles the menu.\n   */\n  'toggleRight',\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#getOpenRatio\n   * @description Gets the ratio of open amount over menu width. For example, a\n   * menu of width 100 that is opened by 50 pixels is 50% opened, and would return\n   * a ratio of 0.5.\n   *\n   * @returns {float} 0 if nothing is open, between 0 and 1 if left menu is\n   * opened/opening, and between 0 and -1 if right menu is opened/opening.\n   */\n  'getOpenRatio',\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#isOpen\n   * @returns {boolean} Whether either the left or right menu is currently opened.\n   */\n  'isOpen',\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#isOpenLeft\n   * @returns {boolean} Whether the left menu is currently opened.\n   */\n  'isOpenLeft',\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#isOpenRight\n   * @returns {boolean} Whether the right menu is currently opened.\n   */\n  'isOpenRight',\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#canDragContent\n   * @param {boolean=} canDrag Set whether the content can or cannot be dragged to open\n   * side menus.\n   * @returns {boolean} Whether the content can be dragged to open side menus.\n   */\n  'canDragContent',\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#edgeDragThreshold\n   * @param {boolean|number=} value Set whether the content drag can only start if it is below a certain threshold distance from the edge of the screen. Accepts three different values:\n   *  - If a non-zero number is given, that many pixels is used as the maximum allowed distance from the edge that starts dragging the side menu.\n   *  - If true is given, the default number of pixels (25) is used as the maximum allowed distance.\n   *  - If false or 0 is given, the edge drag threshold is disabled, and dragging from anywhere on the content is allowed.\n   * @returns {boolean} Whether the drag can start only from within the edge of screen threshold.\n   */\n  'edgeDragThreshold'\n  /**\n   * @ngdoc method\n   * @name $ionicSideMenuDelegate#$getByHandle\n   * @param {string} handle\n   * @returns `delegateInstance` A delegate instance that controls only the\n   * {@link ionic.directive:ionSideMenus} directives with `delegate-handle` matching\n   * the given handle.\n   *\n   * Example: `$ionicSideMenuDelegate.$getByHandle('my-handle').toggleLeft();`\n   */\n]));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/sideMenuDelegate.js\n ** module id = 23\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicSlideBoxDelegate\n * @module ionic\n * @description\n * Delegate that controls the {@link ionic.directive:ionSlideBox} directive.\n *\n * Methods called directly on the $ionicSlideBoxDelegate service will control all slide boxes.  Use the {@link ionic.service:$ionicSlideBoxDelegate#$getByHandle $getByHandle}\n * method to control specific slide box instances.\n *\n * @usage\n *\n * ```html\n * <ion-view>\n *   <ion-slide-box>\n *     <ion-slide>\n *       <div class=\"box blue\">\n *         <button ng-click=\"nextSlide()\">Next slide!</button>\n *       </div>\n *     </ion-slide>\n *     <ion-slide>\n *       <div class=\"box red\">\n *         Slide 2!\n *       </div>\n *     </ion-slide>\n *   </ion-slide-box>\n * </ion-view>\n * ```\n * ```js\n * function MyCtrl($scope, $ionicSlideBoxDelegate) {\n *   $scope.nextSlide = function() {\n *     $ionicSlideBoxDelegate.next();\n *   }\n * }\n * ```\n */\nIonicModule\n.service('$ionicSlideBoxDelegate', ionic.DelegateService([\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#update\n   * @description\n   * Update the slidebox (for example if using Angular with ng-repeat,\n   * resize it for the elements inside).\n   */\n  'update',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#slide\n   * @param {number} to The index to slide to.\n   * @param {number=} speed The number of milliseconds the change should take.\n   */\n  'slide',\n  'select',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#enableSlide\n   * @param {boolean=} shouldEnable Whether to enable sliding the slidebox.\n   * @returns {boolean} Whether sliding is enabled.\n   */\n  'enableSlide',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#previous\n   * @param {number=} speed The number of milliseconds the change should take.\n   * @description Go to the previous slide. Wraps around if at the beginning.\n   */\n  'previous',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#next\n   * @param {number=} speed The number of milliseconds the change should take.\n   * @description Go to the next slide. Wraps around if at the end.\n   */\n  'next',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#stop\n   * @description Stop sliding. The slideBox will not move again until\n   * explicitly told to do so.\n   */\n  'stop',\n  'autoPlay',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#start\n   * @description Start sliding again if the slideBox was stopped.\n   */\n  'start',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#currentIndex\n   * @returns number The index of the current slide.\n   */\n  'currentIndex',\n  'selected',\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#slidesCount\n   * @returns number The number of slides there are currently.\n   */\n  'slidesCount',\n  'count',\n  'loop'\n  /**\n   * @ngdoc method\n   * @name $ionicSlideBoxDelegate#$getByHandle\n   * @param {string} handle\n   * @returns `delegateInstance` A delegate instance that controls only the\n   * {@link ionic.directive:ionSlideBox} directives with `delegate-handle` matching\n   * the given handle.\n   *\n   * Example: `$ionicSlideBoxDelegate.$getByHandle('my-handle').stop();`\n   */\n]));\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/slideBoxDelegate.js\n ** module id = 24\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicTabsDelegate\n * @module ionic\n *\n * @description\n * Delegate for controlling the {@link ionic.directive:ionTabs} directive.\n *\n * Methods called directly on the $ionicTabsDelegate service will control all ionTabs\n * directives. Use the {@link ionic.service:$ionicTabsDelegate#$getByHandle $getByHandle}\n * method to control specific ionTabs instances.\n *\n * @usage\n *\n * ```html\n * <body ng-controller=\"MyCtrl\">\n *   <ion-tabs>\n *\n *     <ion-tab title=\"Tab 1\">\n *       Hello tab 1!\n *       <button ng-click=\"selectTabWithIndex(1)\">Select tab 2!</button>\n *     </ion-tab>\n *     <ion-tab title=\"Tab 2\">Hello tab 2!</ion-tab>\n *\n *   </ion-tabs>\n * </body>\n * ```\n * ```js\n * function MyCtrl($scope, $ionicTabsDelegate) {\n *   $scope.selectTabWithIndex = function(index) {\n *     $ionicTabsDelegate.select(index);\n *   }\n * }\n * ```\n */\nIonicModule\n.service('$ionicTabsDelegate', ionic.DelegateService([\n  /**\n   * @ngdoc method\n   * @name $ionicTabsDelegate#select\n   * @description Select the tab matching the given index.\n   *\n   * @param {number} index Index of the tab to select.\n   */\n  'select',\n  /**\n   * @ngdoc method\n   * @name $ionicTabsDelegate#selectedIndex\n   * @returns `number` The index of the selected tab, or -1.\n   */\n  'selectedIndex',\n  /**\n   * @ngdoc method\n   * @name $ionicTabsDelegate#showBar\n   * @description\n   * Set/get whether the {@link ionic.directive:ionTabs} is shown\n   * @param {boolean} show Whether to show the bar.\n   * @returns {boolean} Whether the bar is shown.\n   */\n  'showBar'\n  /**\n   * @ngdoc method\n   * @name $ionicTabsDelegate#$getByHandle\n   * @param {string} handle\n   * @returns `delegateInstance` A delegate instance that controls only the\n   * {@link ionic.directive:ionTabs} directives with `delegate-handle` matching\n   * the given handle.\n   *\n   * Example: `$ionicTabsDelegate.$getByHandle('my-handle').select(0);`\n   */\n]));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/tabsDelegate.js\n ** module id = 25\n ** module chunks = 0\n **/","// closure to keep things neat\n(function() {\n  var templatesToCache = [];\n\n/**\n * @ngdoc service\n * @name $ionicTemplateCache\n * @module ionic\n * @description A service that preemptively caches template files to eliminate transition flicker and boost performance.\n * @usage\n * State templates are cached automatically, but you can optionally cache other templates.\n *\n * ```js\n * $ionicTemplateCache('myNgIncludeTemplate.html');\n * ```\n *\n * Optionally disable all preemptive caching with the `$ionicConfigProvider` or individual states by setting `prefetchTemplate`\n * in the `$state` definition\n *\n * ```js\n *   angular.module('myApp', ['ionic'])\n *   .config(function($stateProvider, $ionicConfigProvider) {\n *\n *     // disable preemptive template caching globally\n *     $ionicConfigProvider.templates.prefetch(false);\n *\n *     // disable individual states\n *     $stateProvider\n *       .state('tabs', {\n *         url: \"/tab\",\n *         abstract: true,\n *         prefetchTemplate: false,\n *         templateUrl: \"tabs-templates/tabs.html\"\n *       })\n *       .state('tabs.home', {\n *         url: \"/home\",\n *         views: {\n *           'home-tab': {\n *             prefetchTemplate: false,\n *             templateUrl: \"tabs-templates/home.html\",\n *             controller: 'HomeTabCtrl'\n *           }\n *         }\n *       });\n *   });\n * ```\n */\nIonicModule\n.factory('$ionicTemplateCache', [\n'$http',\n'$templateCache',\n'$timeout',\nfunction($http, $templateCache, $timeout) {\n  var toCache = templatesToCache,\n      hasRun;\n\n  function $ionicTemplateCache(templates) {\n    if (typeof templates === 'undefined') {\n      return run();\n    }\n    if (isString(templates)) {\n      templates = [templates];\n    }\n    forEach(templates, function(template) {\n      toCache.push(template);\n    });\n    if (hasRun) {\n      run();\n    }\n  }\n\n  // run through methods - internal method\n  function run() {\n    var template;\n    $ionicTemplateCache._runCount++;\n\n    hasRun = true;\n    // ignore if race condition already zeroed out array\n    if (toCache.length === 0) return;\n\n    var i = 0;\n    while (i < 4 && (template = toCache.pop())) {\n      // note that inline templates are ignored by this request\n      if (isString(template)) $http.get(template, { cache: $templateCache });\n      i++;\n    }\n    // only preload 3 templates a second\n    if (toCache.length) {\n      $timeout(run, 1000);\n    }\n  }\n\n  // exposing for testing\n  $ionicTemplateCache._runCount = 0;\n  // default method\n  return $ionicTemplateCache;\n}])\n\n// Intercepts the $stateprovider.state() command to look for templateUrls that can be cached\n.config([\n'$stateProvider',\n'$ionicConfigProvider',\nfunction($stateProvider, $ionicConfigProvider) {\n  var stateProviderState = $stateProvider.state;\n  $stateProvider.state = function(stateName, definition) {\n    // don't even bother if it's disabled. note, another config may run after this, so it's not a catch-all\n    if (typeof definition === 'object') {\n      var enabled = definition.prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();\n      if (enabled && isString(definition.templateUrl)) templatesToCache.push(definition.templateUrl);\n      if (angular.isObject(definition.views)) {\n        for (var key in definition.views) {\n          enabled = definition.views[key].prefetchTemplate !== false && templatesToCache.length < $ionicConfigProvider.templates.maxPrefetch();\n          if (enabled && isString(definition.views[key].templateUrl)) templatesToCache.push(definition.views[key].templateUrl);\n        }\n      }\n    }\n    return stateProviderState.call($stateProvider, stateName, definition);\n  };\n}])\n\n// process the templateUrls collected by the $stateProvider, adding them to the cache\n.run(['$ionicTemplateCache', function($ionicTemplateCache) {\n  $ionicTemplateCache();\n}]);\n\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/templateCache.js\n ** module id = 26\n ** module chunks = 0\n **/","IonicModule\n.factory('$ionicTemplateLoader', [\n  '$compile',\n  '$controller',\n  '$http',\n  '$q',\n  '$rootScope',\n  '$templateCache',\nfunction($compile, $controller, $http, $q, $rootScope, $templateCache) {\n\n  return {\n    load: fetchTemplate,\n    compile: loadAndCompile\n  };\n\n  function fetchTemplate(url) {\n    return $http.get(url, {cache: $templateCache})\n    .then(function(response) {\n      return response.data && response.data.trim();\n    });\n  }\n\n  function loadAndCompile(options) {\n    options = extend({\n      template: '',\n      templateUrl: '',\n      scope: null,\n      controller: null,\n      locals: {},\n      appendTo: null\n    }, options || {});\n\n    var templatePromise = options.templateUrl ?\n      this.load(options.templateUrl) :\n      $q.when(options.template);\n\n    return templatePromise.then(function(template) {\n      var controller;\n      var scope = options.scope || $rootScope.$new();\n\n      //Incase template doesn't have just one root element, do this\n      var element = jqLite('<div>').html(template).contents();\n\n      if (options.controller) {\n        controller = $controller(\n          options.controller,\n          extend(options.locals, {\n            $scope: scope\n          })\n        );\n        element.children().data('$ngControllerController', controller);\n      }\n      if (options.appendTo) {\n        jqLite(options.appendTo).append(element);\n      }\n\n      $compile(element)(scope);\n\n      return {\n        element: element,\n        scope: scope\n      };\n    });\n  }\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/templateLoader.js\n ** module id = 27\n ** module chunks = 0\n **/","/**\n * @private\n * DEPRECATED, as of v1.0.0-beta14 -------\n */\nIonicModule\n.factory('$ionicViewService', ['$ionicHistory', '$log', function($ionicHistory, $log) {\n\n  function warn(oldMethod, newMethod) {\n    $log.warn('$ionicViewService' + oldMethod + ' is deprecated, please use $ionicHistory' + newMethod + ' instead: http://ionicframework.com/docs/nightly/api/service/$ionicHistory/');\n  }\n\n  warn('', '');\n\n  var methodsMap = {\n    getCurrentView: 'currentView',\n    getBackView: 'backView',\n    getForwardView: 'forwardView',\n    getCurrentStateName: 'currentStateName',\n    nextViewOptions: 'nextViewOptions',\n    clearHistory: 'clearHistory'\n  };\n\n  forEach(methodsMap, function(newMethod, oldMethod) {\n    methodsMap[oldMethod] = function() {\n      warn('.' + oldMethod, '.' + newMethod);\n      return $ionicHistory[newMethod].apply(this, arguments);\n    };\n  });\n\n  return methodsMap;\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/viewService.js\n ** module id = 28\n ** module chunks = 0\n **/","/**\r\n * @private\r\n * TODO document\r\n */\r\n\r\nIonicModule.factory('$ionicViewSwitcher', [\r\n  '$timeout',\r\n  '$document',\r\n  '$q',\r\n  '$ionicClickBlock',\r\n  '$ionicConfig',\r\n  '$ionicNavBarDelegate',\r\nfunction($timeout, $document, $q, $ionicClickBlock, $ionicConfig, $ionicNavBarDelegate) {\r\n\r\n  var TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\r\n  var DATA_NO_CACHE = '$noCache';\r\n  var DATA_DESTROY_ELE = '$destroyEle';\r\n  var DATA_ELE_IDENTIFIER = '$eleId';\r\n  var DATA_VIEW_ACCESSED = '$accessed';\r\n  var DATA_FALLBACK_TIMER = '$fallbackTimer';\r\n  var DATA_VIEW = '$viewData';\r\n  var NAV_VIEW_ATTR = 'nav-view';\r\n  var VIEW_STATUS_ACTIVE = 'active';\r\n  var VIEW_STATUS_CACHED = 'cached';\r\n  var VIEW_STATUS_STAGED = 'stage';\r\n\r\n  var transitionCounter = 0;\r\n  var nextTransition, nextDirection;\r\n  ionic.transition = ionic.transition || {};\r\n  ionic.transition.isActive = false;\r\n  var isActiveTimer;\r\n  var cachedAttr = ionic.DomUtil.cachedAttr;\r\n  var transitionPromises = [];\r\n  var defaultTimeout = 1100;\r\n\r\n  var ionicViewSwitcher = {\r\n\r\n    create: function(navViewCtrl, viewLocals, enteringView, leavingView, renderStart, renderEnd) {\r\n      // get a reference to an entering/leaving element if they exist\r\n      // loop through to see if the view is already in the navViewElement\r\n      var enteringEle, leavingEle;\r\n      var transitionId = ++transitionCounter;\r\n      var alreadyInDom;\r\n\r\n      var switcher = {\r\n\r\n        init: function(registerData, callback) {\r\n          ionicViewSwitcher.isTransitioning(true);\r\n\r\n          switcher.loadViewElements(registerData);\r\n\r\n          switcher.render(registerData, function() {\r\n            callback && callback();\r\n          });\r\n        },\r\n\r\n        loadViewElements: function(registerData) {\r\n          var x, l, viewEle;\r\n          var viewElements = navViewCtrl.getViewElements();\r\n          var enteringEleIdentifier = getViewElementIdentifier(viewLocals, enteringView);\r\n          var navViewActiveEleId = navViewCtrl.activeEleId();\r\n\r\n          for (x = 0, l = viewElements.length; x < l; x++) {\r\n            viewEle = viewElements.eq(x);\r\n\r\n            if (viewEle.data(DATA_ELE_IDENTIFIER) === enteringEleIdentifier) {\r\n              // we found an existing element in the DOM that should be entering the view\r\n              if (viewEle.data(DATA_NO_CACHE)) {\r\n                // the existing element should not be cached, don't use it\r\n                viewEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier + ionic.Utils.nextUid());\r\n                viewEle.data(DATA_DESTROY_ELE, true);\r\n\r\n              } else {\r\n                enteringEle = viewEle;\r\n              }\r\n\r\n            } else if (isDefined(navViewActiveEleId) && viewEle.data(DATA_ELE_IDENTIFIER) === navViewActiveEleId) {\r\n              leavingEle = viewEle;\r\n            }\r\n\r\n            if (enteringEle && leavingEle) break;\r\n          }\r\n\r\n          alreadyInDom = !!enteringEle;\r\n\r\n          if (!alreadyInDom) {\r\n            // still no existing element to use\r\n            // create it using existing template/scope/locals\r\n            enteringEle = registerData.ele || ionicViewSwitcher.createViewEle(viewLocals);\r\n\r\n            // existing elements in the DOM are looked up by their state name and state id\r\n            enteringEle.data(DATA_ELE_IDENTIFIER, enteringEleIdentifier);\r\n          }\r\n\r\n          if (renderEnd) {\r\n            navViewCtrl.activeEleId(enteringEleIdentifier);\r\n          }\r\n\r\n          registerData.ele = null;\r\n        },\r\n\r\n        render: function(registerData, callback) {\r\n          if (alreadyInDom) {\r\n            // it was already found in the DOM, just reconnect the scope\r\n            ionic.Utils.reconnectScope(enteringEle.scope());\r\n\r\n          } else {\r\n            // the entering element is not already in the DOM\r\n            // set that the entering element should be \"staged\" and its\r\n            // styles of where this element will go before it hits the DOM\r\n            navViewAttr(enteringEle, VIEW_STATUS_STAGED);\r\n\r\n            var enteringData = getTransitionData(viewLocals, enteringEle, registerData.direction, enteringView);\r\n            var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;\r\n            transitionFn(enteringEle, null, enteringData.direction, true).run(0);\r\n\r\n            enteringEle.data(DATA_VIEW, {\r\n              viewId: enteringData.viewId,\r\n              historyId: enteringData.historyId,\r\n              stateName: enteringData.stateName,\r\n              stateParams: enteringData.stateParams\r\n            });\r\n\r\n            // if the current state has cache:false\r\n            // or the element has cache-view=\"false\" attribute\r\n            if (viewState(viewLocals).cache === false || viewState(viewLocals).cache === 'false' ||\r\n                enteringEle.attr('cache-view') == 'false' || $ionicConfig.views.maxCache() === 0) {\r\n              enteringEle.data(DATA_NO_CACHE, true);\r\n            }\r\n\r\n            // append the entering element to the DOM, create a new scope and run link\r\n            var viewScope = navViewCtrl.appendViewElement(enteringEle, viewLocals);\r\n\r\n            delete enteringData.direction;\r\n            delete enteringData.transition;\r\n            viewScope.$emit('$ionicView.loaded', enteringData);\r\n          }\r\n\r\n          // update that this view was just accessed\r\n          enteringEle.data(DATA_VIEW_ACCESSED, Date.now());\r\n\r\n          callback && callback();\r\n        },\r\n\r\n        transition: function(direction, enableBack, allowAnimate) {\r\n          var deferred;\r\n          var enteringData = getTransitionData(viewLocals, enteringEle, direction, enteringView);\r\n          var leavingData = extend(extend({}, enteringData), getViewData(leavingView));\r\n          enteringData.transitionId = leavingData.transitionId = transitionId;\r\n          enteringData.fromCache = !!alreadyInDom;\r\n          enteringData.enableBack = !!enableBack;\r\n          enteringData.renderStart = renderStart;\r\n          enteringData.renderEnd = renderEnd;\r\n\r\n          cachedAttr(enteringEle.parent(), 'nav-view-transition', enteringData.transition);\r\n          cachedAttr(enteringEle.parent(), 'nav-view-direction', enteringData.direction);\r\n\r\n          // cancel any previous transition complete fallbacks\r\n          $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));\r\n\r\n          // get the transition ready and see if it'll animate\r\n          var transitionFn = $ionicConfig.transitions.views[enteringData.transition] || $ionicConfig.transitions.views.none;\r\n          var viewTransition = transitionFn(enteringEle, leavingEle, enteringData.direction,\r\n                                            enteringData.shouldAnimate && allowAnimate && renderEnd);\r\n\r\n          if (viewTransition.shouldAnimate) {\r\n            // attach transitionend events (and fallback timer)\r\n            enteringEle.on(TRANSITIONEND_EVENT, completeOnTransitionEnd);\r\n            enteringEle.data(DATA_FALLBACK_TIMER, $timeout(transitionComplete, defaultTimeout));\r\n            $ionicClickBlock.show(defaultTimeout);\r\n          }\r\n\r\n          if (renderStart) {\r\n            // notify the views \"before\" the transition starts\r\n            switcher.emit('before', enteringData, leavingData);\r\n\r\n            // stage entering element, opacity 0, no transition duration\r\n            navViewAttr(enteringEle, VIEW_STATUS_STAGED);\r\n\r\n            // render the elements in the correct location for their starting point\r\n            viewTransition.run(0);\r\n          }\r\n\r\n          if (renderEnd) {\r\n            // create a promise so we can keep track of when all transitions finish\r\n            // only required if this transition should complete\r\n            deferred = $q.defer();\r\n            transitionPromises.push(deferred.promise);\r\n          }\r\n\r\n          if (renderStart && renderEnd) {\r\n            // CSS \"auto\" transitioned, not manually transitioned\r\n            // wait a frame so the styles apply before auto transitioning\r\n            $timeout(function() {\r\n              ionic.requestAnimationFrame(onReflow);\r\n            });\r\n          } else if (!renderEnd) {\r\n            // just the start of a manual transition\r\n            // but it will not render the end of the transition\r\n            navViewAttr(enteringEle, 'entering');\r\n            navViewAttr(leavingEle, 'leaving');\r\n\r\n            // return the transition run method so each step can be ran manually\r\n            return {\r\n              run: viewTransition.run,\r\n              cancel: function(shouldAnimate) {\r\n                if (shouldAnimate) {\r\n                  enteringEle.on(TRANSITIONEND_EVENT, cancelOnTransitionEnd);\r\n                  enteringEle.data(DATA_FALLBACK_TIMER, $timeout(cancelTransition, defaultTimeout));\r\n                  $ionicClickBlock.show(defaultTimeout);\r\n                } else {\r\n                  cancelTransition();\r\n                }\r\n                viewTransition.shouldAnimate = shouldAnimate;\r\n                viewTransition.run(0);\r\n                viewTransition = null;\r\n              }\r\n            };\r\n\r\n          } else if (renderEnd) {\r\n            // just the end of a manual transition\r\n            // happens after the manual transition has completed\r\n            // and a full history change has happened\r\n            onReflow();\r\n          }\r\n\r\n\r\n          function onReflow() {\r\n            // remove that we're staging the entering element so it can auto transition\r\n            navViewAttr(enteringEle, viewTransition.shouldAnimate ? 'entering' : VIEW_STATUS_ACTIVE);\r\n            navViewAttr(leavingEle, viewTransition.shouldAnimate ? 'leaving' : VIEW_STATUS_CACHED);\r\n\r\n            // start the auto transition and let the CSS take over\r\n            viewTransition.run(1);\r\n\r\n            // trigger auto transitions on the associated nav bars\r\n            $ionicNavBarDelegate._instances.forEach(function(instance) {\r\n              instance.triggerTransitionStart(transitionId);\r\n            });\r\n\r\n            if (!viewTransition.shouldAnimate) {\r\n              // no animated auto transition\r\n              transitionComplete();\r\n            }\r\n          }\r\n\r\n          // Make sure that transitionend events bubbling up from children won't fire\r\n          // transitionComplete. Will only go forward if ev.target == the element listening.\r\n          function completeOnTransitionEnd(ev) {\r\n            if (ev.target !== this) return;\r\n            transitionComplete();\r\n          }\r\n          function transitionComplete() {\r\n            if (transitionComplete.x) return;\r\n            transitionComplete.x = true;\r\n\r\n            enteringEle.off(TRANSITIONEND_EVENT, completeOnTransitionEnd);\r\n            $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));\r\n            leavingEle && $timeout.cancel(leavingEle.data(DATA_FALLBACK_TIMER));\r\n\r\n            // resolve that this one transition (there could be many w/ nested views)\r\n            deferred && deferred.resolve(navViewCtrl);\r\n\r\n            // the most recent transition added has completed and all the active\r\n            // transition promises should be added to the services array of promises\r\n            if (transitionId === transitionCounter) {\r\n              $q.all(transitionPromises).then(ionicViewSwitcher.transitionEnd);\r\n\r\n              // emit that the views have finished transitioning\r\n              // each parent nav-view will update which views are active and cached\r\n              switcher.emit('after', enteringData, leavingData);\r\n              switcher.cleanup(enteringData);\r\n            }\r\n\r\n            // tell the nav bars that the transition has ended\r\n            $ionicNavBarDelegate._instances.forEach(function(instance) {\r\n              instance.triggerTransitionEnd();\r\n            });\r\n\r\n\r\n            // remove any references that could cause memory issues\r\n            nextTransition = nextDirection = enteringView = leavingView = enteringEle = leavingEle = null;\r\n          }\r\n\r\n          // Make sure that transitionend events bubbling up from children won't fire\r\n          // transitionComplete. Will only go forward if ev.target == the element listening.\r\n          function cancelOnTransitionEnd(ev) {\r\n            if (ev.target !== this) return;\r\n            cancelTransition();\r\n          }\r\n          function cancelTransition() {\r\n            navViewAttr(enteringEle, VIEW_STATUS_CACHED);\r\n            navViewAttr(leavingEle, VIEW_STATUS_ACTIVE);\r\n            enteringEle.off(TRANSITIONEND_EVENT, cancelOnTransitionEnd);\r\n            $timeout.cancel(enteringEle.data(DATA_FALLBACK_TIMER));\r\n            ionicViewSwitcher.transitionEnd([navViewCtrl]);\r\n          }\r\n\r\n        },\r\n\r\n        emit: function(step, enteringData, leavingData) {\r\n          var enteringScope = enteringEle.scope(),\r\n            leavingScope = leavingEle && leavingEle.scope();\r\n\r\n          if (step == 'after') {\r\n            if (enteringScope) {\r\n              enteringScope.$emit('$ionicView.enter', enteringData);\r\n            }\r\n\r\n            if (leavingScope) {\r\n              leavingScope.$emit('$ionicView.leave', leavingData);\r\n\r\n            } else if (enteringScope && leavingData && leavingData.viewId) {\r\n              enteringScope.$emit('$ionicNavView.leave', leavingData);\r\n            }\r\n          }\r\n\r\n          if (enteringScope) {\r\n            enteringScope.$emit('$ionicView.' + step + 'Enter', enteringData);\r\n          }\r\n\r\n          if (leavingScope) {\r\n            leavingScope.$emit('$ionicView.' + step + 'Leave', leavingData);\r\n\r\n          } else if (enteringScope && leavingData && leavingData.viewId) {\r\n            enteringScope.$emit('$ionicNavView.' + step + 'Leave', leavingData);\r\n          }\r\n        },\r\n\r\n        cleanup: function(transData) {\r\n          // check if any views should be removed\r\n          if (leavingEle && transData.direction == 'back' && !$ionicConfig.views.forwardCache()) {\r\n            // if they just navigated back we can destroy the forward view\r\n            // do not remove forward views if cacheForwardViews config is true\r\n            destroyViewEle(leavingEle);\r\n          }\r\n\r\n          var viewElements = navViewCtrl.getViewElements();\r\n          var viewElementsLength = viewElements.length;\r\n          var x, viewElement;\r\n          var removeOldestAccess = (viewElementsLength - 1) > $ionicConfig.views.maxCache();\r\n          var removableEle;\r\n          var oldestAccess = Date.now();\r\n\r\n          for (x = 0; x < viewElementsLength; x++) {\r\n            viewElement = viewElements.eq(x);\r\n\r\n            if (removeOldestAccess && viewElement.data(DATA_VIEW_ACCESSED) < oldestAccess) {\r\n              // remember what was the oldest element to be accessed so it can be destroyed\r\n              oldestAccess = viewElement.data(DATA_VIEW_ACCESSED);\r\n              removableEle = viewElements.eq(x);\r\n\r\n            } else if (viewElement.data(DATA_DESTROY_ELE) && navViewAttr(viewElement) != VIEW_STATUS_ACTIVE) {\r\n              destroyViewEle(viewElement);\r\n            }\r\n          }\r\n\r\n          destroyViewEle(removableEle);\r\n\r\n          if (enteringEle.data(DATA_NO_CACHE)) {\r\n            enteringEle.data(DATA_DESTROY_ELE, true);\r\n          }\r\n        },\r\n\r\n        enteringEle: function() { return enteringEle; },\r\n        leavingEle: function() { return leavingEle; }\r\n\r\n      };\r\n\r\n      return switcher;\r\n    },\r\n\r\n    transitionEnd: function(navViewCtrls) {\r\n      forEach(navViewCtrls, function(navViewCtrl) {\r\n        navViewCtrl.transitionEnd();\r\n      });\r\n\r\n      ionicViewSwitcher.isTransitioning(false);\r\n      $ionicClickBlock.hide();\r\n      transitionPromises = [];\r\n    },\r\n\r\n    nextTransition: function(val) {\r\n      nextTransition = val;\r\n    },\r\n\r\n    nextDirection: function(val) {\r\n      nextDirection = val;\r\n    },\r\n\r\n    isTransitioning: function(val) {\r\n      if (arguments.length) {\r\n        ionic.transition.isActive = !!val;\r\n        $timeout.cancel(isActiveTimer);\r\n        if (val) {\r\n          isActiveTimer = $timeout(function() {\r\n            ionicViewSwitcher.isTransitioning(false);\r\n          }, 999);\r\n        }\r\n      }\r\n      return ionic.transition.isActive;\r\n    },\r\n\r\n    createViewEle: function(viewLocals) {\r\n      var containerEle = $document[0].createElement('div');\r\n      if (viewLocals && viewLocals.$template) {\r\n        containerEle.innerHTML = viewLocals.$template;\r\n        if (containerEle.children.length === 1) {\r\n          containerEle.children[0].classList.add('pane');\r\n          return jqLite(containerEle.children[0]);\r\n        }\r\n      }\r\n      containerEle.className = \"pane\";\r\n      return jqLite(containerEle);\r\n    },\r\n\r\n    viewEleIsActive: function(viewEle, isActiveAttr) {\r\n      navViewAttr(viewEle, isActiveAttr ? VIEW_STATUS_ACTIVE : VIEW_STATUS_CACHED);\r\n    },\r\n\r\n    getTransitionData: getTransitionData,\r\n    navViewAttr: navViewAttr,\r\n    destroyViewEle: destroyViewEle\r\n\r\n  };\r\n\r\n  return ionicViewSwitcher;\r\n\r\n\r\n  function getViewElementIdentifier(locals, view) {\r\n    if (viewState(locals)['abstract']) return viewState(locals).name;\r\n    if (view) return view.stateId || view.viewId;\r\n    return ionic.Utils.nextUid();\r\n  }\r\n\r\n  function viewState(locals) {\r\n    return locals && locals.$$state && locals.$$state.self || {};\r\n  }\r\n\r\n  function getTransitionData(viewLocals, enteringEle, direction, view) {\r\n    // Priority\r\n    // 1) attribute directive on the button/link to this view\r\n    // 2) entering element's attribute\r\n    // 3) entering view's $state config property\r\n    // 4) view registration data\r\n    // 5) global config\r\n    // 6) fallback value\r\n\r\n    var state = viewState(viewLocals);\r\n    var viewTransition = nextTransition || cachedAttr(enteringEle, 'view-transition') || state.viewTransition || $ionicConfig.views.transition() || 'ios';\r\n    var navBarTransition = $ionicConfig.navBar.transition();\r\n    direction = nextDirection || cachedAttr(enteringEle, 'view-direction') || state.viewDirection || direction || 'none';\r\n\r\n    return extend(getViewData(view), {\r\n      transition: viewTransition,\r\n      navBarTransition: navBarTransition === 'view' ? viewTransition : navBarTransition,\r\n      direction: direction,\r\n      shouldAnimate: (viewTransition !== 'none' && direction !== 'none')\r\n    });\r\n  }\r\n\r\n  function getViewData(view) {\r\n    view = view || {};\r\n    return {\r\n      viewId: view.viewId,\r\n      historyId: view.historyId,\r\n      stateId: view.stateId,\r\n      stateName: view.stateName,\r\n      stateParams: view.stateParams\r\n    };\r\n  }\r\n\r\n  function navViewAttr(ele, value) {\r\n    if (arguments.length > 1) {\r\n      cachedAttr(ele, NAV_VIEW_ATTR, value);\r\n    } else {\r\n      return cachedAttr(ele, NAV_VIEW_ATTR);\r\n    }\r\n  }\r\n\r\n  function destroyViewEle(ele) {\r\n    // we found an element that should be removed\r\n    // destroy its scope, then remove the element\r\n    if (ele && ele.length) {\r\n      var viewScope = ele.scope();\r\n      if (viewScope) {\r\n        viewScope.$emit('$ionicView.unloaded', ele.data(DATA_VIEW));\r\n        viewScope.$destroy();\r\n      }\r\n      ele.remove();\r\n    }\r\n  }\r\n\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/service/viewSwitcher.js\n ** module id = 29\n ** module chunks = 0\n **/","IonicModule\n\n.controller('$ionicHeaderBar', [\n  '$scope',\n  '$element',\n  '$attrs',\n  '$q',\n  '$ionicConfig',\n  '$ionicHistory',\nfunction($scope, $element, $attrs, $q, $ionicConfig, $ionicHistory) {\n  var TITLE = 'title';\n  var BACK_TEXT = 'back-text';\n  var BACK_BUTTON = 'back-button';\n  var DEFAULT_TITLE = 'default-title';\n  var PREVIOUS_TITLE = 'previous-title';\n  var HIDE = 'hide';\n\n  var self = this;\n  var titleText = '';\n  var previousTitleText = '';\n  var titleLeft = 0;\n  var titleRight = 0;\n  var titleCss = '';\n  var isBackEnabled = false;\n  var isBackShown = true;\n  var isNavBackShown = true;\n  var isBackElementShown = false;\n  var titleTextWidth = 0;\n\n\n  self.beforeEnter = function(viewData) {\n    $scope.$broadcast('$ionicView.beforeEnter', viewData);\n  };\n\n\n  self.title = function(newTitleText) {\n    if (arguments.length && newTitleText !== titleText) {\n      getEle(TITLE).innerHTML = newTitleText;\n      titleText = newTitleText;\n      titleTextWidth = 0;\n    }\n    return titleText;\n  };\n\n\n  self.enableBack = function(shouldEnable, disableReset) {\n    // whether or not the back button show be visible, according\n    // to the navigation and history\n    if (arguments.length) {\n      isBackEnabled = shouldEnable;\n      if (!disableReset) self.updateBackButton();\n    }\n    return isBackEnabled;\n  };\n\n\n  self.showBack = function(shouldShow, disableReset) {\n    // different from enableBack() because this will always have the back\n    // visually hidden if false, even if the history says it should show\n    if (arguments.length) {\n      isBackShown = shouldShow;\n      if (!disableReset) self.updateBackButton();\n    }\n    return isBackShown;\n  };\n\n\n  self.showNavBack = function(shouldShow) {\n    // different from showBack() because this is for the entire nav bar's\n    // setting for all of it's child headers. For internal use.\n    isNavBackShown = shouldShow;\n    self.updateBackButton();\n  };\n\n\n  self.updateBackButton = function() {\n    var ele;\n    if ((isBackShown && isNavBackShown && isBackEnabled) !== isBackElementShown) {\n      isBackElementShown = isBackShown && isNavBackShown && isBackEnabled;\n      ele = getEle(BACK_BUTTON);\n      ele && ele.classList[ isBackElementShown ? 'remove' : 'add' ](HIDE);\n    }\n\n    if (isBackEnabled) {\n      ele = ele || getEle(BACK_BUTTON);\n      if (ele) {\n        if (self.backButtonIcon !== $ionicConfig.backButton.icon()) {\n          ele = getEle(BACK_BUTTON + ' .icon');\n          if (ele) {\n            self.backButtonIcon = $ionicConfig.backButton.icon();\n            ele.className = 'icon ' + self.backButtonIcon;\n          }\n        }\n\n        if (self.backButtonText !== $ionicConfig.backButton.text()) {\n          ele = getEle(BACK_BUTTON + ' .back-text');\n          if (ele) {\n            ele.textContent = self.backButtonText = $ionicConfig.backButton.text();\n          }\n        }\n      }\n    }\n  };\n\n\n  self.titleTextWidth = function() {\n    if (!titleTextWidth) {\n      var bounds = ionic.DomUtil.getTextBounds(getEle(TITLE));\n      titleTextWidth = Math.min(bounds && bounds.width || 30);\n    }\n    return titleTextWidth;\n  };\n\n\n  self.titleWidth = function() {\n    var titleWidth = self.titleTextWidth();\n    var offsetWidth = getEle(TITLE).offsetWidth;\n    if (offsetWidth < titleWidth) {\n      titleWidth = offsetWidth + (titleLeft - titleRight - 5);\n    }\n    return titleWidth;\n  };\n\n\n  self.titleTextX = function() {\n    return ($element[0].offsetWidth / 2) - (self.titleWidth() / 2);\n  };\n\n\n  self.titleLeftRight = function() {\n    return titleLeft - titleRight;\n  };\n\n\n  self.backButtonTextLeft = function() {\n    var offsetLeft = 0;\n    var ele = getEle(BACK_TEXT);\n    while (ele) {\n      offsetLeft += ele.offsetLeft;\n      ele = ele.parentElement;\n    }\n    return offsetLeft;\n  };\n\n\n  self.resetBackButton = function(viewData) {\n    if ($ionicConfig.backButton.previousTitleText()) {\n      var previousTitleEle = getEle(PREVIOUS_TITLE);\n      if (previousTitleEle) {\n        previousTitleEle.classList.remove(HIDE);\n\n        var view = (viewData && $ionicHistory.getViewById(viewData.viewId));\n        var newPreviousTitleText = $ionicHistory.backTitle(view);\n\n        if (newPreviousTitleText !== previousTitleText) {\n          previousTitleText = previousTitleEle.innerHTML = newPreviousTitleText;\n        }\n      }\n      var defaultTitleEle = getEle(DEFAULT_TITLE);\n      if (defaultTitleEle) {\n        defaultTitleEle.classList.remove(HIDE);\n      }\n    }\n  };\n\n\n  self.align = function(textAlign) {\n    var titleEle = getEle(TITLE);\n\n    textAlign = textAlign || $attrs.alignTitle || $ionicConfig.navBar.alignTitle();\n\n    var widths = self.calcWidths(textAlign, false);\n\n    if (isBackShown && previousTitleText && $ionicConfig.backButton.previousTitleText()) {\n      var previousTitleWidths = self.calcWidths(textAlign, true);\n\n      var availableTitleWidth = $element[0].offsetWidth - previousTitleWidths.titleLeft - previousTitleWidths.titleRight;\n\n      if (self.titleTextWidth() <= availableTitleWidth) {\n        widths = previousTitleWidths;\n      }\n    }\n\n    return self.updatePositions(titleEle, widths.titleLeft, widths.titleRight, widths.buttonsLeft, widths.buttonsRight, widths.css, widths.showPrevTitle);\n  };\n\n\n  self.calcWidths = function(textAlign, isPreviousTitle) {\n    var titleEle = getEle(TITLE);\n    var backBtnEle = getEle(BACK_BUTTON);\n    var x, y, z, b, c, d, childSize, bounds;\n    var childNodes = $element[0].childNodes;\n    var buttonsLeft = 0;\n    var buttonsRight = 0;\n    var isCountRightOfTitle;\n    var updateTitleLeft = 0;\n    var updateTitleRight = 0;\n    var updateCss = '';\n    var backButtonWidth = 0;\n\n    // Compute how wide the left children are\n    // Skip all titles (there may still be two titles, one leaving the dom)\n    // Once we encounter a titleEle, realize we are now counting the right-buttons, not left\n    for (x = 0; x < childNodes.length; x++) {\n      c = childNodes[x];\n\n      childSize = 0;\n      if (c.nodeType == 1) {\n        // element node\n        if (c === titleEle) {\n          isCountRightOfTitle = true;\n          continue;\n        }\n\n        if (c.classList.contains(HIDE)) {\n          continue;\n        }\n\n        if (isBackShown && c === backBtnEle) {\n\n          for (y = 0; y < c.childNodes.length; y++) {\n            b = c.childNodes[y];\n\n            if (b.nodeType == 1) {\n\n              if (b.classList.contains(BACK_TEXT)) {\n                for (z = 0; z < b.children.length; z++) {\n                  d = b.children[z];\n\n                  if (isPreviousTitle) {\n                    if (d.classList.contains(DEFAULT_TITLE)) continue;\n                    backButtonWidth += d.offsetWidth;\n                  } else {\n                    if (d.classList.contains(PREVIOUS_TITLE)) continue;\n                    backButtonWidth += d.offsetWidth;\n                  }\n                }\n\n              } else {\n                backButtonWidth += b.offsetWidth;\n              }\n\n            } else if (b.nodeType == 3 && b.nodeValue.trim()) {\n              bounds = ionic.DomUtil.getTextBounds(b);\n              backButtonWidth += bounds && bounds.width || 0;\n            }\n\n          }\n          childSize = backButtonWidth || c.offsetWidth;\n\n        } else {\n          // not the title, not the back button, not a hidden element\n          childSize = c.offsetWidth;\n        }\n\n      } else if (c.nodeType == 3 && c.nodeValue.trim()) {\n        // text node\n        bounds = ionic.DomUtil.getTextBounds(c);\n        childSize = bounds && bounds.width || 0;\n      }\n\n      if (isCountRightOfTitle) {\n        buttonsRight += childSize;\n      } else {\n        buttonsLeft += childSize;\n      }\n    }\n\n    // Size and align the header titleEle based on the sizes of the left and\n    // right children, and the desired alignment mode\n    if (textAlign == 'left') {\n      updateCss = 'title-left';\n      if (buttonsLeft) {\n        updateTitleLeft = buttonsLeft + 15;\n      }\n      if (buttonsRight) {\n        updateTitleRight = buttonsRight + 15;\n      }\n\n    } else if (textAlign == 'right') {\n      updateCss = 'title-right';\n      if (buttonsLeft) {\n        updateTitleLeft = buttonsLeft + 15;\n      }\n      if (buttonsRight) {\n        updateTitleRight = buttonsRight + 15;\n      }\n\n    } else {\n      // center the default\n      var margin = Math.max(buttonsLeft, buttonsRight) + 10;\n      if (margin > 10) {\n        updateTitleLeft = updateTitleRight = margin;\n      }\n    }\n\n    return {\n      backButtonWidth: backButtonWidth,\n      buttonsLeft: buttonsLeft,\n      buttonsRight: buttonsRight,\n      titleLeft: updateTitleLeft,\n      titleRight: updateTitleRight,\n      showPrevTitle: isPreviousTitle,\n      css: updateCss\n    };\n  };\n\n\n  self.updatePositions = function(titleEle, updateTitleLeft, updateTitleRight, buttonsLeft, buttonsRight, updateCss, showPreviousTitle) {\n    var deferred = $q.defer();\n\n    // only make DOM updates when there are actual changes\n    if (titleEle) {\n      if (updateTitleLeft !== titleLeft) {\n        titleEle.style.left = updateTitleLeft ? updateTitleLeft + 'px' : '';\n        titleLeft = updateTitleLeft;\n      }\n      if (updateTitleRight !== titleRight) {\n        titleEle.style.right = updateTitleRight ? updateTitleRight + 'px' : '';\n        titleRight = updateTitleRight;\n      }\n\n      if (updateCss !== titleCss) {\n        updateCss && titleEle.classList.add(updateCss);\n        titleCss && titleEle.classList.remove(titleCss);\n        titleCss = updateCss;\n      }\n    }\n\n    if ($ionicConfig.backButton.previousTitleText()) {\n      var prevTitle = getEle(PREVIOUS_TITLE);\n      var defaultTitle = getEle(DEFAULT_TITLE);\n\n      prevTitle && prevTitle.classList[ showPreviousTitle ? 'remove' : 'add'](HIDE);\n      defaultTitle && defaultTitle.classList[ showPreviousTitle ? 'add' : 'remove'](HIDE);\n    }\n\n    ionic.requestAnimationFrame(function() {\n      if (titleEle && titleEle.offsetWidth + 10 < titleEle.scrollWidth) {\n        var minRight = buttonsRight + 5;\n        var testRight = $element[0].offsetWidth - titleLeft - self.titleTextWidth() - 20;\n        updateTitleRight = testRight < minRight ? minRight : testRight;\n        if (updateTitleRight !== titleRight) {\n          titleEle.style.right = updateTitleRight + 'px';\n          titleRight = updateTitleRight;\n        }\n      }\n      deferred.resolve();\n    });\n\n    return deferred.promise;\n  };\n\n\n  self.setCss = function(elementClassname, css) {\n    ionic.DomUtil.cachedStyles(getEle(elementClassname), css);\n  };\n\n\n  var eleCache = {};\n  function getEle(className) {\n    if (!eleCache[className]) {\n      eleCache[className] = $element[0].querySelector('.' + className);\n    }\n    return eleCache[className];\n  }\n\n\n  $scope.$on('$destroy', function() {\n    for (var n in eleCache) eleCache[n] = null;\n  });\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/headerBarController.js\n ** module id = 30\n ** module chunks = 0\n **/","IonicModule\n.controller('$ionInfiniteScroll', [\n  '$scope',\n  '$attrs',\n  '$element',\n  '$timeout',\nfunction($scope, $attrs, $element, $timeout) {\n  var self = this;\n  self.isLoading = false;\n\n  $scope.icon = function() {\n    return isDefined($attrs.icon) ? $attrs.icon : 'ion-load-d';\n  };\n\n  $scope.spinner = function() {\n    return isDefined($attrs.spinner) ? $attrs.spinner : '';\n  };\n\n  $scope.$on('scroll.infiniteScrollComplete', function() {\n    finishInfiniteScroll();\n  });\n\n  $scope.$on('$destroy', function() {\n    if (self.scrollCtrl && self.scrollCtrl.$element) self.scrollCtrl.$element.off('scroll', self.checkBounds);\n    if (self.scrollEl && self.scrollEl.removeEventListener) {\n      self.scrollEl.removeEventListener('scroll', self.checkBounds);\n    }\n  });\n\n  // debounce checking infinite scroll events\n  self.checkBounds = ionic.Utils.throttle(checkInfiniteBounds, 300);\n\n  function onInfinite() {\n    ionic.requestAnimationFrame(function() {\n      $element[0].classList.add('active');\n    });\n    self.isLoading = true;\n    $scope.$parent && $scope.$parent.$apply($attrs.onInfinite || '');\n  }\n\n  function finishInfiniteScroll() {\n    ionic.requestAnimationFrame(function() {\n      $element[0].classList.remove('active');\n    });\n    $timeout(function() {\n      if (self.jsScrolling) self.scrollView.resize();\n      // only check bounds again immediately if the page isn't cached (scroll el has height)\n      if ((self.jsScrolling && self.scrollView.__container && self.scrollView.__container.offsetHeight > 0) ||\n      !self.jsScrolling) {\n        self.checkBounds();\n      }\n    }, 30, false);\n    self.isLoading = false;\n  }\n\n  // check if we've scrolled far enough to trigger an infinite scroll\n  function checkInfiniteBounds() {\n    if (self.isLoading) return;\n    var maxScroll = {};\n\n    if (self.jsScrolling) {\n      maxScroll = self.getJSMaxScroll();\n      var scrollValues = self.scrollView.getValues();\n      if ((maxScroll.left !== -1 && scrollValues.left >= maxScroll.left) ||\n        (maxScroll.top !== -1 && scrollValues.top >= maxScroll.top)) {\n        onInfinite();\n      }\n    } else {\n      maxScroll = self.getNativeMaxScroll();\n      if ((\n        maxScroll.left !== -1 &&\n        self.scrollEl.scrollLeft >= maxScroll.left - self.scrollEl.clientWidth\n        ) || (\n        maxScroll.top !== -1 &&\n        self.scrollEl.scrollTop >= maxScroll.top - self.scrollEl.clientHeight\n        )) {\n        onInfinite();\n      }\n    }\n  }\n\n  // determine the threshold at which we should fire an infinite scroll\n  // note: this gets processed every scroll event, can it be cached?\n  self.getJSMaxScroll = function() {\n    var maxValues = self.scrollView.getScrollMax();\n    return {\n      left: self.scrollView.options.scrollingX ?\n        calculateMaxValue(maxValues.left) :\n        -1,\n      top: self.scrollView.options.scrollingY ?\n        calculateMaxValue(maxValues.top) :\n        -1\n    };\n  };\n\n  self.getNativeMaxScroll = function() {\n    var maxValues = {\n      left: self.scrollEl.scrollWidth,\n      top: self.scrollEl.scrollHeight\n    };\n    var computedStyle = window.getComputedStyle(self.scrollEl) || {};\n    return {\n      left: maxValues.left &&\n        (computedStyle.overflowX === 'scroll' ||\n        computedStyle.overflowX === 'auto' ||\n        self.scrollEl.style['overflow-x'] === 'scroll') ?\n        calculateMaxValue(maxValues.left) : -1,\n      top: maxValues.top &&\n        (computedStyle.overflowY === 'scroll' ||\n        computedStyle.overflowY === 'auto' ||\n        self.scrollEl.style['overflow-y'] === 'scroll' ) ?\n        calculateMaxValue(maxValues.top) : -1\n    };\n  };\n\n  // determine pixel refresh distance based on % or value\n  function calculateMaxValue(maximum) {\n    var distance = ($attrs.distance || '2.5%').trim();\n    var isPercent = distance.indexOf('%') !== -1;\n    return isPercent ?\n    maximum * (1 - parseFloat(distance) / 100) :\n    maximum - parseFloat(distance);\n  }\n\n  //for testing\n  self.__finishInfiniteScroll = finishInfiniteScroll;\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/infiniteScrollController.js\n ** module id = 31\n ** module chunks = 0\n **/","/**\n * @ngdoc service\n * @name $ionicListDelegate\n * @module ionic\n *\n * @description\n * Delegate for controlling the {@link ionic.directive:ionList} directive.\n *\n * Methods called directly on the $ionicListDelegate service will control all lists.\n * Use the {@link ionic.service:$ionicListDelegate#$getByHandle $getByHandle}\n * method to control specific ionList instances.\n *\n * @usage\n * ```html\n * {% raw %}\n * <ion-content ng-controller=\"MyCtrl\">\n *   <button class=\"button\" ng-click=\"showDeleteButtons()\"></button>\n *   <ion-list>\n *     <ion-item ng-repeat=\"i in items\">\n *       Hello, {{i}}!\n *       <ion-delete-button class=\"ion-minus-circled\"></ion-delete-button>\n *     </ion-item>\n *   </ion-list>\n * </ion-content>\n * {% endraw %}\n * ```\n\n * ```js\n * function MyCtrl($scope, $ionicListDelegate) {\n *   $scope.showDeleteButtons = function() {\n *     $ionicListDelegate.showDelete(true);\n *   };\n * }\n * ```\n */\nIonicModule.service('$ionicListDelegate', ionic.DelegateService([\n  /**\n   * @ngdoc method\n   * @name $ionicListDelegate#showReorder\n   * @param {boolean=} showReorder Set whether or not this list is showing its reorder buttons.\n   * @returns {boolean} Whether the reorder buttons are shown.\n   */\n  'showReorder',\n  /**\n   * @ngdoc method\n   * @name $ionicListDelegate#showDelete\n   * @param {boolean=} showDelete Set whether or not this list is showing its delete buttons.\n   * @returns {boolean} Whether the delete buttons are shown.\n   */\n  'showDelete',\n  /**\n   * @ngdoc method\n   * @name $ionicListDelegate#canSwipeItems\n   * @param {boolean=} canSwipeItems Set whether or not this list is able to swipe to show\n   * option buttons.\n   * @returns {boolean} Whether the list is able to swipe to show option buttons.\n   */\n  'canSwipeItems',\n  /**\n   * @ngdoc method\n   * @name $ionicListDelegate#closeOptionButtons\n   * @description Closes any option buttons on the list that are swiped open.\n   */\n  'closeOptionButtons'\n  /**\n   * @ngdoc method\n   * @name $ionicListDelegate#$getByHandle\n   * @param {string} handle\n   * @returns `delegateInstance` A delegate instance that controls only the\n   * {@link ionic.directive:ionList} directives with `delegate-handle` matching\n   * the given handle.\n   *\n   * Example: `$ionicListDelegate.$getByHandle('my-handle').showReorder(true);`\n   */\n]))\n\n.controller('$ionicList', [\n  '$scope',\n  '$attrs',\n  '$ionicListDelegate',\n  '$ionicHistory',\nfunction($scope, $attrs, $ionicListDelegate, $ionicHistory) {\n  var self = this;\n  var isSwipeable = true;\n  var isReorderShown = false;\n  var isDeleteShown = false;\n\n  var deregisterInstance = $ionicListDelegate._registerInstance(\n    self, $attrs.delegateHandle, function() {\n      return $ionicHistory.isActiveScope($scope);\n    }\n  );\n  $scope.$on('$destroy', deregisterInstance);\n\n  self.showReorder = function(show) {\n    if (arguments.length) {\n      isReorderShown = !!show;\n    }\n    return isReorderShown;\n  };\n\n  self.showDelete = function(show) {\n    if (arguments.length) {\n      isDeleteShown = !!show;\n    }\n    return isDeleteShown;\n  };\n\n  self.canSwipeItems = function(can) {\n    if (arguments.length) {\n      isSwipeable = !!can;\n    }\n    return isSwipeable;\n  };\n\n  self.closeOptionButtons = function() {\n    self.listView && self.listView.clearDragEffects();\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/listController.js\n ** module id = 32\n ** module chunks = 0\n **/","IonicModule\n\n.controller('$ionicNavBar', [\n  '$scope',\n  '$element',\n  '$attrs',\n  '$compile',\n  '$timeout',\n  '$ionicNavBarDelegate',\n  '$ionicConfig',\n  '$ionicHistory',\nfunction($scope, $element, $attrs, $compile, $timeout, $ionicNavBarDelegate, $ionicConfig, $ionicHistory) {\n\n  var CSS_HIDE = 'hide';\n  var DATA_NAV_BAR_CTRL = '$ionNavBarController';\n  var PRIMARY_BUTTONS = 'primaryButtons';\n  var SECONDARY_BUTTONS = 'secondaryButtons';\n  var BACK_BUTTON = 'backButton';\n  var ITEM_TYPES = 'primaryButtons secondaryButtons leftButtons rightButtons title'.split(' ');\n\n  var self = this;\n  var headerBars = [];\n  var navElementHtml = {};\n  var isVisible = true;\n  var queuedTransitionStart, queuedTransitionEnd, latestTransitionId;\n\n  $element.parent().data(DATA_NAV_BAR_CTRL, self);\n\n  var delegateHandle = $attrs.delegateHandle || 'navBar' + ionic.Utils.nextUid();\n\n  var deregisterInstance = $ionicNavBarDelegate._registerInstance(self, delegateHandle);\n\n\n  self.init = function() {\n    $element.addClass('nav-bar-container');\n    ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', $ionicConfig.views.transition());\n\n    // create two nav bar blocks which will trade out which one is shown\n    self.createHeaderBar(false);\n    self.createHeaderBar(true);\n\n    $scope.$emit('ionNavBar.init', delegateHandle);\n  };\n\n\n  self.createHeaderBar = function(isActive) {\n    var containerEle = jqLite('<div class=\"nav-bar-block\">');\n    ionic.DomUtil.cachedAttr(containerEle, 'nav-bar', isActive ? 'active' : 'cached');\n\n    var alignTitle = $attrs.alignTitle || $ionicConfig.navBar.alignTitle();\n    var headerBarEle = jqLite('<ion-header-bar>').addClass($attrs['class']).attr('align-title', alignTitle);\n    if (isDefined($attrs.noTapScroll)) headerBarEle.attr('no-tap-scroll', $attrs.noTapScroll);\n    var titleEle = jqLite('<div class=\"title title-' + alignTitle + '\">');\n    var navEle = {};\n    var lastViewItemEle = {};\n    var leftButtonsEle, rightButtonsEle;\n\n    navEle[BACK_BUTTON] = createNavElement(BACK_BUTTON);\n    navEle[BACK_BUTTON] && headerBarEle.append(navEle[BACK_BUTTON]);\n\n    // append title in the header, this is the rock to where buttons append\n    headerBarEle.append(titleEle);\n\n    forEach(ITEM_TYPES, function(itemType) {\n      // create default button elements\n      navEle[itemType] = createNavElement(itemType);\n      // append and position buttons\n      positionItem(navEle[itemType], itemType);\n    });\n\n    // add header-item to the root children\n    for (var x = 0; x < headerBarEle[0].children.length; x++) {\n      headerBarEle[0].children[x].classList.add('header-item');\n    }\n\n    // compile header and append to the DOM\n    containerEle.append(headerBarEle);\n    $element.append($compile(containerEle)($scope.$new()));\n\n    var headerBarCtrl = headerBarEle.data('$ionHeaderBarController');\n    headerBarCtrl.backButtonIcon = $ionicConfig.backButton.icon();\n    headerBarCtrl.backButtonText = $ionicConfig.backButton.text();\n\n    var headerBarInstance = {\n      isActive: isActive,\n      title: function(newTitleText) {\n        headerBarCtrl.title(newTitleText);\n      },\n      setItem: function(navBarItemEle, itemType) {\n        // first make sure any exiting nav bar item has been removed\n        headerBarInstance.removeItem(itemType);\n\n        if (navBarItemEle) {\n          if (itemType === 'title') {\n            // clear out the text based title\n            headerBarInstance.title(\"\");\n          }\n\n          // there's a custom nav bar item\n          positionItem(navBarItemEle, itemType);\n\n          if (navEle[itemType]) {\n            // make sure the default on this itemType is hidden\n            navEle[itemType].addClass(CSS_HIDE);\n          }\n          lastViewItemEle[itemType] = navBarItemEle;\n\n        } else if (navEle[itemType]) {\n          // there's a default button for this side and no view button\n          navEle[itemType].removeClass(CSS_HIDE);\n        }\n      },\n      removeItem: function(itemType) {\n        if (lastViewItemEle[itemType]) {\n          lastViewItemEle[itemType].scope().$destroy();\n          lastViewItemEle[itemType].remove();\n          lastViewItemEle[itemType] = null;\n        }\n      },\n      containerEle: function() {\n        return containerEle;\n      },\n      headerBarEle: function() {\n        return headerBarEle;\n      },\n      afterLeave: function() {\n        forEach(ITEM_TYPES, function(itemType) {\n          headerBarInstance.removeItem(itemType);\n        });\n        headerBarCtrl.resetBackButton();\n      },\n      controller: function() {\n        return headerBarCtrl;\n      },\n      destroy: function() {\n        forEach(ITEM_TYPES, function(itemType) {\n          headerBarInstance.removeItem(itemType);\n        });\n        containerEle.scope().$destroy();\n        for (var n in navEle) {\n          if (navEle[n]) {\n            navEle[n].removeData();\n            navEle[n] = null;\n          }\n        }\n        leftButtonsEle && leftButtonsEle.removeData();\n        rightButtonsEle && rightButtonsEle.removeData();\n        titleEle.removeData();\n        headerBarEle.removeData();\n        containerEle.remove();\n        containerEle = headerBarEle = titleEle = leftButtonsEle = rightButtonsEle = null;\n      }\n    };\n\n    function positionItem(ele, itemType) {\n      if (!ele) return;\n\n      if (itemType === 'title') {\n        // title element\n        titleEle.append(ele);\n\n      } else if (itemType == 'rightButtons' ||\n                (itemType == SECONDARY_BUTTONS && $ionicConfig.navBar.positionSecondaryButtons() != 'left') ||\n                (itemType == PRIMARY_BUTTONS && $ionicConfig.navBar.positionPrimaryButtons() == 'right')) {\n        // right side\n        if (!rightButtonsEle) {\n          rightButtonsEle = jqLite('<div class=\"buttons buttons-right\">');\n          headerBarEle.append(rightButtonsEle);\n        }\n        if (itemType == SECONDARY_BUTTONS) {\n          rightButtonsEle.append(ele);\n        } else {\n          rightButtonsEle.prepend(ele);\n        }\n\n      } else {\n        // left side\n        if (!leftButtonsEle) {\n          leftButtonsEle = jqLite('<div class=\"buttons buttons-left\">');\n          if (navEle[BACK_BUTTON]) {\n            navEle[BACK_BUTTON].after(leftButtonsEle);\n          } else {\n            headerBarEle.prepend(leftButtonsEle);\n          }\n        }\n        if (itemType == SECONDARY_BUTTONS) {\n          leftButtonsEle.append(ele);\n        } else {\n          leftButtonsEle.prepend(ele);\n        }\n      }\n\n    }\n\n    headerBars.push(headerBarInstance);\n\n    return headerBarInstance;\n  };\n\n\n  self.navElement = function(type, html) {\n    if (isDefined(html)) {\n      navElementHtml[type] = html;\n    }\n    return navElementHtml[type];\n  };\n\n\n  self.update = function(viewData) {\n    var showNavBar = !viewData.hasHeaderBar && viewData.showNavBar;\n    viewData.transition = $ionicConfig.views.transition();\n\n    if (!showNavBar) {\n      viewData.direction = 'none';\n    }\n\n    self.enable(showNavBar);\n    var enteringHeaderBar = self.isInitialized ? getOffScreenHeaderBar() : getOnScreenHeaderBar();\n    var leavingHeaderBar = self.isInitialized ? getOnScreenHeaderBar() : null;\n    var enteringHeaderCtrl = enteringHeaderBar.controller();\n\n    // update if the entering header should show the back button or not\n    enteringHeaderCtrl.enableBack(viewData.enableBack, true);\n    enteringHeaderCtrl.showBack(viewData.showBack, true);\n    enteringHeaderCtrl.updateBackButton();\n\n    // update the entering header bar's title\n    self.title(viewData.title, enteringHeaderBar);\n\n    self.showBar(showNavBar);\n\n    // update the nav bar items, depending if the view has their own or not\n    if (viewData.navBarItems) {\n      forEach(ITEM_TYPES, function(itemType) {\n        enteringHeaderBar.setItem(viewData.navBarItems[itemType], itemType);\n      });\n    }\n\n    // begin transition of entering and leaving header bars\n    self.transition(enteringHeaderBar, leavingHeaderBar, viewData);\n\n    self.isInitialized = true;\n    navSwipeAttr('');\n  };\n\n\n  self.transition = function(enteringHeaderBar, leavingHeaderBar, viewData) {\n    var enteringHeaderBarCtrl = enteringHeaderBar.controller();\n    var transitionFn = $ionicConfig.transitions.navBar[viewData.navBarTransition] || $ionicConfig.transitions.navBar.none;\n    var transitionId = viewData.transitionId;\n\n    enteringHeaderBarCtrl.beforeEnter(viewData);\n\n    var navBarTransition = transitionFn(enteringHeaderBar, leavingHeaderBar, viewData.direction, viewData.shouldAnimate && self.isInitialized);\n\n    ionic.DomUtil.cachedAttr($element, 'nav-bar-transition', viewData.navBarTransition);\n    ionic.DomUtil.cachedAttr($element, 'nav-bar-direction', viewData.direction);\n\n    if (navBarTransition.shouldAnimate && viewData.renderEnd) {\n      navBarAttr(enteringHeaderBar, 'stage');\n    } else {\n      navBarAttr(enteringHeaderBar, 'entering');\n      navBarAttr(leavingHeaderBar, 'leaving');\n    }\n\n    enteringHeaderBarCtrl.resetBackButton(viewData);\n\n    navBarTransition.run(0);\n\n    self.activeTransition = {\n      run: function(step) {\n        navBarTransition.shouldAnimate = false;\n        navBarTransition.direction = 'back';\n        navBarTransition.run(step);\n      },\n      cancel: function(shouldAnimate, speed, cancelData) {\n        navSwipeAttr(speed);\n        navBarAttr(leavingHeaderBar, 'active');\n        navBarAttr(enteringHeaderBar, 'cached');\n        navBarTransition.shouldAnimate = shouldAnimate;\n        navBarTransition.run(0);\n        self.activeTransition = navBarTransition = null;\n\n        var runApply;\n        if (cancelData.showBar !== self.showBar()) {\n          self.showBar(cancelData.showBar);\n        }\n        if (cancelData.showBackButton !== self.showBackButton()) {\n          self.showBackButton(cancelData.showBackButton);\n        }\n        if (runApply) {\n          $scope.$apply();\n        }\n      },\n      complete: function(shouldAnimate, speed) {\n        navSwipeAttr(speed);\n        navBarTransition.shouldAnimate = shouldAnimate;\n        navBarTransition.run(1);\n        queuedTransitionEnd = transitionEnd;\n      }\n    };\n\n    $timeout(enteringHeaderBarCtrl.align, 16);\n\n    queuedTransitionStart = function() {\n      if (latestTransitionId !== transitionId) return;\n\n      navBarAttr(enteringHeaderBar, 'entering');\n      navBarAttr(leavingHeaderBar, 'leaving');\n\n      navBarTransition.run(1);\n\n      queuedTransitionEnd = function() {\n        if (latestTransitionId == transitionId || !navBarTransition.shouldAnimate) {\n          transitionEnd();\n        }\n      };\n\n      queuedTransitionStart = null;\n    };\n\n    function transitionEnd() {\n      for (var x = 0; x < headerBars.length; x++) {\n        headerBars[x].isActive = false;\n      }\n      enteringHeaderBar.isActive = true;\n\n      navBarAttr(enteringHeaderBar, 'active');\n      navBarAttr(leavingHeaderBar, 'cached');\n\n      self.activeTransition = navBarTransition = queuedTransitionEnd = null;\n    }\n\n    queuedTransitionStart();\n  };\n\n\n  self.triggerTransitionStart = function(triggerTransitionId) {\n    latestTransitionId = triggerTransitionId;\n    queuedTransitionStart && queuedTransitionStart();\n  };\n\n\n  self.triggerTransitionEnd = function() {\n    queuedTransitionEnd && queuedTransitionEnd();\n  };\n\n\n  self.showBar = function(shouldShow) {\n    if (arguments.length) {\n      self.visibleBar(shouldShow);\n      $scope.$parent.$hasHeader = !!shouldShow;\n    }\n    return !!$scope.$parent.$hasHeader;\n  };\n\n\n  self.visibleBar = function(shouldShow) {\n    if (shouldShow && !isVisible) {\n      $element.removeClass(CSS_HIDE);\n      self.align();\n    } else if (!shouldShow && isVisible) {\n      $element.addClass(CSS_HIDE);\n    }\n    isVisible = shouldShow;\n  };\n\n\n  self.enable = function(val) {\n    // set primary to show first\n    self.visibleBar(val);\n\n    // set non primary to hide second\n    for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {\n      if ($ionicNavBarDelegate._instances[x] !== self) $ionicNavBarDelegate._instances[x].visibleBar(false);\n    }\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $ionicNavBar#showBackButton\n   * @description Show/hide the nav bar back button when there is a\n   * back view. If the back button is not possible, for example, the\n   * first view in the stack, then this will not force the back button\n   * to show.\n   */\n  self.showBackButton = function(shouldShow) {\n    if (arguments.length) {\n      for (var x = 0; x < headerBars.length; x++) {\n        headerBars[x].controller().showNavBack(!!shouldShow);\n      }\n      $scope.$isBackButtonShown = !!shouldShow;\n    }\n    return $scope.$isBackButtonShown;\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $ionicNavBar#showActiveBackButton\n   * @description Show/hide only the active header bar's back button.\n   */\n  self.showActiveBackButton = function(shouldShow) {\n    var headerBar = getOnScreenHeaderBar();\n    if (headerBar) {\n      if (arguments.length) {\n        return headerBar.controller().showBack(shouldShow);\n      }\n      return headerBar.controller().showBack();\n    }\n  };\n\n\n  self.title = function(newTitleText, headerBar) {\n    if (isDefined(newTitleText)) {\n      newTitleText = newTitleText || '';\n      headerBar = headerBar || getOnScreenHeaderBar();\n      headerBar && headerBar.title(newTitleText);\n      $scope.$title = newTitleText;\n      $ionicHistory.currentTitle(newTitleText);\n    }\n    return $scope.$title;\n  };\n\n\n  self.align = function(val, headerBar) {\n    headerBar = headerBar || getOnScreenHeaderBar();\n    headerBar && headerBar.controller().align(val);\n  };\n\n\n  self.hasTabsTop = function(isTabsTop) {\n    $element[isTabsTop ? 'addClass' : 'removeClass']('nav-bar-tabs-top');\n  };\n\n  self.hasBarSubheader = function(isBarSubheader) {\n    $element[isBarSubheader ? 'addClass' : 'removeClass']('nav-bar-has-subheader');\n  };\n\n  // DEPRECATED, as of v1.0.0-beta14 -------\n  self.changeTitle = function(val) {\n    deprecatedWarning('changeTitle(val)', 'title(val)');\n    self.title(val);\n  };\n  self.setTitle = function(val) {\n    deprecatedWarning('setTitle(val)', 'title(val)');\n    self.title(val);\n  };\n  self.getTitle = function() {\n    deprecatedWarning('getTitle()', 'title()');\n    return self.title();\n  };\n  self.back = function() {\n    deprecatedWarning('back()', '$ionicHistory.goBack()');\n    $ionicHistory.goBack();\n  };\n  self.getPreviousTitle = function() {\n    deprecatedWarning('getPreviousTitle()', '$ionicHistory.backTitle()');\n    $ionicHistory.goBack();\n  };\n  function deprecatedWarning(oldMethod, newMethod) {\n    var warn = console.warn || console.log;\n    warn && warn.call(console, 'navBarController.' + oldMethod + ' is deprecated, please use ' + newMethod + ' instead');\n  }\n  // END DEPRECATED -------\n\n\n  function createNavElement(type) {\n    if (navElementHtml[type]) {\n      return jqLite(navElementHtml[type]);\n    }\n  }\n\n\n  function getOnScreenHeaderBar() {\n    for (var x = 0; x < headerBars.length; x++) {\n      if (headerBars[x].isActive) return headerBars[x];\n    }\n  }\n\n\n  function getOffScreenHeaderBar() {\n    for (var x = 0; x < headerBars.length; x++) {\n      if (!headerBars[x].isActive) return headerBars[x];\n    }\n  }\n\n\n  function navBarAttr(ctrl, val) {\n    ctrl && ionic.DomUtil.cachedAttr(ctrl.containerEle(), 'nav-bar', val);\n  }\n\n  function navSwipeAttr(val) {\n    ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);\n  }\n\n\n  $scope.$on('$destroy', function() {\n    $scope.$parent.$hasHeader = false;\n    $element.parent().removeData(DATA_NAV_BAR_CTRL);\n    for (var x = 0; x < headerBars.length; x++) {\n      headerBars[x].destroy();\n    }\n    $element.remove();\n    $element = headerBars = null;\n    deregisterInstance();\n  });\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/navBarController.js\n ** module id = 33\n ** module chunks = 0\n **/","IonicModule\n.controller('$ionicNavView', [\n  '$scope',\n  '$element',\n  '$attrs',\n  '$compile',\n  '$controller',\n  '$ionicNavBarDelegate',\n  '$ionicNavViewDelegate',\n  '$ionicHistory',\n  '$ionicViewSwitcher',\n  '$ionicConfig',\n  '$ionicScrollDelegate',\nfunction($scope, $element, $attrs, $compile, $controller, $ionicNavBarDelegate, $ionicNavViewDelegate, $ionicHistory, $ionicViewSwitcher, $ionicConfig, $ionicScrollDelegate) {\n\n  var DATA_ELE_IDENTIFIER = '$eleId';\n  var DATA_DESTROY_ELE = '$destroyEle';\n  var DATA_NO_CACHE = '$noCache';\n  var VIEW_STATUS_ACTIVE = 'active';\n  var VIEW_STATUS_CACHED = 'cached';\n\n  var self = this;\n  var direction;\n  var isPrimary = false;\n  var navBarDelegate;\n  var activeEleId;\n  var navViewAttr = $ionicViewSwitcher.navViewAttr;\n  var disableRenderStartViewId, disableAnimation;\n\n  self.scope = $scope;\n  self.element = $element;\n\n  self.init = function() {\n    var navViewName = $attrs.name || '';\n\n    // Find the details of the parent view directive (if any) and use it\n    // to derive our own qualified view name, then hang our own details\n    // off the DOM so child directives can find it.\n    var parent = $element.parent().inheritedData('$uiView');\n    var parentViewName = ((parent && parent.state) ? parent.state.name : '');\n    if (navViewName.indexOf('@') < 0) navViewName = navViewName + '@' + parentViewName;\n\n    var viewData = { name: navViewName, state: null };\n    $element.data('$uiView', viewData);\n\n    var deregisterInstance = $ionicNavViewDelegate._registerInstance(self, $attrs.delegateHandle);\n    $scope.$on('$destroy', function() {\n      deregisterInstance();\n\n      // ensure no scrolls have been left frozen\n      if (self.isSwipeFreeze) {\n        $ionicScrollDelegate.freezeAllScrolls(false);\n      }\n    });\n\n    $scope.$on('$ionicHistory.deselect', self.cacheCleanup);\n    $scope.$on('$ionicTabs.top', onTabsTop);\n    $scope.$on('$ionicSubheader', onBarSubheader);\n\n    $scope.$on('$ionicTabs.beforeLeave', onTabsLeave);\n    $scope.$on('$ionicTabs.afterLeave', onTabsLeave);\n    $scope.$on('$ionicTabs.leave', onTabsLeave);\n\n    ionic.Platform.ready(function() {\n      if (ionic.Platform.isWebView() && $ionicConfig.views.swipeBackEnabled()) {\n        self.initSwipeBack();\n      }\n    });\n\n    return viewData;\n  };\n\n\n  self.register = function(viewLocals) {\n    var leavingView = extend({}, $ionicHistory.currentView());\n\n    // register that a view is coming in and get info on how it should transition\n    var registerData = $ionicHistory.register($scope, viewLocals);\n\n    // update which direction\n    self.update(registerData);\n\n    // begin rendering and transitioning\n    var enteringView = $ionicHistory.getViewById(registerData.viewId) || {};\n\n    var renderStart = (disableRenderStartViewId !== registerData.viewId);\n    self.render(registerData, viewLocals, enteringView, leavingView, renderStart, true);\n  };\n\n\n  self.update = function(registerData) {\n    // always reset that this is the primary navView\n    isPrimary = true;\n\n    // remember what direction this navView should use\n    // this may get updated later by a child navView\n    direction = registerData.direction;\n\n    var parentNavViewCtrl = $element.parent().inheritedData('$ionNavViewController');\n    if (parentNavViewCtrl) {\n      // this navView is nested inside another one\n      // update the parent to use this direction and not\n      // the other it originally was set to\n\n      // inform the parent navView that it is not the primary navView\n      parentNavViewCtrl.isPrimary(false);\n\n      if (direction === 'enter' || direction === 'exit') {\n        // they're entering/exiting a history\n        // find parent navViewController\n        parentNavViewCtrl.direction(direction);\n\n        if (direction === 'enter') {\n          // reset the direction so this navView doesn't animate\n          // because it's parent will\n          direction = 'none';\n        }\n      }\n    }\n  };\n\n\n  self.render = function(registerData, viewLocals, enteringView, leavingView, renderStart, renderEnd) {\n    // register the view and figure out where it lives in the various\n    // histories and nav stacks, along with how views should enter/leave\n    var switcher = $ionicViewSwitcher.create(self, viewLocals, enteringView, leavingView, renderStart, renderEnd);\n\n    // init the rendering of views for this navView directive\n    switcher.init(registerData, function() {\n      // the view is now compiled, in the dom and linked, now lets transition the views.\n      // this uses a callback incase THIS nav-view has a nested nav-view, and after the NESTED\n      // nav-view links, the NESTED nav-view would update which direction THIS nav-view should use\n\n      // kick off the transition of views\n      switcher.transition(self.direction(), registerData.enableBack, !disableAnimation);\n\n      // reset private vars for next time\n      disableRenderStartViewId = disableAnimation = null;\n    });\n\n  };\n\n\n  self.beforeEnter = function(transitionData) {\n    if (isPrimary) {\n      // only update this nav-view's nav-bar if this is the primary nav-view\n      navBarDelegate = transitionData.navBarDelegate;\n      var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n      associatedNavBarCtrl && associatedNavBarCtrl.update(transitionData);\n      navSwipeAttr('');\n    }\n  };\n\n\n  self.activeEleId = function(eleId) {\n    if (arguments.length) {\n      activeEleId = eleId;\n    }\n    return activeEleId;\n  };\n\n\n  self.transitionEnd = function() {\n    var viewElements = $element.children();\n    var x, l, viewElement;\n\n    for (x = 0, l = viewElements.length; x < l; x++) {\n      viewElement = viewElements.eq(x);\n\n      if (viewElement.data(DATA_ELE_IDENTIFIER) === activeEleId) {\n        // this is the active element\n        navViewAttr(viewElement, VIEW_STATUS_ACTIVE);\n\n      } else if (navViewAttr(viewElement) === 'leaving' || navViewAttr(viewElement) === VIEW_STATUS_ACTIVE || navViewAttr(viewElement) === VIEW_STATUS_CACHED) {\n        // this is a leaving element or was the former active element, or is an cached element\n        if (viewElement.data(DATA_DESTROY_ELE) || viewElement.data(DATA_NO_CACHE)) {\n          // this element shouldn't stay cached\n          $ionicViewSwitcher.destroyViewEle(viewElement);\n\n        } else {\n          // keep in the DOM, mark as cached\n          navViewAttr(viewElement, VIEW_STATUS_CACHED);\n\n          // disconnect the leaving scope\n          ionic.Utils.disconnectScope(viewElement.scope());\n        }\n      }\n    }\n\n    navSwipeAttr('');\n\n    // ensure no scrolls have been left frozen\n    if (self.isSwipeFreeze) {\n      $ionicScrollDelegate.freezeAllScrolls(false);\n    }\n  };\n\n\n  function onTabsLeave(ev, data) {\n    var viewElements = $element.children();\n    var viewElement, viewScope;\n\n    for (var x = 0, l = viewElements.length; x < l; x++) {\n      viewElement = viewElements.eq(x);\n      if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {\n        viewScope = viewElement.scope();\n        viewScope && viewScope.$emit(ev.name.replace('Tabs', 'View'), data);\n        break;\n      }\n    }\n  }\n\n\n  self.cacheCleanup = function() {\n    var viewElements = $element.children();\n    for (var x = 0, l = viewElements.length; x < l; x++) {\n      if (viewElements.eq(x).data(DATA_DESTROY_ELE)) {\n        $ionicViewSwitcher.destroyViewEle(viewElements.eq(x));\n      }\n    }\n  };\n\n\n  self.clearCache = function(stateIds) {\n    var viewElements = $element.children();\n    var viewElement, viewScope, x, l, y, eleIdentifier;\n\n    for (x = 0, l = viewElements.length; x < l; x++) {\n      viewElement = viewElements.eq(x);\n\n      if (stateIds) {\n        eleIdentifier = viewElement.data(DATA_ELE_IDENTIFIER);\n\n        for (y = 0; y < stateIds.length; y++) {\n          if (eleIdentifier === stateIds[y]) {\n            $ionicViewSwitcher.destroyViewEle(viewElement);\n          }\n        }\n        continue;\n      }\n\n      if (navViewAttr(viewElement) == VIEW_STATUS_CACHED) {\n        $ionicViewSwitcher.destroyViewEle(viewElement);\n\n      } else if (navViewAttr(viewElement) == VIEW_STATUS_ACTIVE) {\n        viewScope = viewElement.scope();\n        viewScope && viewScope.$broadcast('$ionicView.clearCache');\n      }\n\n    }\n  };\n\n\n  self.getViewElements = function() {\n    return $element.children();\n  };\n\n\n  self.appendViewElement = function(viewEle, viewLocals) {\n    // compile the entering element and get the link function\n    var linkFn = $compile(viewEle);\n\n    $element.append(viewEle);\n\n    var viewScope = $scope.$new();\n\n    if (viewLocals && viewLocals.$$controller) {\n      viewLocals.$scope = viewScope;\n      var controller = $controller(viewLocals.$$controller, viewLocals);\n      if (viewLocals.$$controllerAs) {\n        viewScope[viewLocals.$$controllerAs] = controller;\n      }\n      $element.children().data('$ngControllerController', controller);\n    }\n\n    linkFn(viewScope);\n\n    return viewScope;\n  };\n\n\n  self.title = function(val) {\n    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n    associatedNavBarCtrl && associatedNavBarCtrl.title(val);\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $ionicNavView#enableBackButton\n   * @description Enable/disable if the back button can be shown or not. For\n   * example, the very first view in the navigation stack would not have a\n   * back view, so the back button would be disabled.\n   */\n  self.enableBackButton = function(shouldEnable) {\n    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n    associatedNavBarCtrl && associatedNavBarCtrl.enableBackButton(shouldEnable);\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $ionicNavView#showBackButton\n   * @description Show/hide the nav bar active back button. If the back button\n   * is not possible this will not force the back button to show. The\n   * `enableBackButton()` method handles if a back button is even possible or not.\n   */\n  self.showBackButton = function(shouldShow) {\n    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n    if (associatedNavBarCtrl) {\n      if (arguments.length) {\n        return associatedNavBarCtrl.showActiveBackButton(shouldShow);\n      }\n      return associatedNavBarCtrl.showActiveBackButton();\n    }\n    return true;\n  };\n\n\n  self.showBar = function(val) {\n    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n    if (associatedNavBarCtrl) {\n      if (arguments.length) {\n        return associatedNavBarCtrl.showBar(val);\n      }\n      return associatedNavBarCtrl.showBar();\n    }\n    return true;\n  };\n\n\n  self.isPrimary = function(val) {\n    if (arguments.length) {\n      isPrimary = val;\n    }\n    return isPrimary;\n  };\n\n\n  self.direction = function(val) {\n    if (arguments.length) {\n      direction = val;\n    }\n    return direction;\n  };\n\n\n  self.initSwipeBack = function() {\n    var swipeBackHitWidth = $ionicConfig.views.swipeBackHitWidth();\n    var viewTransition, associatedNavBarCtrl, backView;\n    var deregDragStart, deregDrag, deregRelease;\n    var windowWidth, startDragX, dragPoints;\n    var cancelData = {};\n\n    function onDragStart(ev) {\n      if (!isPrimary) return;\n\n      startDragX = getDragX(ev);\n      if (startDragX > swipeBackHitWidth) return;\n\n      backView = $ionicHistory.backView();\n\n      var currentView = $ionicHistory.currentView();\n\n      if (!backView || backView.historyId !== currentView.historyId || currentView.canSwipeBack === false) return;\n\n      if (!windowWidth) windowWidth = window.innerWidth;\n\n      self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(true);\n\n      var registerData = {\n        direction: 'back'\n      };\n\n      dragPoints = [];\n\n      cancelData = {\n        showBar: self.showBar(),\n        showBackButton: self.showBackButton()\n      };\n\n      var switcher = $ionicViewSwitcher.create(self, registerData, backView, currentView, true, false);\n      switcher.loadViewElements(registerData);\n      switcher.render(registerData);\n\n      viewTransition = switcher.transition('back', $ionicHistory.enabledBack(backView), true);\n\n      associatedNavBarCtrl = getAssociatedNavBarCtrl();\n\n      deregDrag = ionic.onGesture('drag', onDrag, $element[0]);\n      deregRelease = ionic.onGesture('release', onRelease, $element[0]);\n    }\n\n    function onDrag(ev) {\n      if (isPrimary && viewTransition) {\n        var dragX = getDragX(ev);\n\n        dragPoints.push({\n          t: Date.now(),\n          x: dragX\n        });\n\n        if (dragX >= windowWidth - 15) {\n          onRelease(ev);\n\n        } else {\n          var step = Math.min(Math.max(getSwipeCompletion(dragX), 0), 1);\n          viewTransition.run(step);\n          associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.run(step);\n        }\n\n      }\n    }\n\n    function onRelease(ev) {\n      if (isPrimary && viewTransition && dragPoints && dragPoints.length > 1) {\n\n        var now = Date.now();\n        var releaseX = getDragX(ev);\n        var startDrag = dragPoints[dragPoints.length - 1];\n\n        for (var x = dragPoints.length - 2; x >= 0; x--) {\n          if (now - startDrag.t > 200) {\n            break;\n          }\n          startDrag = dragPoints[x];\n        }\n\n        var isSwipingRight = (releaseX >= dragPoints[dragPoints.length - 2].x);\n        var releaseSwipeCompletion = getSwipeCompletion(releaseX);\n        var velocity = Math.abs(startDrag.x - releaseX) / (now - startDrag.t);\n\n        // private variables because ui-router has no way to pass custom data using $state.go\n        disableRenderStartViewId = backView.viewId;\n        disableAnimation = (releaseSwipeCompletion < 0.03 || releaseSwipeCompletion > 0.97);\n\n        if (isSwipingRight && (releaseSwipeCompletion > 0.5 || velocity > 0.1)) {\n          // complete view transition on release\n          var speed = (velocity > 0.5 || velocity < 0.05 || releaseX > windowWidth - 45) ? 'fast' : 'slow';\n          navSwipeAttr(disableAnimation ? '' : speed);\n          backView.go();\n          associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.complete(!disableAnimation, speed);\n\n        } else {\n          // cancel view transition on release\n          navSwipeAttr(disableAnimation ? '' : 'fast');\n          disableRenderStartViewId = null;\n          viewTransition.cancel(!disableAnimation);\n          associatedNavBarCtrl && associatedNavBarCtrl.activeTransition && associatedNavBarCtrl.activeTransition.cancel(!disableAnimation, 'fast', cancelData);\n          disableAnimation = null;\n        }\n\n      }\n\n      ionic.offGesture(deregDrag, 'drag', onDrag);\n      ionic.offGesture(deregRelease, 'release', onRelease);\n\n      windowWidth = viewTransition = dragPoints = null;\n\n      self.isSwipeFreeze = $ionicScrollDelegate.freezeAllScrolls(false);\n    }\n\n    function getDragX(ev) {\n      return ionic.tap.pointerCoord(ev.gesture.srcEvent).x;\n    }\n\n    function getSwipeCompletion(dragX) {\n      return (dragX - startDragX) / windowWidth;\n    }\n\n    deregDragStart = ionic.onGesture('dragstart', onDragStart, $element[0]);\n\n    $scope.$on('$destroy', function() {\n      ionic.offGesture(deregDragStart, 'dragstart', onDragStart);\n      ionic.offGesture(deregDrag, 'drag', onDrag);\n      ionic.offGesture(deregRelease, 'release', onRelease);\n      self.element = viewTransition = associatedNavBarCtrl = null;\n    });\n  };\n\n\n  function navSwipeAttr(val) {\n    ionic.DomUtil.cachedAttr($element, 'nav-swipe', val);\n  }\n\n\n  function onTabsTop(ev, isTabsTop) {\n    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n    associatedNavBarCtrl && associatedNavBarCtrl.hasTabsTop(isTabsTop);\n  }\n\n  function onBarSubheader(ev, isBarSubheader) {\n    var associatedNavBarCtrl = getAssociatedNavBarCtrl();\n    associatedNavBarCtrl && associatedNavBarCtrl.hasBarSubheader(isBarSubheader);\n  }\n\n  function getAssociatedNavBarCtrl() {\n    if (navBarDelegate) {\n      for (var x = 0; x < $ionicNavBarDelegate._instances.length; x++) {\n        if ($ionicNavBarDelegate._instances[x].$$delegateHandle == navBarDelegate) {\n          return $ionicNavBarDelegate._instances[x];\n        }\n      }\n    }\n    return $element.inheritedData('$ionNavBarController');\n  }\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/navViewController.js\n ** module id = 34\n ** module chunks = 0\n **/","IonicModule\r\n.controller('$ionicRefresher', [\r\n  '$scope',\r\n  '$attrs',\r\n  '$element',\r\n  '$ionicBind',\r\n  '$timeout',\r\n  function($scope, $attrs, $element, $ionicBind, $timeout) {\r\n    var self = this,\r\n        isDragging = false,\r\n        isOverscrolling = false,\r\n        dragOffset = 0,\r\n        lastOverscroll = 0,\r\n        ptrThreshold = 60,\r\n        activated = false,\r\n        scrollTime = 500,\r\n        startY = null,\r\n        deltaY = null,\r\n        canOverscroll = true,\r\n        scrollParent,\r\n        scrollChild;\r\n\r\n    if (!isDefined($attrs.pullingIcon)) {\r\n      $attrs.$set('pullingIcon', 'ion-android-arrow-down');\r\n    }\r\n\r\n    $scope.showSpinner = !isDefined($attrs.refreshingIcon) && $attrs.spinner != 'none';\r\n\r\n    $scope.showIcon = isDefined($attrs.refreshingIcon);\r\n\r\n    $ionicBind($scope, $attrs, {\r\n      pullingIcon: '@',\r\n      pullingText: '@',\r\n      refreshingIcon: '@',\r\n      refreshingText: '@',\r\n      spinner: '@',\r\n      disablePullingRotation: '@',\r\n      $onRefresh: '&onRefresh',\r\n      $onPulling: '&onPulling'\r\n    });\r\n\r\n    function handleMousedown(e) {\r\n      e.touches = e.touches || [{\r\n        screenX: e.screenX,\r\n        screenY: e.screenY\r\n      }];\r\n      // Mouse needs this\r\n      startY = Math.floor(e.touches[0].screenY);\r\n    }\r\n\r\n    function handleTouchstart(e) {\r\n      e.touches = e.touches || [{\r\n        screenX: e.screenX,\r\n        screenY: e.screenY\r\n      }];\r\n\r\n      startY = e.touches[0].screenY;\r\n    }\r\n\r\n    function handleTouchend() {\r\n      // reset Y\r\n      startY = null;\r\n      // if this wasn't an overscroll, get out immediately\r\n      if (!canOverscroll && !isDragging) {\r\n        return;\r\n      }\r\n      // the user has overscrolled but went back to native scrolling\r\n      if (!isDragging) {\r\n        dragOffset = 0;\r\n        isOverscrolling = false;\r\n        setScrollLock(false);\r\n      } else {\r\n        isDragging = false;\r\n        dragOffset = 0;\r\n\r\n        // the user has scroll far enough to trigger a refresh\r\n        if (lastOverscroll > ptrThreshold) {\r\n          start();\r\n          scrollTo(ptrThreshold, scrollTime);\r\n\r\n        // the user has overscrolled but not far enough to trigger a refresh\r\n        } else {\r\n          scrollTo(0, scrollTime, deactivate);\r\n          isOverscrolling = false;\r\n        }\r\n      }\r\n    }\r\n\r\n    function handleTouchmove(e) {\r\n      e.touches = e.touches || [{\r\n        screenX: e.screenX,\r\n        screenY: e.screenY\r\n      }];\r\n\r\n      // Force mouse events to have had a down event first\r\n      if (!startY && e.type == 'mousemove') {\r\n        return;\r\n      }\r\n\r\n      // if multitouch or regular scroll event, get out immediately\r\n      if (!canOverscroll || e.touches.length > 1) {\r\n        return;\r\n      }\r\n      //if this is a new drag, keep track of where we start\r\n      if (startY === null) {\r\n        startY = e.touches[0].screenY;\r\n      }\r\n\r\n      deltaY = e.touches[0].screenY - startY;\r\n\r\n      // how far have we dragged so far?\r\n      // kitkat fix for touchcancel events http://updates.html5rocks.com/2014/05/A-More-Compatible-Smoother-Touch\r\n      // Only do this if we're not on crosswalk\r\n      if (ionic.Platform.isAndroid() && ionic.Platform.version() === 4.4 && !ionic.Platform.isCrosswalk() && scrollParent.scrollTop === 0 && deltaY > 0) {\r\n        isDragging = true;\r\n        e.preventDefault();\r\n      }\r\n\r\n\r\n      // if we've dragged up and back down in to native scroll territory\r\n      if (deltaY - dragOffset <= 0 || scrollParent.scrollTop !== 0) {\r\n\r\n        if (isOverscrolling) {\r\n          isOverscrolling = false;\r\n          setScrollLock(false);\r\n        }\r\n\r\n        if (isDragging) {\r\n          nativescroll(scrollParent, deltaY - dragOffset * -1);\r\n        }\r\n\r\n        // if we're not at overscroll 0 yet, 0 out\r\n        if (lastOverscroll !== 0) {\r\n          overscroll(0);\r\n        }\r\n        return;\r\n\r\n      } else if (deltaY > 0 && scrollParent.scrollTop === 0 && !isOverscrolling) {\r\n        // starting overscroll, but drag started below scrollTop 0, so we need to offset the position\r\n        dragOffset = deltaY;\r\n      }\r\n\r\n      // prevent native scroll events while overscrolling\r\n      e.preventDefault();\r\n\r\n      // if not overscrolling yet, initiate overscrolling\r\n      if (!isOverscrolling) {\r\n        isOverscrolling = true;\r\n        setScrollLock(true);\r\n      }\r\n\r\n      isDragging = true;\r\n      // overscroll according to the user's drag so far\r\n      overscroll((deltaY - dragOffset) / 3);\r\n\r\n      // update the icon accordingly\r\n      if (!activated && lastOverscroll > ptrThreshold) {\r\n        activated = true;\r\n        ionic.requestAnimationFrame(activate);\r\n\r\n      } else if (activated && lastOverscroll < ptrThreshold) {\r\n        activated = false;\r\n        ionic.requestAnimationFrame(deactivate);\r\n      }\r\n    }\r\n\r\n    function handleScroll(e) {\r\n      // canOverscrol is used to greatly simplify the drag handler during normal scrolling\r\n      canOverscroll = (e.target.scrollTop === 0) || isDragging;\r\n    }\r\n\r\n    function overscroll(val) {\r\n      scrollChild.style[ionic.CSS.TRANSFORM] = 'translateY(' + val + 'px)';\r\n      lastOverscroll = val;\r\n    }\r\n\r\n    function nativescroll(target, newScrollTop) {\r\n      // creates a scroll event that bubbles, can be cancelled, and with its view\r\n      // and detail property initialized to window and 1, respectively\r\n      target.scrollTop = newScrollTop;\r\n      var e = document.createEvent(\"UIEvents\");\r\n      e.initUIEvent(\"scroll\", true, true, window, 1);\r\n      target.dispatchEvent(e);\r\n    }\r\n\r\n    function setScrollLock(enabled) {\r\n      // set the scrollbar to be position:fixed in preparation to overscroll\r\n      // or remove it so the app can be natively scrolled\r\n      if (enabled) {\r\n        ionic.requestAnimationFrame(function() {\r\n          scrollChild.classList.add('overscroll');\r\n          show();\r\n        });\r\n\r\n      } else {\r\n        ionic.requestAnimationFrame(function() {\r\n          scrollChild.classList.remove('overscroll');\r\n          hide();\r\n          deactivate();\r\n        });\r\n      }\r\n    }\r\n\r\n    $scope.$on('scroll.refreshComplete', function() {\r\n      // prevent the complete from firing before the scroll has started\r\n      $timeout(function() {\r\n\r\n        ionic.requestAnimationFrame(tail);\r\n\r\n        // scroll back to home during tail animation\r\n        scrollTo(0, scrollTime, deactivate);\r\n\r\n        // return to native scrolling after tail animation has time to finish\r\n        $timeout(function() {\r\n\r\n          if (isOverscrolling) {\r\n            isOverscrolling = false;\r\n            setScrollLock(false);\r\n          }\r\n\r\n        }, scrollTime);\r\n\r\n      }, scrollTime);\r\n    });\r\n\r\n    function scrollTo(Y, duration, callback) {\r\n      // scroll animation loop w/ easing\r\n      // credit https://gist.github.com/dezinezync/5487119\r\n      var start = Date.now(),\r\n          from = lastOverscroll;\r\n\r\n      if (from === Y) {\r\n        callback();\r\n        return; /* Prevent scrolling to the Y point if already there */\r\n      }\r\n\r\n      // decelerating to zero velocity\r\n      function easeOutCubic(t) {\r\n        return (--t) * t * t + 1;\r\n      }\r\n\r\n      // scroll loop\r\n      function scroll() {\r\n        var currentTime = Date.now(),\r\n          time = Math.min(1, ((currentTime - start) / duration)),\r\n          // where .5 would be 50% of time on a linear scale easedT gives a\r\n          // fraction based on the easing method\r\n          easedT = easeOutCubic(time);\r\n\r\n        overscroll(Math.floor((easedT * (Y - from)) + from));\r\n\r\n        if (time < 1) {\r\n          ionic.requestAnimationFrame(scroll);\r\n\r\n        } else {\r\n\r\n          if (Y < 5 && Y > -5) {\r\n            isOverscrolling = false;\r\n            setScrollLock(false);\r\n          }\r\n\r\n          callback && callback();\r\n        }\r\n      }\r\n\r\n      // start scroll loop\r\n      ionic.requestAnimationFrame(scroll);\r\n    }\r\n\r\n\r\n    var touchStartEvent, touchMoveEvent, touchEndEvent;\r\n    if (window.navigator.pointerEnabled) {\r\n      touchStartEvent = 'pointerdown';\r\n      touchMoveEvent = 'pointermove';\r\n      touchEndEvent = 'pointerup';\r\n    } else if (window.navigator.msPointerEnabled) {\r\n      touchStartEvent = 'MSPointerDown';\r\n      touchMoveEvent = 'MSPointerMove';\r\n      touchEndEvent = 'MSPointerUp';\r\n    } else {\r\n      touchStartEvent = 'touchstart';\r\n      touchMoveEvent = 'touchmove';\r\n      touchEndEvent = 'touchend';\r\n    }\r\n\r\n    self.init = function() {\r\n      scrollParent = $element.parent().parent()[0];\r\n      scrollChild = $element.parent()[0];\r\n\r\n      if (!scrollParent || !scrollParent.classList.contains('ionic-scroll') ||\r\n        !scrollChild || !scrollChild.classList.contains('scroll')) {\r\n        throw new Error('Refresher must be immediate child of ion-content or ion-scroll');\r\n      }\r\n\r\n\r\n      ionic.on(touchStartEvent, handleTouchstart, scrollChild);\r\n      ionic.on(touchMoveEvent, handleTouchmove, scrollChild);\r\n      ionic.on(touchEndEvent, handleTouchend, scrollChild);\r\n      ionic.on('mousedown', handleMousedown, scrollChild);\r\n      ionic.on('mousemove', handleTouchmove, scrollChild);\r\n      ionic.on('mouseup', handleTouchend, scrollChild);\r\n      ionic.on('scroll', handleScroll, scrollParent);\r\n\r\n      // cleanup when done\r\n      $scope.$on('$destroy', destroy);\r\n    };\r\n\r\n    function destroy() {\r\n      ionic.off(touchStartEvent, handleTouchstart, scrollChild);\r\n      ionic.off(touchMoveEvent, handleTouchmove, scrollChild);\r\n      ionic.off(touchEndEvent, handleTouchend, scrollChild);\r\n      ionic.off('mousedown', handleMousedown, scrollChild);\r\n      ionic.off('mousemove', handleTouchmove, scrollChild);\r\n      ionic.off('mouseup', handleTouchend, scrollChild);\r\n      ionic.off('scroll', handleScroll, scrollParent);\r\n      scrollParent = null;\r\n      scrollChild = null;\r\n    }\r\n\r\n    // DOM manipulation and broadcast methods shared by JS and Native Scrolling\r\n    // getter used by JS Scrolling\r\n    self.getRefresherDomMethods = function() {\r\n      return {\r\n        activate: activate,\r\n        deactivate: deactivate,\r\n        start: start,\r\n        show: show,\r\n        hide: hide,\r\n        tail: tail\r\n      };\r\n    };\r\n\r\n    function activate() {\r\n      $element[0].classList.add('active');\r\n      $scope.$onPulling();\r\n    }\r\n\r\n    function deactivate() {\r\n      // give tail 150ms to finish\r\n      $timeout(function() {\r\n        // deactivateCallback\r\n        $element.removeClass('active refreshing refreshing-tail');\r\n        if (activated) activated = false;\r\n      }, 150);\r\n    }\r\n\r\n    function start() {\r\n      // startCallback\r\n      $element[0].classList.add('refreshing');\r\n      var q = $scope.$onRefresh();\r\n\r\n      if (q && q.then) {\r\n        q['finally'](function() {\r\n          $scope.$broadcast('scroll.refreshComplete');\r\n        });\r\n      }\r\n    }\r\n\r\n    function show() {\r\n      // showCallback\r\n      $element[0].classList.remove('invisible');\r\n    }\r\n\r\n    function hide() {\r\n      // showCallback\r\n      $element[0].classList.add('invisible');\r\n    }\r\n\r\n    function tail() {\r\n      // tailCallback\r\n      $element[0].classList.add('refreshing-tail');\r\n    }\r\n\r\n    // for testing\r\n    self.__handleTouchmove = handleTouchmove;\r\n    self.__getScrollChild = function() { return scrollChild; };\r\n    self.__getScrollParent = function() { return scrollParent; };\r\n  }\r\n]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/refresherController.js\n ** module id = 35\n ** module chunks = 0\n **/","/**\r\n * @private\r\n */\r\nIonicModule\r\n\r\n.controller('$ionicScroll', [\r\n  '$scope',\r\n  'scrollViewOptions',\r\n  '$timeout',\r\n  '$window',\r\n  '$location',\r\n  '$document',\r\n  '$ionicScrollDelegate',\r\n  '$ionicHistory',\r\nfunction($scope,\r\n         scrollViewOptions,\r\n         $timeout,\r\n         $window,\r\n         $location,\r\n         $document,\r\n         $ionicScrollDelegate,\r\n         $ionicHistory) {\r\n\r\n  var self = this;\r\n  // for testing\r\n  self.__timeout = $timeout;\r\n\r\n  self._scrollViewOptions = scrollViewOptions; //for testing\r\n  self.isNative = function() {\r\n    return !!scrollViewOptions.nativeScrolling;\r\n  };\r\n\r\n  var element = self.element = scrollViewOptions.el;\r\n  var $element = self.$element = jqLite(element);\r\n  var scrollView;\r\n  if (self.isNative()) {\r\n    scrollView = self.scrollView = new ionic.views.ScrollNative(scrollViewOptions);\r\n  } else {\r\n    scrollView = self.scrollView = new ionic.views.Scroll(scrollViewOptions);\r\n  }\r\n\r\n\r\n  //Attach self to element as a controller so other directives can require this controller\r\n  //through `require: '$ionicScroll'\r\n  //Also attach to parent so that sibling elements can require this\r\n  ($element.parent().length ? $element.parent() : $element)\r\n    .data('$$ionicScrollController', self);\r\n\r\n  var deregisterInstance = $ionicScrollDelegate._registerInstance(\r\n    self, scrollViewOptions.delegateHandle, function() {\r\n      return $ionicHistory.isActiveScope($scope);\r\n    }\r\n  );\r\n\r\n  if (!isDefined(scrollViewOptions.bouncing)) {\r\n    ionic.Platform.ready(function() {\r\n      if (scrollView && scrollView.options) {\r\n        scrollView.options.bouncing = true;\r\n        if (ionic.Platform.isAndroid()) {\r\n          // No bouncing by default on Android\r\n          scrollView.options.bouncing = false;\r\n          // Faster scroll decel\r\n          scrollView.options.deceleration = 0.95;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  var resize = angular.bind(scrollView, scrollView.resize);\r\n  angular.element($window).on('resize', resize);\r\n\r\n  var scrollFunc = function(e) {\r\n    var detail = (e.originalEvent || e).detail || {};\r\n    $scope.$onScroll && $scope.$onScroll({\r\n      event: e,\r\n      scrollTop: detail.scrollTop || 0,\r\n      scrollLeft: detail.scrollLeft || 0\r\n    });\r\n  };\r\n\r\n  $element.on('scroll', scrollFunc);\r\n\r\n  $scope.$on('$destroy', function() {\r\n    deregisterInstance();\r\n    scrollView && scrollView.__cleanup && scrollView.__cleanup();\r\n    angular.element($window).off('resize', resize);\r\n    $element.off('scroll', scrollFunc);\r\n    scrollView = self.scrollView = scrollViewOptions = self._scrollViewOptions = scrollViewOptions.el = self._scrollViewOptions.el = $element = self.$element = element = null;\r\n  });\r\n\r\n  $timeout(function() {\r\n    scrollView && scrollView.run && scrollView.run();\r\n  });\r\n\r\n  self.getScrollView = function() {\r\n    return scrollView;\r\n  };\r\n\r\n  self.getScrollPosition = function() {\r\n    return scrollView.getValues();\r\n  };\r\n\r\n  self.resize = function() {\r\n    return $timeout(resize, 0, false).then(function() {\r\n      $element && $element.triggerHandler('scroll-resize');\r\n    });\r\n  };\r\n\r\n  self.scrollTop = function(shouldAnimate) {\r\n    self.resize().then(function() {\r\n      if (!scrollView) {\r\n        return;\r\n      }\r\n      scrollView.scrollTo(0, 0, !!shouldAnimate);\r\n    });\r\n  };\r\n\r\n  self.scrollBottom = function(shouldAnimate) {\r\n    self.resize().then(function() {\r\n      if (!scrollView) {\r\n        return;\r\n      }\r\n      var max = scrollView.getScrollMax();\r\n      scrollView.scrollTo(max.left, max.top, !!shouldAnimate);\r\n    });\r\n  };\r\n\r\n  self.scrollTo = function(left, top, shouldAnimate) {\r\n    self.resize().then(function() {\r\n      if (!scrollView) {\r\n        return;\r\n      }\r\n      scrollView.scrollTo(left, top, !!shouldAnimate);\r\n    });\r\n  };\r\n\r\n  self.zoomTo = function(zoom, shouldAnimate, originLeft, originTop) {\r\n    self.resize().then(function() {\r\n      if (!scrollView) {\r\n        return;\r\n      }\r\n      scrollView.zoomTo(zoom, !!shouldAnimate, originLeft, originTop);\r\n    });\r\n  };\r\n\r\n  self.zoomBy = function(zoom, shouldAnimate, originLeft, originTop) {\r\n    self.resize().then(function() {\r\n      if (!scrollView) {\r\n        return;\r\n      }\r\n      scrollView.zoomBy(zoom, !!shouldAnimate, originLeft, originTop);\r\n    });\r\n  };\r\n\r\n  self.scrollBy = function(left, top, shouldAnimate) {\r\n    self.resize().then(function() {\r\n      if (!scrollView) {\r\n        return;\r\n      }\r\n      scrollView.scrollBy(left, top, !!shouldAnimate);\r\n    });\r\n  };\r\n\r\n  self.anchorScroll = function(shouldAnimate) {\r\n    self.resize().then(function() {\r\n      if (!scrollView) {\r\n        return;\r\n      }\r\n      var hash = $location.hash();\r\n      var elm = hash && $document[0].getElementById(hash);\r\n      if (!(hash && elm)) {\r\n        scrollView.scrollTo(0, 0, !!shouldAnimate);\r\n        return;\r\n      }\r\n      var curElm = elm;\r\n      var scrollLeft = 0, scrollTop = 0;\r\n      do {\r\n        if (curElm !== null) scrollLeft += curElm.offsetLeft;\r\n        if (curElm !== null) scrollTop += curElm.offsetTop;\r\n        curElm = curElm.offsetParent;\r\n      } while (curElm.attributes != self.element.attributes && curElm.offsetParent);\r\n      scrollView.scrollTo(scrollLeft, scrollTop, !!shouldAnimate);\r\n    });\r\n  };\r\n\r\n  self.freezeScroll = scrollView.freeze;\r\n  self.freezeScrollShut = scrollView.freezeShut;\r\n\r\n  self.freezeAllScrolls = function(shouldFreeze) {\r\n    for (var i = 0; i < $ionicScrollDelegate._instances.length; i++) {\r\n      $ionicScrollDelegate._instances[i].freezeScroll(shouldFreeze);\r\n    }\r\n  };\r\n\r\n\r\n  /**\r\n   * @private\r\n   */\r\n  self._setRefresher = function(refresherScope, refresherElement, refresherMethods) {\r\n    self.refresher = refresherElement;\r\n    var refresherHeight = self.refresher.clientHeight || 60;\r\n    scrollView.activatePullToRefresh(\r\n      refresherHeight,\r\n      refresherMethods\r\n    );\r\n  };\r\n\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/scrollController.js\n ** module id = 36\n ** module chunks = 0\n **/","IonicModule\r\n.controller('$ionicSideMenus', [\r\n  '$scope',\r\n  '$attrs',\r\n  '$ionicSideMenuDelegate',\r\n  '$ionicPlatform',\r\n  '$ionicBody',\r\n  '$ionicHistory',\r\n  '$ionicScrollDelegate',\r\n  'IONIC_BACK_PRIORITY',\r\n  '$rootScope',\r\nfunction($scope, $attrs, $ionicSideMenuDelegate, $ionicPlatform, $ionicBody, $ionicHistory, $ionicScrollDelegate, IONIC_BACK_PRIORITY, $rootScope) {\r\n  var self = this;\r\n  var rightShowing, leftShowing, isDragging;\r\n  var startX, lastX, offsetX, isAsideExposed;\r\n  var enableMenuWithBackViews = true;\r\n\r\n  self.$scope = $scope;\r\n\r\n  self.initialize = function(options) {\r\n    self.left = options.left;\r\n    self.right = options.right;\r\n    self.setContent(options.content);\r\n    self.dragThresholdX = options.dragThresholdX || 10;\r\n    $ionicHistory.registerHistory(self.$scope);\r\n  };\r\n\r\n  /**\r\n   * Set the content view controller if not passed in the constructor options.\r\n   *\r\n   * @param {object} content\r\n   */\r\n  self.setContent = function(content) {\r\n    if (content) {\r\n      self.content = content;\r\n\r\n      self.content.onDrag = function(e) {\r\n        self._handleDrag(e);\r\n      };\r\n\r\n      self.content.endDrag = function(e) {\r\n        self._endDrag(e);\r\n      };\r\n    }\r\n  };\r\n\r\n  self.isOpenLeft = function() {\r\n    return self.getOpenAmount() > 0;\r\n  };\r\n\r\n  self.isOpenRight = function() {\r\n    return self.getOpenAmount() < 0;\r\n  };\r\n\r\n  /**\r\n   * Toggle the left menu to open 100%\r\n   */\r\n  self.toggleLeft = function(shouldOpen) {\r\n    if (isAsideExposed || !self.left.isEnabled) return;\r\n    var openAmount = self.getOpenAmount();\r\n    if (arguments.length === 0) {\r\n      shouldOpen = openAmount <= 0;\r\n    }\r\n    self.content.enableAnimation();\r\n    if (!shouldOpen) {\r\n      self.openPercentage(0);\r\n      $rootScope.$emit('$ionicSideMenuClose', 'left');\r\n    } else {\r\n      self.openPercentage(100);\r\n      $rootScope.$emit('$ionicSideMenuOpen', 'left');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Toggle the right menu to open 100%\r\n   */\r\n  self.toggleRight = function(shouldOpen) {\r\n    if (isAsideExposed || !self.right.isEnabled) return;\r\n    var openAmount = self.getOpenAmount();\r\n    if (arguments.length === 0) {\r\n      shouldOpen = openAmount >= 0;\r\n    }\r\n    self.content.enableAnimation();\r\n    if (!shouldOpen) {\r\n      self.openPercentage(0);\r\n      $rootScope.$emit('$ionicSideMenuClose', 'right');\r\n    } else {\r\n      self.openPercentage(-100);\r\n      $rootScope.$emit('$ionicSideMenuOpen', 'right');\r\n    }\r\n  };\r\n\r\n  self.toggle = function(side) {\r\n    if (side == 'right') {\r\n      self.toggleRight();\r\n    } else {\r\n      self.toggleLeft();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Close all menus.\r\n   */\r\n  self.close = function() {\r\n    self.openPercentage(0);\r\n    $rootScope.$emit('$ionicSideMenuClose', 'left');\r\n    $rootScope.$emit('$ionicSideMenuClose', 'right');\r\n  };\r\n\r\n  /**\r\n   * @return {float} The amount the side menu is open, either positive or negative for left (positive), or right (negative)\r\n   */\r\n  self.getOpenAmount = function() {\r\n    return self.content && self.content.getTranslateX() || 0;\r\n  };\r\n\r\n  /**\r\n   * @return {float} The ratio of open amount over menu width. For example, a\r\n   * menu of width 100 open 50 pixels would be open 50% or a ratio of 0.5. Value is negative\r\n   * for right menu.\r\n   */\r\n  self.getOpenRatio = function() {\r\n    var amount = self.getOpenAmount();\r\n    if (amount >= 0) {\r\n      return amount / self.left.width;\r\n    }\r\n    return amount / self.right.width;\r\n  };\r\n\r\n  self.isOpen = function() {\r\n    return self.getOpenAmount() !== 0;\r\n  };\r\n\r\n  /**\r\n   * @return {float} The percentage of open amount over menu width. For example, a\r\n   * menu of width 100 open 50 pixels would be open 50%. Value is negative\r\n   * for right menu.\r\n   */\r\n  self.getOpenPercentage = function() {\r\n    return self.getOpenRatio() * 100;\r\n  };\r\n\r\n  /**\r\n   * Open the menu with a given percentage amount.\r\n   * @param {float} percentage The percentage (positive or negative for left/right) to open the menu.\r\n   */\r\n  self.openPercentage = function(percentage) {\r\n    var p = percentage / 100;\r\n\r\n    if (self.left && percentage >= 0) {\r\n      self.openAmount(self.left.width * p);\r\n    } else if (self.right && percentage < 0) {\r\n      self.openAmount(self.right.width * p);\r\n    }\r\n\r\n    // add the CSS class \"menu-open\" if the percentage does not\r\n    // equal 0, otherwise remove the class from the body element\r\n    $ionicBody.enableClass((percentage !== 0), 'menu-open');\r\n\r\n    self.content.setCanScroll(percentage == 0);\r\n  };\r\n\r\n  /*\r\n  function freezeAllScrolls(shouldFreeze) {\r\n    if (shouldFreeze && !self.isScrollFreeze) {\r\n      $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);\r\n\r\n    } else if (!shouldFreeze && self.isScrollFreeze) {\r\n      $ionicScrollDelegate.freezeAllScrolls(false);\r\n    }\r\n    self.isScrollFreeze = shouldFreeze;\r\n  }\r\n  */\r\n\r\n  /**\r\n   * Open the menu the given pixel amount.\r\n   * @param {float} amount the pixel amount to open the menu. Positive value for left menu,\r\n   * negative value for right menu (only one menu will be visible at a time).\r\n   */\r\n  self.openAmount = function(amount) {\r\n    var maxLeft = self.left && self.left.width || 0;\r\n    var maxRight = self.right && self.right.width || 0;\r\n\r\n    // Check if we can move to that side, depending if the left/right panel is enabled\r\n    if (!(self.left && self.left.isEnabled) && amount > 0) {\r\n      self.content.setTranslateX(0);\r\n      return;\r\n    }\r\n\r\n    if (!(self.right && self.right.isEnabled) && amount < 0) {\r\n      self.content.setTranslateX(0);\r\n      return;\r\n    }\r\n\r\n    if (leftShowing && amount > maxLeft) {\r\n      self.content.setTranslateX(maxLeft);\r\n      return;\r\n    }\r\n\r\n    if (rightShowing && amount < -maxRight) {\r\n      self.content.setTranslateX(-maxRight);\r\n      return;\r\n    }\r\n\r\n    self.content.setTranslateX(amount);\r\n\r\n    if (amount >= 0) {\r\n      leftShowing = true;\r\n      rightShowing = false;\r\n\r\n      if (amount > 0) {\r\n        // Push the z-index of the right menu down\r\n        self.right && self.right.pushDown && self.right.pushDown();\r\n        // Bring the z-index of the left menu up\r\n        self.left && self.left.bringUp && self.left.bringUp();\r\n      }\r\n    } else {\r\n      rightShowing = true;\r\n      leftShowing = false;\r\n\r\n      // Bring the z-index of the right menu up\r\n      self.right && self.right.bringUp && self.right.bringUp();\r\n      // Push the z-index of the left menu down\r\n      self.left && self.left.pushDown && self.left.pushDown();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * Given an event object, find the final resting position of this side\r\n   * menu. For example, if the user \"throws\" the content to the right and\r\n   * releases the touch, the left menu should snap open (animated, of course).\r\n   *\r\n   * @param {Event} e the gesture event to use for snapping\r\n   */\r\n  self.snapToRest = function(e) {\r\n    // We want to animate at the end of this\r\n    self.content.enableAnimation();\r\n    isDragging = false;\r\n\r\n    // Check how much the panel is open after the drag, and\r\n    // what the drag velocity is\r\n    var ratio = self.getOpenRatio();\r\n\r\n    if (ratio === 0) {\r\n      // Just to be safe\r\n      self.openPercentage(0);\r\n      return;\r\n    }\r\n\r\n    var velocityThreshold = 0.3;\r\n    var velocityX = e.gesture.velocityX;\r\n    var direction = e.gesture.direction;\r\n\r\n    // Going right, less than half, too slow (snap back)\r\n    if (ratio > 0 && ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {\r\n      self.openPercentage(0);\r\n    }\r\n\r\n    // Going left, more than half, too slow (snap back)\r\n    else if (ratio > 0.5 && direction == 'left' && velocityX < velocityThreshold) {\r\n      self.openPercentage(100);\r\n    }\r\n\r\n    // Going left, less than half, too slow (snap back)\r\n    else if (ratio < 0 && ratio > -0.5 && direction == 'left' && velocityX < velocityThreshold) {\r\n      self.openPercentage(0);\r\n    }\r\n\r\n    // Going right, more than half, too slow (snap back)\r\n    else if (ratio < 0.5 && direction == 'right' && velocityX < velocityThreshold) {\r\n      self.openPercentage(-100);\r\n    }\r\n\r\n    // Going right, more than half, or quickly (snap open)\r\n    else if (direction == 'right' && ratio >= 0 && (ratio >= 0.5 || velocityX > velocityThreshold)) {\r\n      self.openPercentage(100);\r\n    }\r\n\r\n    // Going left, more than half, or quickly (span open)\r\n    else if (direction == 'left' && ratio <= 0 && (ratio <= -0.5 || velocityX > velocityThreshold)) {\r\n      self.openPercentage(-100);\r\n    }\r\n\r\n    // Snap back for safety\r\n    else {\r\n      self.openPercentage(0);\r\n    }\r\n  };\r\n\r\n  self.enableMenuWithBackViews = function(val) {\r\n    if (arguments.length) {\r\n      enableMenuWithBackViews = !!val;\r\n    }\r\n    return enableMenuWithBackViews;\r\n  };\r\n\r\n  self.isAsideExposed = function() {\r\n    return !!isAsideExposed;\r\n  };\r\n\r\n  self.exposeAside = function(shouldExposeAside) {\r\n    if (!(self.left && self.left.isEnabled) && !(self.right && self.right.isEnabled)) return;\r\n    self.close();\r\n\r\n    isAsideExposed = shouldExposeAside;\r\n    if ((self.left && self.left.isEnabled) && (self.right && self.right.isEnabled)) {\r\n      self.content.setMarginLeftAndRight(isAsideExposed ? self.left.width : 0, isAsideExposed ? self.right.width : 0);\r\n    } else if (self.left && self.left.isEnabled) {\r\n      // set the left marget width if it should be exposed\r\n      // otherwise set false so there's no left margin\r\n      self.content.setMarginLeft(isAsideExposed ? self.left.width : 0);\r\n    } else if (self.right && self.right.isEnabled) {\r\n      self.content.setMarginRight(isAsideExposed ? self.right.width : 0);\r\n    }\r\n    self.$scope.$emit('$ionicExposeAside', isAsideExposed);\r\n  };\r\n\r\n  self.activeAsideResizing = function(isResizing) {\r\n    $ionicBody.enableClass(isResizing, 'aside-resizing');\r\n  };\r\n\r\n  // End a drag with the given event\r\n  self._endDrag = function(e) {\r\n    if (isAsideExposed) return;\r\n\r\n    if (isDragging) {\r\n      self.snapToRest(e);\r\n    }\r\n    startX = null;\r\n    lastX = null;\r\n    offsetX = null;\r\n  };\r\n\r\n  // Handle a drag event\r\n  self._handleDrag = function(e) {\r\n    if (isAsideExposed || !$scope.dragContent) return;\r\n\r\n    // If we don't have start coords, grab and store them\r\n    if (!startX) {\r\n      startX = e.gesture.touches[0].pageX;\r\n      lastX = startX;\r\n    } else {\r\n      // Grab the current tap coords\r\n      lastX = e.gesture.touches[0].pageX;\r\n    }\r\n\r\n    // Calculate difference from the tap points\r\n    if (!isDragging && Math.abs(lastX - startX) > self.dragThresholdX) {\r\n      // if the difference is greater than threshold, start dragging using the current\r\n      // point as the starting point\r\n      startX = lastX;\r\n\r\n      isDragging = true;\r\n      // Initialize dragging\r\n      self.content.disableAnimation();\r\n      offsetX = self.getOpenAmount();\r\n    }\r\n\r\n    if (isDragging) {\r\n      self.openAmount(offsetX + (lastX - startX));\r\n      //self.content.setCanScroll(false);\r\n    }\r\n  };\r\n\r\n  self.canDragContent = function(canDrag) {\r\n    if (arguments.length) {\r\n      $scope.dragContent = !!canDrag;\r\n    }\r\n    return $scope.dragContent;\r\n  };\r\n\r\n  self.edgeThreshold = 25;\r\n  self.edgeThresholdEnabled = false;\r\n  self.edgeDragThreshold = function(value) {\r\n    if (arguments.length) {\r\n      if (isNumber(value) && value > 0) {\r\n        self.edgeThreshold = value;\r\n        self.edgeThresholdEnabled = true;\r\n      } else {\r\n        self.edgeThresholdEnabled = !!value;\r\n      }\r\n    }\r\n    return self.edgeThresholdEnabled;\r\n  };\r\n\r\n  self.isDraggableTarget = function(e) {\r\n    //Only restrict edge when sidemenu is closed and restriction is enabled\r\n    var shouldOnlyAllowEdgeDrag = self.edgeThresholdEnabled && !self.isOpen();\r\n    var startX = e.gesture.startEvent && e.gesture.startEvent.center &&\r\n      e.gesture.startEvent.center.pageX;\r\n\r\n    var dragIsWithinBounds = !shouldOnlyAllowEdgeDrag ||\r\n      startX <= self.edgeThreshold ||\r\n      startX >= self.content.element.offsetWidth - self.edgeThreshold;\r\n\r\n    var backView = $ionicHistory.backView();\r\n    var menuEnabled = enableMenuWithBackViews ? true : !backView;\r\n    if (!menuEnabled) {\r\n      var currentView = $ionicHistory.currentView() || {};\r\n      return (dragIsWithinBounds && (backView.historyId !== currentView.historyId));\r\n    }\r\n\r\n    return ($scope.dragContent || self.isOpen()) &&\r\n      dragIsWithinBounds &&\r\n      !e.gesture.srcEvent.defaultPrevented &&\r\n      menuEnabled &&\r\n      !e.target.tagName.match(/input|textarea|select|object|embed/i) &&\r\n      !e.target.isContentEditable &&\r\n      !(e.target.dataset ? e.target.dataset.preventScroll : e.target.getAttribute('data-prevent-scroll') == 'true');\r\n  };\r\n\r\n  $scope.sideMenuContentTranslateX = 0;\r\n\r\n  var deregisterBackButtonAction = noop;\r\n  var closeSideMenu = angular.bind(self, self.close);\r\n\r\n  $scope.$watch(function() {\r\n    return self.getOpenAmount() !== 0;\r\n  }, function(isOpen) {\r\n    deregisterBackButtonAction();\r\n    if (isOpen) {\r\n      deregisterBackButtonAction = $ionicPlatform.registerBackButtonAction(\r\n        closeSideMenu,\r\n        IONIC_BACK_PRIORITY.sideMenu\r\n      );\r\n    }\r\n  });\r\n\r\n  var deregisterInstance = $ionicSideMenuDelegate._registerInstance(\r\n    self, $attrs.delegateHandle, function() {\r\n      return $ionicHistory.isActiveScope($scope);\r\n    }\r\n  );\r\n\r\n  $scope.$on('$destroy', function() {\r\n    deregisterInstance();\r\n    deregisterBackButtonAction();\r\n    self.$scope = null;\r\n    if (self.content) {\r\n      self.content.setCanScroll(true);\r\n      self.content.element = null;\r\n      self.content = null;\r\n    }\r\n  });\r\n\r\n  self.initialize({\r\n    left: {\r\n      width: 275\r\n    },\r\n    right: {\r\n      width: 275\r\n    }\r\n  });\r\n\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/sideMenuController.js\n ** module id = 37\n ** module chunks = 0\n **/","(function(ionic) {\n\n  var TRANSLATE32 = 'translate(32,32)';\n  var STROKE_OPACITY = 'stroke-opacity';\n  var ROUND = 'round';\n  var INDEFINITE = 'indefinite';\n  var DURATION = '750ms';\n  var NONE = 'none';\n  var SHORTCUTS = {\n    a: 'animate',\n    an: 'attributeName',\n    at: 'animateTransform',\n    c: 'circle',\n    da: 'stroke-dasharray',\n    os: 'stroke-dashoffset',\n    f: 'fill',\n    lc: 'stroke-linecap',\n    rc: 'repeatCount',\n    sw: 'stroke-width',\n    t: 'transform',\n    v: 'values'\n  };\n\n  var SPIN_ANIMATION = {\n    v: '0,32,32;360,32,32',\n    an: 'transform',\n    type: 'rotate',\n    rc: INDEFINITE,\n    dur: DURATION\n  };\n\n  function createSvgElement(tagName, data, parent, spinnerName) {\n    var ele = document.createElement(SHORTCUTS[tagName] || tagName);\n    var k, x, y;\n\n    for (k in data) {\n\n      if (angular.isArray(data[k])) {\n        for (x = 0; x < data[k].length; x++) {\n          if (data[k][x].fn) {\n            for (y = 0; y < data[k][x].t; y++) {\n              createSvgElement(k, data[k][x].fn(y, spinnerName), ele, spinnerName);\n            }\n          } else {\n            createSvgElement(k, data[k][x], ele, spinnerName);\n          }\n        }\n\n      } else {\n        setSvgAttribute(ele, k, data[k]);\n      }\n    }\n\n    parent.appendChild(ele);\n  }\n\n  function setSvgAttribute(ele, k, v) {\n    ele.setAttribute(SHORTCUTS[k] || k, v);\n  }\n\n  function animationValues(strValues, i) {\n    var values = strValues.split(';');\n    var back = values.slice(i);\n    var front = values.slice(0, values.length - back.length);\n    values = back.concat(front).reverse();\n    return values.join(';') + ';' + values[0];\n  }\n\n  var IOS_SPINNER = {\n    sw: 4,\n    lc: ROUND,\n    line: [{\n      fn: function(i, spinnerName) {\n        return {\n          y1: spinnerName == 'ios' ? 17 : 12,\n          y2: spinnerName == 'ios' ? 29 : 20,\n          t: TRANSLATE32 + ' rotate(' + (30 * i + (i < 6 ? 180 : -180)) + ')',\n          a: [{\n            fn: function() {\n              return {\n                an: STROKE_OPACITY,\n                dur: DURATION,\n                v: animationValues('0;.1;.15;.25;.35;.45;.55;.65;.7;.85;1', i),\n                rc: INDEFINITE\n              };\n            },\n            t: 1\n          }]\n        };\n      },\n      t: 12\n    }]\n  };\n\n  var spinners = {\n\n    android: {\n      c: [{\n        sw: 6,\n        da: 128,\n        os: 82,\n        r: 26,\n        cx: 32,\n        cy: 32,\n        f: NONE\n      }]\n    },\n\n    ios: IOS_SPINNER,\n\n    'ios-small': IOS_SPINNER,\n\n    bubbles: {\n      sw: 0,\n      c: [{\n        fn: function(i) {\n          return {\n            cx: 24 * Math.cos(2 * Math.PI * i / 8),\n            cy: 24 * Math.sin(2 * Math.PI * i / 8),\n            t: TRANSLATE32,\n            a: [{\n              fn: function() {\n                return {\n                  an: 'r',\n                  dur: DURATION,\n                  v: animationValues('1;2;3;4;5;6;7;8', i),\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }]\n          };\n        },\n        t: 8\n      }]\n    },\n\n    circles: {\n\n      c: [{\n        fn: function(i) {\n          return {\n            r: 5,\n            cx: 24 * Math.cos(2 * Math.PI * i / 8),\n            cy: 24 * Math.sin(2 * Math.PI * i / 8),\n            t: TRANSLATE32,\n            sw: 0,\n            a: [{\n              fn: function() {\n                return {\n                  an: 'fill-opacity',\n                  dur: DURATION,\n                  v: animationValues('.3;.3;.3;.4;.7;.85;.9;1', i),\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }]\n          };\n        },\n        t: 8\n      }]\n    },\n\n    crescent: {\n      c: [{\n        sw: 4,\n        da: 128,\n        os: 82,\n        r: 26,\n        cx: 32,\n        cy: 32,\n        f: NONE,\n        at: [SPIN_ANIMATION]\n      }]\n    },\n\n    dots: {\n\n      c: [{\n        fn: function(i) {\n          return {\n            cx: 16 + (16 * i),\n            cy: 32,\n            sw: 0,\n            a: [{\n              fn: function() {\n                return {\n                  an: 'fill-opacity',\n                  dur: DURATION,\n                  v: animationValues('.5;.6;.8;1;.8;.6;.5', i),\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }, {\n              fn: function() {\n                return {\n                  an: 'r',\n                  dur: DURATION,\n                  v: animationValues('4;5;6;5;4;3;3', i),\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }]\n          };\n        },\n        t: 3\n      }]\n    },\n\n    lines: {\n      sw: 7,\n      lc: ROUND,\n      line: [{\n        fn: function(i) {\n          return {\n            x1: 10 + (i * 14),\n            x2: 10 + (i * 14),\n            a: [{\n              fn: function() {\n                return {\n                  an: 'y1',\n                  dur: DURATION,\n                  v: animationValues('16;18;28;18;16', i),\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }, {\n              fn: function() {\n                return {\n                  an: 'y2',\n                  dur: DURATION,\n                  v: animationValues('48;44;36;46;48', i),\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }, {\n              fn: function() {\n                return {\n                  an: STROKE_OPACITY,\n                  dur: DURATION,\n                  v: animationValues('1;.8;.5;.4;1', i),\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }]\n          };\n        },\n        t: 4\n      }]\n    },\n\n    ripple: {\n      f: NONE,\n      'fill-rule': 'evenodd',\n      sw: 3,\n      circle: [{\n        fn: function(i) {\n          return {\n            cx: 32,\n            cy: 32,\n            a: [{\n              fn: function() {\n                return {\n                  an: 'r',\n                  begin: (i * -1) + 's',\n                  dur: '2s',\n                  v: '0;24',\n                  keyTimes: '0;1',\n                  keySplines: '0.1,0.2,0.3,1',\n                  calcMode: 'spline',\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }, {\n              fn: function() {\n                return {\n                  an: STROKE_OPACITY,\n                  begin: (i * -1) + 's',\n                  dur: '2s',\n                  v: '.2;1;.2;0',\n                  rc: INDEFINITE\n                };\n              },\n              t: 1\n            }]\n          };\n        },\n        t: 2\n      }]\n    },\n\n    spiral: {\n      defs: [{\n        linearGradient: [{\n          id: 'sGD',\n          gradientUnits: 'userSpaceOnUse',\n          x1: 55, y1: 46, x2: 2, y2: 46,\n          stop: [{\n            offset: 0.1,\n            class: 'stop1'\n          }, {\n            offset: 1,\n            class: 'stop2'\n          }]\n        }]\n      }],\n      g: [{\n        sw: 4,\n        lc: ROUND,\n        f: NONE,\n        path: [{\n          stroke: 'url(#sGD)',\n          d: 'M4,32 c0,15,12,28,28,28c8,0,16-4,21-9'\n        }, {\n          d: 'M60,32 C60,16,47.464,4,32,4S4,16,4,32'\n        }],\n        at: [SPIN_ANIMATION]\n      }]\n    }\n\n  };\n\n  var animations = {\n\n    android: function(ele) {\n      var self = this;\n\n      this.stop = false;\n\n      var rIndex = 0;\n      var rotateCircle = 0;\n      var startTime;\n      var svgEle = ele.querySelector('g');\n      var circleEle = ele.querySelector('circle');\n\n      function run() {\n        if (self.stop) return;\n\n        var v = easeInOutCubic(Date.now() - startTime, 650);\n        var scaleX = 1;\n        var translateX = 0;\n        var dasharray = (188 - (58 * v));\n        var dashoffset = (182 - (182 * v));\n\n        if (rIndex % 2) {\n          scaleX = -1;\n          translateX = -64;\n          dasharray = (128 - (-58 * v));\n          dashoffset = (182 * v);\n        }\n\n        var rotateLine = [0, -101, -90, -11, -180, 79, -270, -191][rIndex];\n\n        setSvgAttribute(circleEle, 'da', Math.max(Math.min(dasharray, 188), 128));\n        setSvgAttribute(circleEle, 'os', Math.max(Math.min(dashoffset, 182), 0));\n        setSvgAttribute(circleEle, 't', 'scale(' + scaleX + ',1) translate(' + translateX + ',0) rotate(' + rotateLine + ',32,32)');\n\n        rotateCircle += 4.1;\n        if (rotateCircle > 359) rotateCircle = 0;\n        setSvgAttribute(svgEle, 't', 'rotate(' + rotateCircle + ',32,32)');\n\n        if (v >= 1) {\n          rIndex++;\n          if (rIndex > 7) rIndex = 0;\n          startTime = Date.now();\n        }\n\n        ionic.requestAnimationFrame(run);\n      }\n\n      return function() {\n        startTime = Date.now();\n        run();\n        return self;\n      };\n\n    }\n\n  };\n\n  function easeInOutCubic(t, c) {\n    t /= c / 2;\n    if (t < 1) return 1 / 2 * t * t * t;\n    t -= 2;\n    return 1 / 2 * (t * t * t + 2);\n  }\n\n\n  IonicModule\n  .controller('$ionicSpinner', [\n    '$element',\n    '$attrs',\n    '$ionicConfig',\n  function($element, $attrs, $ionicConfig) {\n    var spinnerName, anim;\n\n    this.init = function() {\n      spinnerName = $attrs.icon || $ionicConfig.spinner.icon();\n\n      var container = document.createElement('div');\n      createSvgElement('svg', {\n        viewBox: '0 0 64 64',\n        g: [spinners[spinnerName]]\n      }, container, spinnerName);\n\n      // Specifically for animations to work,\n      // Android 4.3 and below requires the element to be\n      // added as an html string, rather than dynmically\n      // building up the svg element and appending it.\n      $element.html(container.innerHTML);\n\n      this.start();\n\n      return spinnerName;\n    };\n\n    this.start = function() {\n      animations[spinnerName] && (anim = animations[spinnerName]($element[0])());\n    };\n\n    this.stop = function() {\n      animations[spinnerName] && (anim.stop = true);\n    };\n\n  }]);\n\n})(ionic);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/spinnerController.js\n ** module id = 38\n ** module chunks = 0\n **/","IonicModule\n.controller('$ionicTab', [\n  '$scope',\n  '$ionicHistory',\n  '$attrs',\n  '$location',\n  '$state',\nfunction($scope, $ionicHistory, $attrs, $location, $state) {\n  this.$scope = $scope;\n\n  //All of these exposed for testing\n  this.hrefMatchesState = function() {\n    return $attrs.href && $location.path().indexOf(\n      $attrs.href.replace(/^#/, '').replace(/\\/$/, '')\n    ) === 0;\n  };\n  this.srefMatchesState = function() {\n    return $attrs.uiSref && $state.includes($attrs.uiSref.split('(')[0]);\n  };\n  this.navNameMatchesState = function() {\n    return this.navViewName && $ionicHistory.isCurrentStateNavView(this.navViewName);\n  };\n\n  this.tabMatchesState = function() {\n    return this.hrefMatchesState() || this.srefMatchesState() || this.navNameMatchesState();\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/tabController.js\n ** module id = 39\n ** module chunks = 0\n **/","IonicModule\n.controller('$ionicTabs', [\n  '$scope',\n  '$element',\n  '$ionicHistory',\nfunction($scope, $element, $ionicHistory) {\n  var self = this;\n  var selectedTab = null;\n  var previousSelectedTab = null;\n  var selectedTabIndex;\n  var isVisible = true;\n  self.tabs = [];\n\n  self.selectedIndex = function() {\n    return self.tabs.indexOf(selectedTab);\n  };\n  self.selectedTab = function() {\n    return selectedTab;\n  };\n  self.previousSelectedTab = function() {\n    return previousSelectedTab;\n  };\n\n  self.add = function(tab) {\n    $ionicHistory.registerHistory(tab);\n    self.tabs.push(tab);\n  };\n\n  self.remove = function(tab) {\n    var tabIndex = self.tabs.indexOf(tab);\n    if (tabIndex === -1) {\n      return;\n    }\n    //Use a field like '$tabSelected' so developers won't accidentally set it in controllers etc\n    if (tab.$tabSelected) {\n      self.deselect(tab);\n      //Try to select a new tab if we're removing a tab\n      if (self.tabs.length === 1) {\n        //Do nothing if there are no other tabs to select\n      } else {\n        //Select previous tab if it's the last tab, else select next tab\n        var newTabIndex = tabIndex === self.tabs.length - 1 ? tabIndex - 1 : tabIndex + 1;\n        self.select(self.tabs[newTabIndex]);\n      }\n    }\n    self.tabs.splice(tabIndex, 1);\n  };\n\n  self.deselect = function(tab) {\n    if (tab.$tabSelected) {\n      previousSelectedTab = selectedTab;\n      selectedTab = selectedTabIndex = null;\n      tab.$tabSelected = false;\n      (tab.onDeselect || noop)();\n      tab.$broadcast && tab.$broadcast('$ionicHistory.deselect');\n    }\n  };\n\n  self.select = function(tab, shouldEmitEvent) {\n    var tabIndex;\n    if (isNumber(tab)) {\n      tabIndex = tab;\n      if (tabIndex >= self.tabs.length) return;\n      tab = self.tabs[tabIndex];\n    } else {\n      tabIndex = self.tabs.indexOf(tab);\n    }\n\n    if (arguments.length === 1) {\n      shouldEmitEvent = !!(tab.navViewName || tab.uiSref);\n    }\n\n    if (selectedTab && selectedTab.$historyId == tab.$historyId) {\n      if (shouldEmitEvent) {\n        $ionicHistory.goToHistoryRoot(tab.$historyId);\n      }\n\n    } else if (selectedTabIndex !== tabIndex) {\n      forEach(self.tabs, function(tab) {\n        self.deselect(tab);\n      });\n\n      selectedTab = tab;\n      selectedTabIndex = tabIndex;\n\n      if (self.$scope && self.$scope.$parent) {\n        self.$scope.$parent.$activeHistoryId = tab.$historyId;\n      }\n\n      //Use a funny name like $tabSelected so the developer doesn't overwrite the var in a child scope\n      tab.$tabSelected = true;\n      (tab.onSelect || noop)();\n\n      if (shouldEmitEvent) {\n        $scope.$emit('$ionicHistory.change', {\n          type: 'tab',\n          tabIndex: tabIndex,\n          historyId: tab.$historyId,\n          navViewName: tab.navViewName,\n          hasNavView: !!tab.navViewName,\n          title: tab.title,\n          url: tab.href,\n          uiSref: tab.uiSref\n        });\n      }\n    }\n  };\n\n  self.hasActiveScope = function() {\n    for (var x = 0; x < self.tabs.length; x++) {\n      if ($ionicHistory.isActiveScope(self.tabs[x])) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  self.showBar = function(show) {\n    if (arguments.length) {\n      if (show) {\n        $element.removeClass('tabs-item-hide');\n      } else {\n        $element.addClass('tabs-item-hide');\n      }\n      isVisible = !!show;\n    }\n    return isVisible;\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/tabsController.js\n ** module id = 40\n ** module chunks = 0\n **/","IonicModule\n.controller('$ionicView', [\n  '$scope',\n  '$element',\n  '$attrs',\n  '$compile',\n  '$rootScope',\nfunction($scope, $element, $attrs, $compile, $rootScope) {\n  var self = this;\n  var navElementHtml = {};\n  var navViewCtrl;\n  var navBarDelegateHandle;\n  var hasViewHeaderBar;\n  var deregisters = [];\n  var viewTitle;\n\n  var deregIonNavBarInit = $scope.$on('ionNavBar.init', function(ev, delegateHandle) {\n    // this view has its own ion-nav-bar, remember the navBarDelegateHandle for this view\n    ev.stopPropagation();\n    navBarDelegateHandle = delegateHandle;\n  });\n\n\n  self.init = function() {\n    deregIonNavBarInit();\n\n    var modalCtrl = $element.inheritedData('$ionModalController');\n    navViewCtrl = $element.inheritedData('$ionNavViewController');\n\n    // don't bother if inside a modal or there's no parent navView\n    if (!navViewCtrl || modalCtrl) return;\n\n    // add listeners for when this view changes\n    $scope.$on('$ionicView.beforeEnter', self.beforeEnter);\n    $scope.$on('$ionicView.afterEnter', afterEnter);\n    $scope.$on('$ionicView.beforeLeave', deregisterFns);\n  };\n\n  self.beforeEnter = function(ev, transData) {\n    // this event was emitted, starting at intial ion-view, then bubbles up\n    // only the first ion-view should do something with it, parent ion-views should ignore\n    if (transData && !transData.viewNotified) {\n      transData.viewNotified = true;\n\n      if (!$rootScope.$$phase) $scope.$digest();\n      viewTitle = isDefined($attrs.viewTitle) ? $attrs.viewTitle : $attrs.title;\n\n      var navBarItems = {};\n      for (var n in navElementHtml) {\n        navBarItems[n] = generateNavBarItem(navElementHtml[n]);\n      }\n\n      navViewCtrl.beforeEnter(extend(transData, {\n        title: viewTitle,\n        showBack: !attrTrue('hideBackButton'),\n        navBarItems: navBarItems,\n        navBarDelegate: navBarDelegateHandle || null,\n        showNavBar: !attrTrue('hideNavBar'),\n        hasHeaderBar: !!hasViewHeaderBar\n      }));\n\n      // make sure any existing observers are cleaned up\n      deregisterFns();\n    }\n  };\n\n\n  function afterEnter() {\n    // only listen for title updates after it has entered\n    // but also deregister the observe before it leaves\n    var viewTitleAttr = isDefined($attrs.viewTitle) && 'viewTitle' || isDefined($attrs.title) && 'title';\n    if (viewTitleAttr) {\n      titleUpdate($attrs[viewTitleAttr]);\n      deregisters.push($attrs.$observe(viewTitleAttr, titleUpdate));\n    }\n\n    if (isDefined($attrs.hideBackButton)) {\n      deregisters.push($scope.$watch($attrs.hideBackButton, function(val) {\n        navViewCtrl.showBackButton(!val);\n      }));\n    }\n\n    if (isDefined($attrs.hideNavBar)) {\n      deregisters.push($scope.$watch($attrs.hideNavBar, function(val) {\n        navViewCtrl.showBar(!val);\n      }));\n    }\n  }\n\n\n  function titleUpdate(newTitle) {\n    if (isDefined(newTitle) && newTitle !== viewTitle) {\n      viewTitle = newTitle;\n      navViewCtrl.title(viewTitle);\n    }\n  }\n\n\n  function deregisterFns() {\n    // remove all existing $attrs.$observe's\n    for (var x = 0; x < deregisters.length; x++) {\n      deregisters[x]();\n    }\n    deregisters = [];\n  }\n\n\n  function generateNavBarItem(html) {\n    if (html) {\n      // every time a view enters we need to recreate its view buttons if they exist\n      return $compile(html)($scope.$new());\n    }\n  }\n\n\n  function attrTrue(key) {\n    return !!$scope.$eval($attrs[key]);\n  }\n\n\n  self.navElement = function(type, html) {\n    navElementHtml[type] = html;\n  };\n\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/controller/viewController.js\n ** module id = 41\n ** module chunks = 0\n **/","/*\n * We don't document the ionActionSheet directive, we instead document\n * the $ionicActionSheet service\n */\nIonicModule\n.directive('ionActionSheet', ['$document', function($document) {\n  return {\n    restrict: 'E',\n    scope: true,\n    replace: true,\n    link: function($scope, $element) {\n\n      var keyUp = function(e) {\n        if (e.which == 27) {\n          $scope.cancel();\n          $scope.$apply();\n        }\n      };\n\n      var backdropClick = function(e) {\n        if (e.target == $element[0]) {\n          $scope.cancel();\n          $scope.$apply();\n        }\n      };\n      $scope.$on('$destroy', function() {\n        $element.remove();\n        $document.unbind('keyup', keyUp);\n      });\n\n      $document.bind('keyup', keyUp);\n      $element.bind('click', backdropClick);\n    },\n    template: '<div class=\"action-sheet-backdrop\">' +\n                '<div class=\"action-sheet-wrapper\">' +\n                  '<div class=\"action-sheet\" ng-class=\"{\\'action-sheet-has-icons\\': $actionSheetHasIcon}\">' +\n                    '<div class=\"action-sheet-group action-sheet-options\">' +\n                      '<div class=\"action-sheet-title\" ng-if=\"titleText\" ng-bind-html=\"titleText\"></div>' +\n                      '<button class=\"button action-sheet-option\" ng-click=\"buttonClicked($index)\" ng-class=\"b.className\" ng-repeat=\"b in buttons\" ng-bind-html=\"b.text\"></button>' +\n                      '<button class=\"button destructive action-sheet-destructive\" ng-if=\"destructiveText\" ng-click=\"destructiveButtonClicked()\" ng-bind-html=\"destructiveText\"></button>' +\n                    '</div>' +\n                    '<div class=\"action-sheet-group action-sheet-cancel\" ng-if=\"cancelText\">' +\n                      '<button class=\"button\" ng-click=\"cancel()\" ng-bind-html=\"cancelText\"></button>' +\n                    '</div>' +\n                  '</div>' +\n                '</div>' +\n              '</div>'\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/actionSheet.js\n ** module id = 42\n ** module chunks = 0\n **/","\n/**\n * @ngdoc directive\n * @name ionCheckbox\n * @module ionic\n * @restrict E\n * @codepen hqcju\n * @description\n * The checkbox is no different than the HTML checkbox input, except it's styled differently.\n *\n * The checkbox behaves like any [AngularJS checkbox](http://docs.angularjs.org/api/ng/input/input[checkbox]).\n *\n * @usage\n * ```html\n * <ion-checkbox ng-model=\"isChecked\">Checkbox Label</ion-checkbox>\n * ```\n */\n\nIonicModule\n.directive('ionCheckbox', ['$ionicConfig', function($ionicConfig) {\n  return {\n    restrict: 'E',\n    replace: true,\n    require: '?ngModel',\n    transclude: true,\n    template:\n      '<label class=\"item item-checkbox\">' +\n        '<div class=\"checkbox checkbox-input-hidden disable-pointer-events\">' +\n          '<input type=\"checkbox\">' +\n          '<i class=\"checkbox-icon\"></i>' +\n        '</div>' +\n        '<div class=\"item-content disable-pointer-events\" ng-transclude></div>' +\n      '</label>',\n    compile: function(element, attr) {\n      var input = element.find('input');\n      forEach({\n        'name': attr.name,\n        'ng-value': attr.ngValue,\n        'ng-model': attr.ngModel,\n        'ng-checked': attr.ngChecked,\n        'ng-disabled': attr.ngDisabled,\n        'ng-true-value': attr.ngTrueValue,\n        'ng-false-value': attr.ngFalseValue,\n        'ng-change': attr.ngChange,\n        'ng-required': attr.ngRequired,\n        'required': attr.required\n      }, function(value, name) {\n        if (isDefined(value)) {\n          input.attr(name, value);\n        }\n      });\n      var checkboxWrapper = element[0].querySelector('.checkbox');\n      checkboxWrapper.classList.add('checkbox-' + $ionicConfig.form.checkbox());\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/checkbox.js\n ** module id = 43\n ** module chunks = 0\n **/","\n/**\n * @ngdoc directive\n * @restrict A\n * @name collectionRepeat\n * @module ionic\n * @codepen 7ec1ec58f2489ab8f359fa1a0fe89c15\n * @description\n * `collection-repeat` allows an app to show huge lists of items much more performantly than\n * `ng-repeat`.\n *\n * It renders into the DOM only as many items as are currently visible.\n *\n * This means that on a phone screen that can fit eight items, only the eight items matching\n * the current scroll position will be rendered.\n *\n * **The Basics**:\n *\n * - The data given to collection-repeat must be an array.\n * - If the `item-height` and `item-width` attributes are not supplied, it will be assumed that\n *   every item in the list has the same dimensions as the first item.\n * - Don't use angular one-time binding (`::`) with collection-repeat. The scope of each item is\n *   assigned new data and re-digested as you scroll. Bindings need to update, and one-time bindings\n *   won't.\n *\n * **Performance Tips**:\n *\n * - The iOS webview has a performance bottleneck when switching out `<img src>` attributes.\n *   To increase performance of images on iOS, cache your images in advance and,\n *   if possible, lower the number of unique images. We're working on [a solution](https://github.com/driftyco/ionic/issues/3194).\n *\n * @usage\n * #### Basic Item List ([codepen](http://codepen.io/ionic/pen/0c2c35a34a8b18ad4d793fef0b081693))\n * ```html\n * <ion-content>\n *   <ion-item collection-repeat=\"item in items\">\n *     {% raw %}{{item}}{% endraw %}\n *   </ion-item>\n * </ion-content>\n * ```\n *\n * #### Grid of Images ([codepen](http://codepen.io/ionic/pen/5515d4efd9d66f780e96787387f41664))\n * ```html\n * <ion-content>\n *   <img collection-repeat=\"photo in photos\"\n *     item-width=\"33%\"\n *     item-height=\"200px\"\n *     ng-src=\"{% raw %}{{photo.url}}{% endraw %}\">\n * </ion-content>\n * ```\n *\n * #### Horizontal Scroller, Dynamic Item Width ([codepen](http://codepen.io/ionic/pen/67cc56b349124a349acb57a0740e030e))\n * ```html\n * <ion-content>\n *   <h2>Available Kittens:</h2>\n *   <ion-scroll direction=\"x\" class=\"available-scroller\">\n *     <div class=\"photo\" collection-repeat=\"photo in main.photos\"\n *        item-height=\"250\" item-width=\"photo.width + 30\">\n *        <img ng-src=\"{% raw %}{{photo.src}}{% endraw %}\">\n *     </div>\n *   </ion-scroll>\n * </ion-content>\n * ```\n *\n * @param {expression} collection-repeat The expression indicating how to enumerate a collection,\n *   of the format  `variable in expression`  where variable is the user defined loop variable\n *   and `expression` is a scope expression giving the collection to enumerate.\n *   For example: `album in artist.albums` or `album in artist.albums | orderBy:'name'`.\n * @param {expression=} item-width The width of the repeated element. The expression must return\n *   a number (pixels) or a percentage. Defaults to the width of the first item in the list.\n *   (previously named collection-item-width)\n * @param {expression=} item-height The height of the repeated element. The expression must return\n *   a number (pixels) or a percentage. Defaults to the height of the first item in the list.\n *   (previously named collection-item-height)\n * @param {number=} item-render-buffer The number of items to load before and after the visible\n *   items in the list. Default 3. Tip: set this higher if you have lots of images to preload, but\n *   don't set it too high or you'll see performance loss.\n * @param {boolean=} force-refresh-images Force images to refresh as you scroll. This fixes a problem\n *   where, when an element is interchanged as scrolling, its image will still have the old src\n *   while the new src loads. Setting this to true comes with a small performance loss.\n */\n\nIonicModule\n.directive('collectionRepeat', CollectionRepeatDirective)\n.factory('$ionicCollectionManager', RepeatManagerFactory);\n\nvar ONE_PX_TRANSPARENT_IMG_SRC = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';\nvar WIDTH_HEIGHT_REGEX = /height:.*?px;\\s*width:.*?px/;\nvar DEFAULT_RENDER_BUFFER = 3;\n\nCollectionRepeatDirective.$inject = ['$ionicCollectionManager', '$parse', '$window', '$$rAF', '$rootScope', '$timeout'];\nfunction CollectionRepeatDirective($ionicCollectionManager, $parse, $window, $$rAF, $rootScope, $timeout) {\n  return {\n    restrict: 'A',\n    priority: 1000,\n    transclude: 'element',\n    $$tlb: true,\n    require: '^^$ionicScroll',\n    link: postLink\n  };\n\n  function postLink(scope, element, attr, scrollCtrl, transclude) {\n    var scrollView = scrollCtrl.scrollView;\n    var node = element[0];\n    var containerNode = angular.element('<div class=\"collection-repeat-container\">')[0];\n    node.parentNode.replaceChild(containerNode, node);\n\n    if (scrollView.options.scrollingX && scrollView.options.scrollingY) {\n      throw new Error(\"collection-repeat expected a parent x or y scrollView, not \" +\n                      \"an xy scrollView.\");\n    }\n\n    var repeatExpr = attr.collectionRepeat;\n    var match = repeatExpr.match(/^\\s*([\\s\\S]+?)\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?\\s*$/);\n    if (!match) {\n      throw new Error(\"collection-repeat expected expression in form of '_item_ in \" +\n                      \"_collection_[ track by _id_]' but got '\" + attr.collectionRepeat + \"'.\");\n    }\n    var keyExpr = match[1];\n    var listExpr = match[2];\n    var listGetter = $parse(listExpr);\n    var heightData = {};\n    var widthData = {};\n    var computedStyleDimensions = {};\n    var data = [];\n    var repeatManager;\n\n    // attr.collectionBufferSize is deprecated\n    var renderBufferExpr = attr.itemRenderBuffer || attr.collectionBufferSize;\n    var renderBuffer = angular.isDefined(renderBufferExpr) ?\n      parseInt(renderBufferExpr) :\n      DEFAULT_RENDER_BUFFER;\n\n    // attr.collectionItemHeight is deprecated\n    var heightExpr = attr.itemHeight || attr.collectionItemHeight;\n    // attr.collectionItemWidth is deprecated\n    var widthExpr = attr.itemWidth || attr.collectionItemWidth;\n\n    var afterItemsContainer = initAfterItemsContainer();\n\n    var changeValidator = makeChangeValidator();\n    initDimensions();\n\n    // Dimensions are refreshed on resize or data change.\n    scrollCtrl.$element.on('scroll-resize', refreshDimensions);\n\n    angular.element($window).on('resize', onResize);\n    var unlistenToExposeAside = $rootScope.$on('$ionicExposeAside', ionic.animationFrameThrottle(function() {\n      scrollCtrl.scrollView.resize();\n      onResize();\n    }));\n    $timeout(refreshDimensions, 0, false);\n\n    function onResize() {\n      if (changeValidator.resizeRequiresRefresh(scrollView.__clientWidth, scrollView.__clientHeight)) {\n        refreshDimensions();\n      }\n    }\n\n    scope.$watchCollection(listGetter, function(newValue) {\n      data = newValue || (newValue = []);\n      if (!angular.isArray(newValue)) {\n        throw new Error(\"collection-repeat expected an array for '\" + listExpr + \"', \" +\n          \"but got a \" + typeof value);\n      }\n      // Wait for this digest to end before refreshing everything.\n      scope.$$postDigest(function() {\n        getRepeatManager().setData(data);\n        if (changeValidator.dataChangeRequiresRefresh(data)) refreshDimensions();\n      });\n    });\n\n    scope.$on('$destroy', function() {\n      angular.element($window).off('resize', onResize);\n      unlistenToExposeAside();\n      scrollCtrl.$element && scrollCtrl.$element.off('scroll-resize', refreshDimensions);\n\n      computedStyleNode && computedStyleNode.parentNode &&\n        computedStyleNode.parentNode.removeChild(computedStyleNode);\n      computedStyleScope && computedStyleScope.$destroy();\n      computedStyleScope = computedStyleNode = null;\n\n      repeatManager && repeatManager.destroy();\n      repeatManager = null;\n    });\n\n    function makeChangeValidator() {\n      var self;\n      return (self = {\n        dataLength: 0,\n        width: 0,\n        height: 0,\n        // A resize triggers a refresh only if we have data, the scrollView has size,\n        // and the size has changed.\n        resizeRequiresRefresh: function(newWidth, newHeight) {\n          var requiresRefresh = self.dataLength && newWidth && newHeight &&\n            (newWidth !== self.width || newHeight !== self.height);\n\n          self.width = newWidth;\n          self.height = newHeight;\n\n          return !!requiresRefresh;\n        },\n        // A change in data only triggers a refresh if the data has length, or if the data's\n        // length is less than before.\n        dataChangeRequiresRefresh: function(newData) {\n          var requiresRefresh = newData.length > 0 || newData.length < self.dataLength;\n\n          self.dataLength = newData.length;\n\n          return !!requiresRefresh;\n        }\n      });\n    }\n\n    function getRepeatManager() {\n      return repeatManager || (repeatManager = new $ionicCollectionManager({\n        afterItemsNode: afterItemsContainer[0],\n        containerNode: containerNode,\n        heightData: heightData,\n        widthData: widthData,\n        forceRefreshImages: !!(isDefined(attr.forceRefreshImages) && attr.forceRefreshImages !== 'false'),\n        keyExpression: keyExpr,\n        renderBuffer: renderBuffer,\n        scope: scope,\n        scrollView: scrollCtrl.scrollView,\n        transclude: transclude\n      }));\n    }\n\n    function initAfterItemsContainer() {\n      var container = angular.element(\n        scrollView.__content.querySelector('.collection-repeat-after-container')\n      );\n      // Put everything in the view after the repeater into a container.\n      if (!container.length) {\n        var elementIsAfterRepeater = false;\n        var afterNodes = [].filter.call(scrollView.__content.childNodes, function(node) {\n          if (ionic.DomUtil.contains(node, containerNode)) {\n            elementIsAfterRepeater = true;\n            return false;\n          }\n          return elementIsAfterRepeater;\n        });\n        container = angular.element('<span class=\"collection-repeat-after-container\">');\n        if (scrollView.options.scrollingX) {\n          container.addClass('horizontal');\n        }\n        container.append(afterNodes);\n        scrollView.__content.appendChild(container[0]);\n      }\n      return container;\n    }\n\n    function initDimensions() {\n      //Height and width have four 'modes':\n      //1) Computed Mode\n      //  - Nothing is supplied, so we getComputedStyle() on one element in the list and use\n      //    that width and height value for the width and height of every item. This is re-computed\n      //    every resize.\n      //2) Constant Mode, Static Integer\n      //  - The user provides a constant number for width or height, in pixels. We parse it,\n      //    store it on the `value` field, and it never changes\n      //3) Constant Mode, Percent\n      //  - The user provides a percent string for width or height. The getter for percent is\n      //    stored on the `getValue()` field, and is re-evaluated once every resize. The result\n      //    is stored on the `value` field.\n      //4) Dynamic Mode\n      //  - The user provides a dynamic expression for the width or height.  This is re-evaluated\n      //    for every item, stored on the `.getValue()` field.\n      if (heightExpr) {\n        parseDimensionAttr(heightExpr, heightData);\n      } else {\n        heightData.computed = true;\n      }\n      if (widthExpr) {\n        parseDimensionAttr(widthExpr, widthData);\n      } else {\n        widthData.computed = true;\n      }\n    }\n\n    function refreshDimensions() {\n      var hasData = data.length > 0;\n\n      if (hasData && (heightData.computed || widthData.computed)) {\n        computeStyleDimensions();\n      }\n\n      if (hasData && heightData.computed) {\n        heightData.value = computedStyleDimensions.height;\n        if (!heightData.value) {\n          throw new Error('collection-repeat tried to compute the height of repeated elements \"' +\n            repeatExpr + '\", but was unable to. Please provide the \"item-height\" attribute. ' +\n            'http://ionicframework.com/docs/api/directive/collectionRepeat/');\n        }\n      } else if (!heightData.dynamic && heightData.getValue) {\n        // If it's a constant with a getter (eg percent), we just refresh .value after resize\n        heightData.value = heightData.getValue();\n      }\n\n      if (hasData && widthData.computed) {\n        widthData.value = computedStyleDimensions.width;\n        if (!widthData.value) {\n          throw new Error('collection-repeat tried to compute the width of repeated elements \"' +\n            repeatExpr + '\", but was unable to. Please provide the \"item-width\" attribute. ' +\n            'http://ionicframework.com/docs/api/directive/collectionRepeat/');\n        }\n      } else if (!widthData.dynamic && widthData.getValue) {\n        // If it's a constant with a getter (eg percent), we just refresh .value after resize\n        widthData.value = widthData.getValue();\n      }\n      // Dynamic dimensions aren't updated on resize. Since they're already dynamic anyway,\n      // .getValue() will be used.\n\n      getRepeatManager().refreshLayout();\n    }\n\n    function parseDimensionAttr(attrValue, dimensionData) {\n      if (!attrValue) return;\n\n      var parsedValue;\n      // Try to just parse the plain attr value\n      try {\n        parsedValue = $parse(attrValue);\n      } catch (e) {\n        // If the parse fails and the value has `px` or `%` in it, surround the attr in\n        // quotes, to attempt to let the user provide a simple `attr=\"100%\"` or `attr=\"100px\"`\n        if (attrValue.trim().match(/\\d+(px|%)$/)) {\n          attrValue = '\"' + attrValue + '\"';\n        }\n        parsedValue = $parse(attrValue);\n      }\n\n      var constantAttrValue = attrValue.replace(/(\\'|\\\"|px|%)/g, '').trim();\n      var isConstant = constantAttrValue.length && !/([a-zA-Z]|\\$|:|\\?)/.test(constantAttrValue);\n      dimensionData.attrValue = attrValue;\n\n      // If it's a constant, it's either a percent or just a constant pixel number.\n      if (isConstant) {\n        // For percents, store the percent getter on .getValue()\n        if (attrValue.indexOf('%') > -1) {\n          var decimalValue = parseFloat(parsedValue()) / 100;\n          dimensionData.getValue = dimensionData === heightData ?\n            function() { return Math.floor(decimalValue * scrollView.__clientHeight); } :\n            function() { return Math.floor(decimalValue * scrollView.__clientWidth); };\n        } else {\n          // For static constants, just store the static constant.\n          dimensionData.value = parseInt(parsedValue());\n        }\n\n      } else {\n        dimensionData.dynamic = true;\n        dimensionData.getValue = dimensionData === heightData ?\n          function heightGetter(scope, locals) {\n            var result = parsedValue(scope, locals);\n            if (result.charAt && result.charAt(result.length - 1) === '%') {\n              return Math.floor(parseFloat(result) / 100 * scrollView.__clientHeight);\n            }\n            return parseInt(result);\n          } :\n          function widthGetter(scope, locals) {\n            var result = parsedValue(scope, locals);\n            if (result.charAt && result.charAt(result.length - 1) === '%') {\n              return Math.floor(parseFloat(result) / 100 * scrollView.__clientWidth);\n            }\n            return parseInt(result);\n          };\n      }\n    }\n\n    var computedStyleNode;\n    var computedStyleScope;\n    function computeStyleDimensions() {\n      if (!computedStyleNode) {\n        transclude(computedStyleScope = scope.$new(), function(clone) {\n          clone[0].removeAttribute('collection-repeat'); // remove absolute position styling\n          computedStyleNode = clone[0];\n        });\n      }\n\n      computedStyleScope[keyExpr] = (listGetter(scope) || [])[0];\n      if (!$rootScope.$$phase) computedStyleScope.$digest();\n      containerNode.appendChild(computedStyleNode);\n\n      var style = $window.getComputedStyle(computedStyleNode);\n      computedStyleDimensions.width = parseInt(style.width);\n      computedStyleDimensions.height = parseInt(style.height);\n\n      containerNode.removeChild(computedStyleNode);\n    }\n\n  }\n\n}\n\nRepeatManagerFactory.$inject = ['$rootScope', '$window', '$$rAF'];\nfunction RepeatManagerFactory($rootScope, $window, $$rAF) {\n  var EMPTY_DIMENSION = { primaryPos: 0, secondaryPos: 0, primarySize: 0, secondarySize: 0, rowPrimarySize: 0 };\n\n  return function RepeatController(options) {\n    var afterItemsNode = options.afterItemsNode;\n    var containerNode = options.containerNode;\n    var forceRefreshImages = options.forceRefreshImages;\n    var heightData = options.heightData;\n    var widthData = options.widthData;\n    var keyExpression = options.keyExpression;\n    var renderBuffer = options.renderBuffer;\n    var scope = options.scope;\n    var scrollView = options.scrollView;\n    var transclude = options.transclude;\n\n    var data = [];\n\n    var getterLocals = {};\n    var heightFn = heightData.getValue || function() { return heightData.value; };\n    var heightGetter = function(index, value) {\n      getterLocals[keyExpression] = value;\n      getterLocals.$index = index;\n      return heightFn(scope, getterLocals);\n    };\n\n    var widthFn = widthData.getValue || function() { return widthData.value; };\n    var widthGetter = function(index, value) {\n      getterLocals[keyExpression] = value;\n      getterLocals.$index = index;\n      return widthFn(scope, getterLocals);\n    };\n\n    var isVertical = !!scrollView.options.scrollingY;\n\n    // We say it's a grid view if we're either dynamic or not 100% width\n    var isGridView = isVertical ?\n      (widthData.dynamic || widthData.value !== scrollView.__clientWidth) :\n      (heightData.dynamic || heightData.value !== scrollView.__clientHeight);\n\n    var isStaticView = !heightData.dynamic && !widthData.dynamic;\n\n    var PRIMARY = 'PRIMARY';\n    var SECONDARY = 'SECONDARY';\n    var TRANSLATE_TEMPLATE_STR = isVertical ?\n      'translate3d(SECONDARYpx,PRIMARYpx,0)' :\n      'translate3d(PRIMARYpx,SECONDARYpx,0)';\n    var WIDTH_HEIGHT_TEMPLATE_STR = isVertical ?\n      'height: PRIMARYpx; width: SECONDARYpx;' :\n      'height: SECONDARYpx; width: PRIMARYpx;';\n\n    var estimatedHeight;\n    var estimatedWidth;\n\n    var repeaterBeforeSize = 0;\n    var repeaterAfterSize = 0;\n\n    var renderStartIndex = -1;\n    var renderEndIndex = -1;\n    var renderAfterBoundary = -1;\n    var renderBeforeBoundary = -1;\n\n    var itemsPool = [];\n    var itemsLeaving = [];\n    var itemsEntering = [];\n    var itemsShownMap = {};\n    var nextItemId = 0;\n\n    var scrollViewSetDimensions = isVertical ?\n      function() { scrollView.setDimensions(null, null, null, view.getContentSize(), true); } :\n      function() { scrollView.setDimensions(null, null, view.getContentSize(), null, true); };\n\n    // view is a mix of list/grid methods + static/dynamic methods.\n    // See bottom for implementations. Available methods:\n    //\n    // getEstimatedPrimaryPos(i), getEstimatedSecondaryPos(i), getEstimatedIndex(scrollTop),\n    // calculateDimensions(toIndex), getDimensions(index),\n    // updateRenderRange(scrollTop, scrollValueEnd), onRefreshLayout(), onRefreshData()\n    var view = isVertical ? new VerticalViewType() : new HorizontalViewType();\n    (isGridView ? GridViewType : ListViewType).call(view);\n    (isStaticView ? StaticViewType : DynamicViewType).call(view);\n\n    var contentSizeStr = isVertical ? 'getContentHeight' : 'getContentWidth';\n    var originalGetContentSize = scrollView.options[contentSizeStr];\n    scrollView.options[contentSizeStr] = angular.bind(view, view.getContentSize);\n\n    scrollView.__$callback = scrollView.__callback;\n    scrollView.__callback = function(transformLeft, transformTop, zoom, wasResize) {\n      var scrollValue = view.getScrollValue();\n      if (renderStartIndex === -1 ||\n          scrollValue + view.scrollPrimarySize > renderAfterBoundary ||\n          scrollValue < renderBeforeBoundary) {\n        render();\n      }\n      scrollView.__$callback(transformLeft, transformTop, zoom, wasResize);\n    };\n\n    var isLayoutReady = false;\n    var isDataReady = false;\n    this.refreshLayout = function() {\n      if (data.length) {\n        estimatedHeight = heightGetter(0, data[0]);\n        estimatedWidth = widthGetter(0, data[0]);\n      } else {\n        // If we don't have any data in our array, just guess.\n        estimatedHeight = 100;\n        estimatedWidth = 100;\n      }\n\n      // Get the size of every element AFTER the repeater. We have to get the margin before and\n      // after the first/last element to fix a browser bug with getComputedStyle() not counting\n      // the first/last child's margins into height.\n      var style = getComputedStyle(afterItemsNode) || {};\n      var firstStyle = afterItemsNode.firstElementChild && getComputedStyle(afterItemsNode.firstElementChild) || {};\n      var lastStyle = afterItemsNode.lastElementChild && getComputedStyle(afterItemsNode.lastElementChild) || {};\n      repeaterAfterSize = (parseInt(style[isVertical ? 'height' : 'width']) || 0) +\n        (firstStyle && parseInt(firstStyle[isVertical ? 'marginTop' : 'marginLeft']) || 0) +\n        (lastStyle && parseInt(lastStyle[isVertical ? 'marginBottom' : 'marginRight']) || 0);\n\n      // Get the offsetTop of the repeater.\n      repeaterBeforeSize = 0;\n      var current = containerNode;\n      do {\n        repeaterBeforeSize += current[isVertical ? 'offsetTop' : 'offsetLeft'];\n      } while ( ionic.DomUtil.contains(scrollView.__content, current = current.offsetParent) );\n\n      var containerPrevNode = containerNode.previousElementSibling;\n      var beforeStyle = containerPrevNode ? $window.getComputedStyle(containerPrevNode) : {};\n      var beforeMargin = parseInt(beforeStyle[isVertical ? 'marginBottom' : 'marginRight'] || 0);\n\n      // Because we position the collection container with position: relative, it doesn't take\n      // into account where to position itself relative to the previous element's marginBottom.\n      // To compensate, we translate the container up by the previous element's margin.\n      containerNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR\n        .replace(PRIMARY, -beforeMargin)\n        .replace(SECONDARY, 0);\n      repeaterBeforeSize -= beforeMargin;\n\n      if (!scrollView.__clientHeight || !scrollView.__clientWidth) {\n        scrollView.__clientWidth = scrollView.__container.clientWidth;\n        scrollView.__clientHeight = scrollView.__container.clientHeight;\n      }\n\n      (view.onRefreshLayout || angular.noop)();\n      view.refreshDirection();\n      scrollViewSetDimensions();\n\n      // Create the pool of items for reuse, setting the size to (estimatedItemsOnScreen) * 2,\n      // plus the size of the renderBuffer.\n      if (!isLayoutReady) {\n        var poolSize = Math.max(20, renderBuffer * 3);\n        for (var i = 0; i < poolSize; i++) {\n          itemsPool.push(new RepeatItem());\n        }\n      }\n\n      isLayoutReady = true;\n      if (isLayoutReady && isDataReady) {\n        // If the resize or latest data change caused the scrollValue to\n        // now be out of bounds, resize the scrollView.\n        if (scrollView.__scrollLeft > scrollView.__maxScrollLeft ||\n            scrollView.__scrollTop > scrollView.__maxScrollTop) {\n          scrollView.resize();\n        }\n        forceRerender(true);\n      }\n    };\n\n    this.setData = function(newData) {\n      data = newData;\n      (view.onRefreshData || angular.noop)();\n      isDataReady = true;\n    };\n\n    this.destroy = function() {\n      render.destroyed = true;\n\n      itemsPool.forEach(function(item) {\n        item.scope.$destroy();\n        item.scope = item.element = item.node = item.images = null;\n      });\n      itemsPool.length = itemsEntering.length = itemsLeaving.length = 0;\n      itemsShownMap = {};\n\n      //Restore the scrollView's normal behavior and resize it to normal size.\n      scrollView.options[contentSizeStr] = originalGetContentSize;\n      scrollView.__callback = scrollView.__$callback;\n      scrollView.resize();\n\n      (view.onDestroy || angular.noop)();\n    };\n\n    function forceRerender() {\n      return render(true);\n    }\n    function render(forceRerender) {\n      if (render.destroyed) return;\n      var i;\n      var ii;\n      var item;\n      var dim;\n      var scope;\n      var scrollValue = view.getScrollValue();\n      var scrollValueEnd = scrollValue + view.scrollPrimarySize;\n\n      view.updateRenderRange(scrollValue, scrollValueEnd);\n\n      renderStartIndex = Math.max(0, renderStartIndex - renderBuffer);\n      renderEndIndex = Math.min(data.length - 1, renderEndIndex + renderBuffer);\n\n      for (i in itemsShownMap) {\n        if (i < renderStartIndex || i > renderEndIndex) {\n          item = itemsShownMap[i];\n          delete itemsShownMap[i];\n          itemsLeaving.push(item);\n          item.isShown = false;\n        }\n      }\n\n      // Render indicies that aren't shown yet\n      //\n      // NOTE(ajoslin): this may sound crazy, but calling any other functions during this render\n      // loop will often push the render time over the edge from less than one frame to over\n      // one frame, causing visible jank.\n      // DON'T call any other functions inside this loop unless it's vital.\n      for (i = renderStartIndex; i <= renderEndIndex; i++) {\n        // We only go forward with render if the index is in data, the item isn't already shown,\n        // or forceRerender is on.\n        if (i >= data.length || (itemsShownMap[i] && !forceRerender)) continue;\n\n        item = itemsShownMap[i] || (itemsShownMap[i] = itemsLeaving.length ? itemsLeaving.pop() :\n                                    itemsPool.length ? itemsPool.shift() :\n                                    new RepeatItem());\n        itemsEntering.push(item);\n        item.isShown = true;\n\n        scope = item.scope;\n        scope.$index = i;\n        scope[keyExpression] = data[i];\n        scope.$first = (i === 0);\n        scope.$last = (i === (data.length - 1));\n        scope.$middle = !(scope.$first || scope.$last);\n        scope.$odd = !(scope.$even = (i & 1) === 0);\n\n        if (scope.$$disconnected) ionic.Utils.reconnectScope(item.scope);\n\n        dim = view.getDimensions(i);\n        if (item.secondaryPos !== dim.secondaryPos || item.primaryPos !== dim.primaryPos) {\n          item.node.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR\n            .replace(PRIMARY, (item.primaryPos = dim.primaryPos))\n            .replace(SECONDARY, (item.secondaryPos = dim.secondaryPos));\n        }\n        if (item.secondarySize !== dim.secondarySize || item.primarySize !== dim.primarySize) {\n          item.node.style.cssText = item.node.style.cssText\n            .replace(WIDTH_HEIGHT_REGEX, WIDTH_HEIGHT_TEMPLATE_STR\n              //TODO fix item.primarySize + 1 hack\n              .replace(PRIMARY, (item.primarySize = dim.primarySize) + 1)\n              .replace(SECONDARY, (item.secondarySize = dim.secondarySize))\n            );\n        }\n\n      }\n\n      // If we reach the end of the list, render the afterItemsNode - this contains all the\n      // elements the developer placed after the collection-repeat\n      if (renderEndIndex === data.length - 1) {\n        dim = view.getDimensions(data.length - 1) || EMPTY_DIMENSION;\n        afterItemsNode.style[ionic.CSS.TRANSFORM] = TRANSLATE_TEMPLATE_STR\n          .replace(PRIMARY, dim.primaryPos + dim.primarySize)\n          .replace(SECONDARY, 0);\n      }\n\n      while (itemsLeaving.length) {\n        item = itemsLeaving.pop();\n        item.scope.$broadcast('$collectionRepeatLeave');\n        ionic.Utils.disconnectScope(item.scope);\n        itemsPool.push(item);\n        item.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';\n        item.primaryPos = item.secondaryPos = null;\n      }\n\n      if (forceRefreshImages) {\n        for (i = 0, ii = itemsEntering.length; i < ii && (item = itemsEntering[i]); i++) {\n          if (!item.images) continue;\n          for (var j = 0, jj = item.images.length, img; j < jj && (img = item.images[j]); j++) {\n            var src = img.src;\n            img.src = ONE_PX_TRANSPARENT_IMG_SRC;\n            img.src = src;\n          }\n        }\n      }\n      if (forceRerender) {\n        var rootScopePhase = $rootScope.$$phase;\n        while (itemsEntering.length) {\n          item = itemsEntering.pop();\n          if (!rootScopePhase) item.scope.$digest();\n        }\n      } else {\n        digestEnteringItems();\n      }\n    }\n\n    function digestEnteringItems() {\n      var item;\n      if (digestEnteringItems.running) return;\n      digestEnteringItems.running = true;\n\n      $$rAF(function process() {\n        var rootScopePhase = $rootScope.$$phase;\n        while (itemsEntering.length) {\n          item = itemsEntering.pop();\n          if (item.isShown) {\n            if (!rootScopePhase) item.scope.$digest();\n          }\n        }\n        digestEnteringItems.running = false;\n      });\n    }\n\n    function RepeatItem() {\n      var self = this;\n      this.scope = scope.$new();\n      this.id = 'item' + (nextItemId++);\n      transclude(this.scope, function(clone) {\n        self.element = clone;\n        self.element.data('$$collectionRepeatItem', self);\n        // TODO destroy\n        self.node = clone[0];\n        // Batch style setting to lower repaints\n        self.node.style[ionic.CSS.TRANSFORM] = 'translate3d(-9999px,-9999px,0)';\n        self.node.style.cssText += ' height: 0px; width: 0px;';\n        ionic.Utils.disconnectScope(self.scope);\n        containerNode.appendChild(self.node);\n        self.images = clone[0].getElementsByTagName('img');\n      });\n    }\n\n    function VerticalViewType() {\n      this.getItemPrimarySize = heightGetter;\n      this.getItemSecondarySize = widthGetter;\n\n      this.getScrollValue = function() {\n        return Math.max(0, Math.min(scrollView.__scrollTop - repeaterBeforeSize,\n          scrollView.__maxScrollTop - repeaterBeforeSize - repeaterAfterSize));\n      };\n\n      this.refreshDirection = function() {\n        this.scrollPrimarySize = scrollView.__clientHeight;\n        this.scrollSecondarySize = scrollView.__clientWidth;\n\n        this.estimatedPrimarySize = estimatedHeight;\n        this.estimatedSecondarySize = estimatedWidth;\n        this.estimatedItemsAcross = isGridView &&\n          Math.floor(scrollView.__clientWidth / estimatedWidth) ||\n          1;\n      };\n    }\n    function HorizontalViewType() {\n      this.getItemPrimarySize = widthGetter;\n      this.getItemSecondarySize = heightGetter;\n\n      this.getScrollValue = function() {\n        return Math.max(0, Math.min(scrollView.__scrollLeft - repeaterBeforeSize,\n          scrollView.__maxScrollLeft - repeaterBeforeSize - repeaterAfterSize));\n      };\n\n      this.refreshDirection = function() {\n        this.scrollPrimarySize = scrollView.__clientWidth;\n        this.scrollSecondarySize = scrollView.__clientHeight;\n\n        this.estimatedPrimarySize = estimatedWidth;\n        this.estimatedSecondarySize = estimatedHeight;\n        this.estimatedItemsAcross = isGridView &&\n          Math.floor(scrollView.__clientHeight / estimatedHeight) ||\n          1;\n      };\n    }\n\n    function GridViewType() {\n      this.getEstimatedSecondaryPos = function(index) {\n        return (index % this.estimatedItemsAcross) * this.estimatedSecondarySize;\n      };\n      this.getEstimatedPrimaryPos = function(index) {\n        return Math.floor(index / this.estimatedItemsAcross) * this.estimatedPrimarySize;\n      };\n      this.getEstimatedIndex = function(scrollValue) {\n        return Math.floor(scrollValue / this.estimatedPrimarySize) *\n          this.estimatedItemsAcross;\n      };\n    }\n\n    function ListViewType() {\n      this.getEstimatedSecondaryPos = function() {\n        return 0;\n      };\n      this.getEstimatedPrimaryPos = function(index) {\n        return index * this.estimatedPrimarySize;\n      };\n      this.getEstimatedIndex = function(scrollValue) {\n        return Math.floor((scrollValue) / this.estimatedPrimarySize);\n      };\n    }\n\n    function StaticViewType() {\n      this.getContentSize = function() {\n        return this.getEstimatedPrimaryPos(data.length - 1) + this.estimatedPrimarySize +\n          repeaterBeforeSize + repeaterAfterSize;\n      };\n      // static view always returns the same object for getDimensions, to avoid memory allocation\n      // while scrolling. This could be dangerous if this was a public function, but it's not.\n      // Only we use it.\n      var dim = {};\n      this.getDimensions = function(index) {\n        dim.primaryPos = this.getEstimatedPrimaryPos(index);\n        dim.secondaryPos = this.getEstimatedSecondaryPos(index);\n        dim.primarySize = this.estimatedPrimarySize;\n        dim.secondarySize = this.estimatedSecondarySize;\n        return dim;\n      };\n      this.updateRenderRange = function(scrollValue, scrollValueEnd) {\n        renderStartIndex = Math.max(0, this.getEstimatedIndex(scrollValue));\n\n        // Make sure the renderEndIndex takes into account all the items on the row\n        renderEndIndex = Math.min(data.length - 1,\n          this.getEstimatedIndex(scrollValueEnd) + this.estimatedItemsAcross - 1);\n\n        renderBeforeBoundary = Math.max(0,\n          this.getEstimatedPrimaryPos(renderStartIndex));\n        renderAfterBoundary = this.getEstimatedPrimaryPos(renderEndIndex) +\n          this.estimatedPrimarySize;\n      };\n    }\n\n    function DynamicViewType() {\n      var self = this;\n      var debouncedScrollViewSetDimensions = ionic.debounce(scrollViewSetDimensions, 25, true);\n      var calculateDimensions = isGridView ? calculateDimensionsGrid : calculateDimensionsList;\n      var dimensionsIndex;\n      var dimensions = [];\n\n\n      // Get the dimensions at index. {width, height, left, top}.\n      // We start with no dimensions calculated, then any time dimensions are asked for at an\n      // index we calculate dimensions up to there.\n      function calculateDimensionsList(toIndex) {\n        var i, prevDimension, dim;\n        for (i = Math.max(0, dimensionsIndex); i <= toIndex && (dim = dimensions[i]); i++) {\n          prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;\n          dim.primarySize = self.getItemPrimarySize(i, data[i]);\n          dim.secondarySize = self.scrollSecondarySize;\n          dim.primaryPos = prevDimension.primaryPos + prevDimension.primarySize;\n          dim.secondaryPos = 0;\n        }\n      }\n      function calculateDimensionsGrid(toIndex) {\n        var i, prevDimension, dim;\n        for (i = Math.max(dimensionsIndex, 0); i <= toIndex && (dim = dimensions[i]); i++) {\n          prevDimension = dimensions[i - 1] || EMPTY_DIMENSION;\n          dim.secondarySize = Math.min(\n            self.getItemSecondarySize(i, data[i]),\n            self.scrollSecondarySize\n          );\n          dim.secondaryPos = prevDimension.secondaryPos + prevDimension.secondarySize;\n\n          if (i === 0 || dim.secondaryPos + dim.secondarySize > self.scrollSecondarySize) {\n            dim.secondaryPos = 0;\n            dim.primarySize = self.getItemPrimarySize(i, data[i]);\n            dim.primaryPos = prevDimension.primaryPos + prevDimension.rowPrimarySize;\n\n            dim.rowStartIndex = i;\n            dim.rowPrimarySize = dim.primarySize;\n          } else {\n            dim.primarySize = self.getItemPrimarySize(i, data[i]);\n            dim.primaryPos = prevDimension.primaryPos;\n            dim.rowStartIndex = prevDimension.rowStartIndex;\n\n            dimensions[dim.rowStartIndex].rowPrimarySize = dim.rowPrimarySize = Math.max(\n              dimensions[dim.rowStartIndex].rowPrimarySize,\n              dim.primarySize\n            );\n            dim.rowPrimarySize = Math.max(dim.primarySize, dim.rowPrimarySize);\n          }\n        }\n      }\n\n      this.getContentSize = function() {\n        var dim = dimensions[dimensionsIndex] || EMPTY_DIMENSION;\n        return ((dim.primaryPos + dim.primarySize) || 0) +\n          this.getEstimatedPrimaryPos(data.length - dimensionsIndex - 1) +\n          repeaterBeforeSize + repeaterAfterSize;\n      };\n      this.onDestroy = function() {\n        dimensions.length = 0;\n      };\n\n      this.onRefreshData = function() {\n        var i;\n        var ii;\n        // Make sure dimensions has as many items as data.length.\n        // This is to be sure we don't have to allocate objects while scrolling.\n        for (i = dimensions.length, ii = data.length; i < ii; i++) {\n          dimensions.push({});\n        }\n        dimensionsIndex = -1;\n      };\n      this.onRefreshLayout = function() {\n        dimensionsIndex = -1;\n      };\n      this.getDimensions = function(index) {\n        index = Math.min(index, data.length - 1);\n\n        if (dimensionsIndex < index) {\n          // Once we start asking for dimensions near the end of the list, go ahead and calculate\n          // everything. This is to make sure when the user gets to the end of the list, the\n          // scroll height of the list is 100% accurate (not estimated anymore).\n          if (index > data.length * 0.9) {\n            calculateDimensions(data.length - 1);\n            dimensionsIndex = data.length - 1;\n            scrollViewSetDimensions();\n          } else {\n            calculateDimensions(index);\n            dimensionsIndex = index;\n            debouncedScrollViewSetDimensions();\n          }\n\n        }\n        return dimensions[index];\n      };\n\n      var oldRenderStartIndex = -1;\n      var oldScrollValue = -1;\n      this.updateRenderRange = function(scrollValue, scrollValueEnd) {\n        var i;\n        var len;\n        var dim;\n\n        // Calculate more dimensions than we estimate we'll need, to be sure.\n        this.getDimensions( this.getEstimatedIndex(scrollValueEnd) * 2 );\n\n        // -- Calculate renderStartIndex\n        // base case: start at 0\n        if (oldRenderStartIndex === -1 || scrollValue === 0) {\n          i = 0;\n        // scrolling down\n        } else if (scrollValue >= oldScrollValue) {\n          for (i = oldRenderStartIndex, len = data.length; i < len; i++) {\n            if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize >= scrollValue) {\n              break;\n            }\n          }\n        // scrolling up\n        } else {\n          for (i = oldRenderStartIndex; i >= 0; i--) {\n            if ((dim = this.getDimensions(i)) && dim.primaryPos <= scrollValue) {\n              // when grid view, make sure the render starts at the beginning of a row.\n              i = isGridView ? dim.rowStartIndex : i;\n              break;\n            }\n          }\n        }\n\n        renderStartIndex = Math.min(Math.max(0, i), data.length - 1);\n        renderBeforeBoundary = renderStartIndex !== -1 ? this.getDimensions(renderStartIndex).primaryPos : -1;\n\n        // -- Calculate renderEndIndex\n        var lastRowDim;\n        for (i = renderStartIndex + 1, len = data.length; i < len; i++) {\n          if ((dim = this.getDimensions(i)) && dim.primaryPos + dim.rowPrimarySize > scrollValueEnd) {\n\n            // Go all the way to the end of the row if we're in a grid\n            if (isGridView) {\n              lastRowDim = dim;\n              while (i < len - 1 &&\n                    (dim = this.getDimensions(i + 1)).primaryPos === lastRowDim.primaryPos) {\n                i++;\n              }\n            }\n            break;\n          }\n        }\n\n        renderEndIndex = Math.min(i, data.length - 1);\n        renderAfterBoundary = renderEndIndex !== -1 ?\n          ((dim = this.getDimensions(renderEndIndex)).primaryPos + (dim.rowPrimarySize || dim.primarySize)) :\n          -1;\n\n        oldScrollValue = scrollValue;\n        oldRenderStartIndex = renderStartIndex;\n      };\n    }\n\n\n  };\n\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/collectionRepeat.js\n ** module id = 44\n ** module chunks = 0\n **/","/**\r\n * @ngdoc directive\r\n * @name ionContent\r\n * @module ionic\r\n * @delegate ionic.service:$ionicScrollDelegate\r\n * @restrict E\r\n *\r\n * @description\r\n * The ionContent directive provides an easy to use content area that can be configured\r\n * to use Ionic's custom Scroll View, or the built in overflow scrolling of the browser.\r\n *\r\n * While we recommend using the custom Scroll features in Ionic in most cases, sometimes\r\n * (for performance reasons) only the browser's native overflow scrolling will suffice,\r\n * and so we've made it easy to toggle between the Ionic scroll implementation and\r\n * overflow scrolling.\r\n *\r\n * You can implement pull-to-refresh with the {@link ionic.directive:ionRefresher}\r\n * directive, and infinite scrolling with the {@link ionic.directive:ionInfiniteScroll}\r\n * directive.\r\n *\r\n * If there is any dynamic content inside the ion-content, be sure to call `.resize()` with {@link ionic.service:$ionicScrollDelegate}\r\n * after the content has been added.\r\n *\r\n * Be aware that this directive gets its own child scope. If you do not understand why this\r\n * is important, you can read [https://docs.angularjs.org/guide/scope](https://docs.angularjs.org/guide/scope).\r\n *\r\n * @param {string=} delegate-handle The handle used to identify this scrollView\r\n * with {@link ionic.service:$ionicScrollDelegate}.\r\n * @param {string=} direction Which way to scroll. 'x' or 'y' or 'xy'. Default 'y'.\r\n * @param {boolean=} locking Whether to lock scrolling in one direction at a time. Useful to set to false when zoomed in or scrolling in two directions. Default true.\r\n * @param {boolean=} padding Whether to add padding to the content.\r\n * Defaults to true on iOS, false on Android.\r\n * @param {boolean=} scroll Whether to allow scrolling of content.  Defaults to true.\r\n * @param {boolean=} overflow-scroll Whether to use overflow-scrolling instead of\r\n * Ionic scroll. See {@link ionic.provider:$ionicConfigProvider} to set this as the global default.\r\n * @param {boolean=} scrollbar-x Whether to show the horizontal scrollbar. Default true.\r\n * @param {boolean=} scrollbar-y Whether to show the vertical scrollbar. Default true.\r\n * @param {string=} start-x Initial horizontal scroll position. Default 0.\r\n * @param {string=} start-y Initial vertical scroll position. Default 0.\r\n * @param {expression=} on-scroll Expression to evaluate when the content is scrolled.\r\n * @param {expression=} on-scroll-complete Expression to evaluate when a scroll action completes. Has access to 'scrollLeft' and 'scrollTop' locals.\r\n * @param {boolean=} has-bouncing Whether to allow scrolling to bounce past the edges\r\n * of the content.  Defaults to true on iOS, false on Android.\r\n * @param {number=} scroll-event-interval Number of milliseconds between each firing of the 'on-scroll' expression. Default 10.\r\n */\r\nIonicModule\r\n.directive('ionContent', [\r\n  '$timeout',\r\n  '$controller',\r\n  '$ionicBind',\r\n  '$ionicConfig',\r\nfunction($timeout, $controller, $ionicBind, $ionicConfig) {\r\n  return {\r\n    restrict: 'E',\r\n    require: '^?ionNavView',\r\n    scope: true,\r\n    priority: 800,\r\n    compile: function(element, attr) {\r\n      var innerElement;\r\n      var scrollCtrl;\r\n\r\n      element.addClass('scroll-content ionic-scroll');\r\n\r\n      if (attr.scroll != 'false') {\r\n        //We cannot use normal transclude here because it breaks element.data()\r\n        //inheritance on compile\r\n        innerElement = jqLite('<div class=\"scroll\"></div>');\r\n        innerElement.append(element.contents());\r\n        element.append(innerElement);\r\n      } else {\r\n        element.addClass('scroll-content-false');\r\n      }\r\n\r\n      var nativeScrolling = attr.overflowScroll !== \"false\" && (attr.overflowScroll === \"true\" || !$ionicConfig.scrolling.jsScrolling());\r\n\r\n      // collection-repeat requires JS scrolling\r\n      if (nativeScrolling) {\r\n        nativeScrolling = !element[0].querySelector('[collection-repeat]');\r\n      }\r\n      return { pre: prelink };\r\n      function prelink($scope, $element, $attr) {\r\n        var parentScope = $scope.$parent;\r\n        $scope.$watch(function() {\r\n          return (parentScope.$hasHeader ? ' has-header' : '') +\r\n            (parentScope.$hasSubheader ? ' has-subheader' : '') +\r\n            (parentScope.$hasFooter ? ' has-footer' : '') +\r\n            (parentScope.$hasSubfooter ? ' has-subfooter' : '') +\r\n            (parentScope.$hasTabs ? ' has-tabs' : '') +\r\n            (parentScope.$hasTabsTop ? ' has-tabs-top' : '');\r\n        }, function(className, oldClassName) {\r\n          $element.removeClass(oldClassName);\r\n          $element.addClass(className);\r\n        });\r\n\r\n        //Only this ionContent should use these variables from parent scopes\r\n        $scope.$hasHeader = $scope.$hasSubheader =\r\n          $scope.$hasFooter = $scope.$hasSubfooter =\r\n          $scope.$hasTabs = $scope.$hasTabsTop =\r\n          false;\r\n        $ionicBind($scope, $attr, {\r\n          $onScroll: '&onScroll',\r\n          $onScrollComplete: '&onScrollComplete',\r\n          hasBouncing: '@',\r\n          padding: '@',\r\n          direction: '@',\r\n          scrollbarX: '@',\r\n          scrollbarY: '@',\r\n          startX: '@',\r\n          startY: '@',\r\n          scrollEventInterval: '@'\r\n        });\r\n        $scope.direction = $scope.direction || 'y';\r\n\r\n        if (isDefined($attr.padding)) {\r\n          $scope.$watch($attr.padding, function(newVal) {\r\n              (innerElement || $element).toggleClass('padding', !!newVal);\r\n          });\r\n        }\r\n\r\n        if ($attr.scroll === \"false\") {\r\n          //do nothing\r\n        } else {\r\n          var scrollViewOptions = {};\r\n\r\n          // determined in compile phase above\r\n          if (nativeScrolling) {\r\n            // use native scrolling\r\n            $element.addClass('overflow-scroll');\r\n\r\n            scrollViewOptions = {\r\n              el: $element[0],\r\n              delegateHandle: attr.delegateHandle,\r\n              startX: $scope.$eval($scope.startX) || 0,\r\n              startY: $scope.$eval($scope.startY) || 0,\r\n              nativeScrolling: true\r\n            };\r\n\r\n          } else {\r\n            // Use JS scrolling\r\n            scrollViewOptions = {\r\n              el: $element[0],\r\n              delegateHandle: attr.delegateHandle,\r\n              locking: (attr.locking || 'true') === 'true',\r\n              bouncing: $scope.$eval($scope.hasBouncing),\r\n              startX: $scope.$eval($scope.startX) || 0,\r\n              startY: $scope.$eval($scope.startY) || 0,\r\n              scrollbarX: $scope.$eval($scope.scrollbarX) !== false,\r\n              scrollbarY: $scope.$eval($scope.scrollbarY) !== false,\r\n              scrollingX: $scope.direction.indexOf('x') >= 0,\r\n              scrollingY: $scope.direction.indexOf('y') >= 0,\r\n              scrollEventInterval: parseInt($scope.scrollEventInterval, 10) || 10,\r\n              scrollingComplete: onScrollComplete\r\n            };\r\n          }\r\n\r\n          // init scroll controller with appropriate options\r\n          scrollCtrl = $controller('$ionicScroll', {\r\n            $scope: $scope,\r\n            scrollViewOptions: scrollViewOptions\r\n          });\r\n\r\n          $scope.scrollCtrl = scrollCtrl;\r\n\r\n          $scope.$on('$destroy', function() {\r\n            if (scrollViewOptions) {\r\n              scrollViewOptions.scrollingComplete = noop;\r\n              delete scrollViewOptions.el;\r\n            }\r\n            innerElement = null;\r\n            $element = null;\r\n            attr.$$element = null;\r\n          });\r\n        }\r\n\r\n        function onScrollComplete() {\r\n          $scope.$onScrollComplete({\r\n            scrollTop: scrollCtrl.scrollView.__scrollTop,\r\n            scrollLeft: scrollCtrl.scrollView.__scrollLeft\r\n          });\r\n        }\r\n\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/content.js\n ** module id = 45\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name exposeAsideWhen\n * @module ionic\n * @restrict A\n * @parent ionic.directive:ionSideMenus\n *\n * @description\n * It is common for a tablet application to hide a menu when in portrait mode, but to show the\n * same menu on the left side when the tablet is in landscape mode. The `exposeAsideWhen` attribute\n * directive can be used to accomplish a similar interface.\n *\n * By default, side menus are hidden underneath its side menu content, and can be opened by either\n * swiping the content left or right, or toggling a button to show the side menu. However, by adding the\n * `exposeAsideWhen` attribute directive to an {@link ionic.directive:ionSideMenu} element directive,\n * a side menu can be given instructions on \"when\" the menu should be exposed (always viewable). For\n * example, the `expose-aside-when=\"large\"` attribute will keep the side menu hidden when the viewport's\n * width is less than `768px`, but when the viewport's width is `768px` or greater, the menu will then\n * always be shown and can no longer be opened or closed like it could when it was hidden for smaller\n * viewports.\n *\n * Using `large` as the attribute's value is a shortcut value to `(min-width:768px)` since it is\n * the most common use-case. However, for added flexibility, any valid media query could be added\n * as the value, such as `(min-width:600px)` or even multiple queries such as\n * `(min-width:750px) and (max-width:1200px)`.\n * @usage\n * ```html\n * <ion-side-menus>\n *   <!-- Center content -->\n *   <ion-side-menu-content>\n *   </ion-side-menu-content>\n *\n *   <!-- Left menu -->\n *   <ion-side-menu expose-aside-when=\"large\">\n *   </ion-side-menu>\n * </ion-side-menus>\n * ```\n * For a complete side menu example, see the\n * {@link ionic.directive:ionSideMenus} documentation.\n */\n\nIonicModule.directive('exposeAsideWhen', ['$window', function($window) {\n  return {\n    restrict: 'A',\n    require: '^ionSideMenus',\n    link: function($scope, $element, $attr, sideMenuCtrl) {\n\n      // Setup a match media query listener that triggers a ui change only when a change\n      // in media matching status occurs\n      var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;\n      var mql = $window.matchMedia(mq);\n      mql.addListener(function() {\n        onResize();\n      });\n\n      function checkAsideExpose() {\n        var mq = $attr.exposeAsideWhen == 'large' ? '(min-width:768px)' : $attr.exposeAsideWhen;\n        sideMenuCtrl.exposeAside($window.matchMedia(mq).matches);\n        sideMenuCtrl.activeAsideResizing(false);\n      }\n\n      function onResize() {\n        sideMenuCtrl.activeAsideResizing(true);\n        debouncedCheck();\n      }\n\n      var debouncedCheck = ionic.debounce(function() {\n        $scope.$apply(checkAsideExpose);\n      }, 300, false);\n\n      $scope.$evalAsync(checkAsideExpose);\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/exposeAsideWhen.js\n ** module id = 46\n ** module chunks = 0\n **/","var GESTURE_DIRECTIVES = 'onHold onTap onDoubleTap onTouch onRelease onDragStart onDrag onDragEnd onDragUp onDragRight onDragDown onDragLeft onSwipe onSwipeUp onSwipeRight onSwipeDown onSwipeLeft'.split(' ');\n\nGESTURE_DIRECTIVES.forEach(function(name) {\n  IonicModule.directive(name, gestureDirective(name));\n});\n\n\n/**\n * @ngdoc directive\n * @name onHold\n * @module ionic\n * @restrict A\n *\n * @description\n * Touch stays at the same location for 500ms. Similar to long touch events available for AngularJS and jQuery.\n *\n * @usage\n * ```html\n * <button on-hold=\"onHold()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onTap\n * @module ionic\n * @restrict A\n *\n * @description\n * Quick touch at a location. If the duration of the touch goes\n * longer than 250ms it is no longer a tap gesture.\n *\n * @usage\n * ```html\n * <button on-tap=\"onTap()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onDoubleTap\n * @module ionic\n * @restrict A\n *\n * @description\n * Double tap touch at a location.\n *\n * @usage\n * ```html\n * <button on-double-tap=\"onDoubleTap()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onTouch\n * @module ionic\n * @restrict A\n *\n * @description\n * Called immediately when the user first begins a touch. This\n * gesture does not wait for a touchend/mouseup.\n *\n * @usage\n * ```html\n * <button on-touch=\"onTouch()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onRelease\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when the user ends a touch.\n *\n * @usage\n * ```html\n * <button on-release=\"onRelease()\" class=\"button\">Test</button>\n * ```\n */\n\n/**\n * @ngdoc directive\n * @name onDragStart\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when a drag gesture has started.\n *\n * @usage\n * ```html\n * <button on-drag-start=\"onDragStart()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onDrag\n * @module ionic\n * @restrict A\n *\n * @description\n * Move with one touch around on the page. Blocking the scrolling when\n * moving left and right is a good practice. When all the drag events are\n * blocking you disable scrolling on that area.\n *\n * @usage\n * ```html\n * <button on-drag=\"onDrag()\" class=\"button\">Test</button>\n * ```\n */\n\n/**\n * @ngdoc directive\n * @name onDragEnd\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when a drag gesture has ended.\n *\n * @usage\n * ```html\n * <button on-drag-end=\"onDragEnd()\" class=\"button\">Test</button>\n * ```\n */\n\n/**\n * @ngdoc directive\n * @name onDragUp\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when the element is dragged up.\n *\n * @usage\n * ```html\n * <button on-drag-up=\"onDragUp()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onDragRight\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when the element is dragged to the right.\n *\n * @usage\n * ```html\n * <button on-drag-right=\"onDragRight()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onDragDown\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when the element is dragged down.\n *\n * @usage\n * ```html\n * <button on-drag-down=\"onDragDown()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onDragLeft\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when the element is dragged to the left.\n *\n * @usage\n * ```html\n * <button on-drag-left=\"onDragLeft()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onSwipe\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when a moving touch has a high velocity in any direction.\n *\n * @usage\n * ```html\n * <button on-swipe=\"onSwipe()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onSwipeUp\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when a moving touch has a high velocity moving up.\n *\n * @usage\n * ```html\n * <button on-swipe-up=\"onSwipeUp()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onSwipeRight\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when a moving touch has a high velocity moving to the right.\n *\n * @usage\n * ```html\n * <button on-swipe-right=\"onSwipeRight()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onSwipeDown\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when a moving touch has a high velocity moving down.\n *\n * @usage\n * ```html\n * <button on-swipe-down=\"onSwipeDown()\" class=\"button\">Test</button>\n * ```\n */\n\n\n/**\n * @ngdoc directive\n * @name onSwipeLeft\n * @module ionic\n * @restrict A\n *\n * @description\n * Called when a moving touch has a high velocity moving to the left.\n *\n * @usage\n * ```html\n * <button on-swipe-left=\"onSwipeLeft()\" class=\"button\">Test</button>\n * ```\n */\n\n\nfunction gestureDirective(directiveName) {\n  return ['$ionicGesture', '$parse', function($ionicGesture, $parse) {\n    var eventType = directiveName.substr(2).toLowerCase();\n\n    return function(scope, element, attr) {\n      var fn = $parse( attr[directiveName] );\n\n      var listener = function(ev) {\n        scope.$apply(function() {\n          fn(scope, {\n            $event: ev\n          });\n        });\n      };\n\n      var gesture = $ionicGesture.on(eventType, listener, element);\n\n      scope.$on('$destroy', function() {\n        $ionicGesture.off(gesture, eventType, listener);\n      });\n    };\n  }];\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/gesture.js\n ** module id = 47\n ** module chunks = 0\n **/","\nIonicModule\n//.directive('ionHeaderBar', tapScrollToTopDirective())\n\n/**\n * @ngdoc directive\n * @name ionHeaderBar\n * @module ionic\n * @restrict E\n *\n * @description\n * Adds a fixed header bar above some content.\n *\n * Can also be a subheader (lower down) if the 'bar-subheader' class is applied.\n * See [the header CSS docs](/docs/components/#subheader).\n *\n * @param {string=} align-title How to align the title. By default the title\n * will be aligned the same as how the platform aligns its titles (iOS centers\n * titles, Android aligns them left).\n * Available: 'left', 'right', or 'center'.  Defaults to the same as the platform.\n * @param {boolean=} no-tap-scroll By default, the header bar will scroll the\n * content to the top when tapped.  Set no-tap-scroll to true to disable this\n * behavior.\n * Available: true or false.  Defaults to false.\n *\n * @usage\n * ```html\n * <ion-header-bar align-title=\"left\" class=\"bar-positive\">\n *   <div class=\"buttons\">\n *     <button class=\"button\" ng-click=\"doSomething()\">Left Button</button>\n *   </div>\n *   <h1 class=\"title\">Title!</h1>\n *   <div class=\"buttons\">\n *     <button class=\"button\">Right Button</button>\n *   </div>\n * </ion-header-bar>\n * <ion-content>\n *   Some content!\n * </ion-content>\n * ```\n */\n.directive('ionHeaderBar', headerFooterBarDirective(true))\n\n/**\n * @ngdoc directive\n * @name ionFooterBar\n * @module ionic\n * @restrict E\n *\n * @description\n * Adds a fixed footer bar below some content.\n *\n * Can also be a subfooter (higher up) if the 'bar-subfooter' class is applied.\n * See [the footer CSS docs](/docs/components/#footer).\n *\n * Note: If you use ionFooterBar in combination with ng-if, the surrounding content\n * will not align correctly.  This will be fixed soon.\n *\n * @param {string=} align-title Where to align the title.\n * Available: 'left', 'right', or 'center'.  Defaults to 'center'.\n *\n * @usage\n * ```html\n * <ion-content>\n *   Some content!\n * </ion-content>\n * <ion-footer-bar align-title=\"left\" class=\"bar-assertive\">\n *   <div class=\"buttons\">\n *     <button class=\"button\">Left Button</button>\n *   </div>\n *   <h1 class=\"title\">Title!</h1>\n *   <div class=\"buttons\" ng-click=\"doSomething()\">\n *     <button class=\"button\">Right Button</button>\n *   </div>\n * </ion-footer-bar>\n * ```\n */\n.directive('ionFooterBar', headerFooterBarDirective(false));\n\nfunction tapScrollToTopDirective() { //eslint-disable-line no-unused-vars\n  return ['$ionicScrollDelegate', function($ionicScrollDelegate) {\n    return {\n      restrict: 'E',\n      link: function($scope, $element, $attr) {\n        if ($attr.noTapScroll == 'true') {\n          return;\n        }\n        ionic.on('tap', onTap, $element[0]);\n        $scope.$on('$destroy', function() {\n          ionic.off('tap', onTap, $element[0]);\n        });\n\n        function onTap(e) {\n          var depth = 3;\n          var current = e.target;\n          //Don't scroll to top in certain cases\n          while (depth-- && current) {\n            if (current.classList.contains('button') ||\n                current.tagName.match(/input|textarea|select/i) ||\n                current.isContentEditable) {\n              return;\n            }\n            current = current.parentNode;\n          }\n          var touch = e.gesture && e.gesture.touches[0] || e.detail.touches[0];\n          var bounds = $element[0].getBoundingClientRect();\n          if (ionic.DomUtil.rectContains(\n            touch.pageX, touch.pageY,\n            bounds.left, bounds.top - 20,\n            bounds.left + bounds.width, bounds.top + bounds.height\n          )) {\n            $ionicScrollDelegate.scrollTop(true);\n          }\n        }\n      }\n    };\n  }];\n}\n\nfunction headerFooterBarDirective(isHeader) {\n  return ['$document', '$timeout', function($document, $timeout) {\n    return {\n      restrict: 'E',\n      controller: '$ionicHeaderBar',\n      compile: function(tElement) {\n        tElement.addClass(isHeader ? 'bar bar-header' : 'bar bar-footer');\n        // top style tabs? if so, remove bottom border for seamless display\n        $timeout(function() {\n          if (isHeader && $document[0].getElementsByClassName('tabs-top').length) tElement.addClass('has-tabs-top');\n        });\n\n        return { pre: prelink };\n        function prelink($scope, $element, $attr, ctrl) {\n          if (isHeader) {\n            $scope.$watch(function() { return $element[0].className; }, function(value) {\n              var isShown = value.indexOf('ng-hide') === -1;\n              var isSubheader = value.indexOf('bar-subheader') !== -1;\n              $scope.$hasHeader = isShown && !isSubheader;\n              $scope.$hasSubheader = isShown && isSubheader;\n              $scope.$emit('$ionicSubheader', $scope.$hasSubheader);\n            });\n            $scope.$on('$destroy', function() {\n              delete $scope.$hasHeader;\n              delete $scope.$hasSubheader;\n            });\n            ctrl.align();\n            $scope.$on('$ionicHeader.align', function() {\n              ionic.requestAnimationFrame(function() {\n                ctrl.align();\n              });\n            });\n\n          } else {\n            $scope.$watch(function() { return $element[0].className; }, function(value) {\n              var isShown = value.indexOf('ng-hide') === -1;\n              var isSubfooter = value.indexOf('bar-subfooter') !== -1;\n              $scope.$hasFooter = isShown && !isSubfooter;\n              $scope.$hasSubfooter = isShown && isSubfooter;\n            });\n            $scope.$on('$destroy', function() {\n              delete $scope.$hasFooter;\n              delete $scope.$hasSubfooter;\n            });\n            $scope.$watch('$hasTabs', function(val) {\n              $element.toggleClass('has-tabs', !!val);\n            });\n            ctrl.align();\n            $scope.$on('$ionicFooter.align', function() {\n              ionic.requestAnimationFrame(function() {\n                ctrl.align();\n              });\n            });\n          }\n        }\n      }\n    };\n  }];\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/headerFooterBar.js\n ** module id = 48\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionInfiniteScroll\n * @module ionic\n * @parent ionic.directive:ionContent, ionic.directive:ionScroll\n * @restrict E\n *\n * @description\n * The ionInfiniteScroll directive allows you to call a function whenever\n * the user gets to the bottom of the page or near the bottom of the page.\n *\n * The expression you pass in for `on-infinite` is called when the user scrolls\n * greater than `distance` away from the bottom of the content.  Once `on-infinite`\n * is done loading new data, it should broadcast the `scroll.infiniteScrollComplete`\n * event from your controller (see below example).\n *\n * @param {expression} on-infinite What to call when the scroller reaches the\n * bottom.\n * @param {string=} distance The distance from the bottom that the scroll must\n * reach to trigger the on-infinite expression. Default: 1%.\n * @param {string=} spinner The {@link ionic.directive:ionSpinner} to show while loading. The SVG\n * {@link ionic.directive:ionSpinner} is now the default, replacing rotating font icons.\n * @param {string=} icon The icon to show while loading. Default: 'ion-load-d'.  This is depreicated\n * in favor of the SVG {@link ionic.directive:ionSpinner}.\n * @param {boolean=} immediate-check Whether to check the infinite scroll bounds immediately on load.\n *\n * @usage\n * ```html\n * <ion-content ng-controller=\"MyController\">\n *   <ion-list>\n *   ....\n *   ....\n *   </ion-list>\n *\n *   <ion-infinite-scroll\n *     on-infinite=\"loadMore()\"\n *     distance=\"1%\">\n *   </ion-infinite-scroll>\n * </ion-content>\n * ```\n * ```js\n * function MyController($scope, $http) {\n *   $scope.items = [];\n *   $scope.loadMore = function() {\n *     $http.get('/more-items').success(function(items) {\n *       useItems(items);\n *       $scope.$broadcast('scroll.infiniteScrollComplete');\n *     });\n *   };\n *\n *   $scope.$on('$stateChangeSuccess', function() {\n *     $scope.loadMore();\n *   });\n * }\n * ```\n *\n * An easy to way to stop infinite scroll once there is no more data to load\n * is to use angular's `ng-if` directive:\n *\n * ```html\n * <ion-infinite-scroll\n *   ng-if=\"moreDataCanBeLoaded()\"\n *   icon=\"ion-loading-c\"\n *   on-infinite=\"loadMoreData()\">\n * </ion-infinite-scroll>\n * ```\n */\nIonicModule\n.directive('ionInfiniteScroll', ['$timeout', function($timeout) {\n  return {\n    restrict: 'E',\n    require: ['?^$ionicScroll', 'ionInfiniteScroll'],\n    template: function($element, $attrs) {\n      if ($attrs.icon) return '<i class=\"icon {{icon()}} icon-refreshing {{scrollingType}}\"></i>';\n      return '<ion-spinner icon=\"{{spinner()}}\"></ion-spinner>';\n    },\n    scope: true,\n    controller: '$ionInfiniteScroll',\n    link: function($scope, $element, $attrs, ctrls) {\n      var infiniteScrollCtrl = ctrls[1];\n      var scrollCtrl = infiniteScrollCtrl.scrollCtrl = ctrls[0];\n      var jsScrolling = infiniteScrollCtrl.jsScrolling = !scrollCtrl.isNative();\n\n      // if this view is not beneath a scrollCtrl, it can't be injected, proceed w/ native scrolling\n      if (jsScrolling) {\n        infiniteScrollCtrl.scrollView = scrollCtrl.scrollView;\n        $scope.scrollingType = 'js-scrolling';\n        //bind to JS scroll events\n        scrollCtrl.$element.on('scroll', infiniteScrollCtrl.checkBounds);\n      } else {\n        // grabbing the scrollable element, to determine dimensions, and current scroll pos\n        var scrollEl = ionic.DomUtil.getParentOrSelfWithClass($element[0].parentNode, 'overflow-scroll');\n        infiniteScrollCtrl.scrollEl = scrollEl;\n        // if there's no scroll controller, and no overflow scroll div, infinite scroll wont work\n        if (!scrollEl) {\n          throw 'Infinite scroll must be used inside a scrollable div';\n        }\n        //bind to native scroll events\n        infiniteScrollCtrl.scrollEl.addEventListener('scroll', infiniteScrollCtrl.checkBounds);\n      }\n\n      // Optionally check bounds on start after scrollView is fully rendered\n      var doImmediateCheck = isDefined($attrs.immediateCheck) ? $scope.$eval($attrs.immediateCheck) : true;\n      if (doImmediateCheck) {\n        $timeout(function() { infiniteScrollCtrl.checkBounds(); });\n      }\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/infiniteScroll.js\n ** module id = 49\n ** module chunks = 0\n **/","/**\r\n* @ngdoc directive\r\n* @name ionInput\r\n* @parent ionic.directive:ionList\r\n* @module ionic\r\n* @restrict E\r\n* Creates a text input group that can easily be focused\r\n*\r\n* @usage\r\n*\r\n* ```html\r\n* <ion-list>\r\n*   <ion-input>\r\n*     <input type=\"text\" placeholder=\"First Name\">\r\n*   <ion-input>\r\n*\r\n*   <ion-input>\r\n*     <ion-label>Username</ion-label>\r\n*     <input type=\"text\">\r\n*   </ion-input>\r\n* </ion-list>\r\n* ```\r\n*/\r\n\r\nvar labelIds = -1;\r\n\r\nIonicModule\r\n.directive('ionInput', [function() {\r\n  return {\r\n    restrict: 'E',\r\n    controller: ['$scope', '$element', function($scope, $element) {\r\n      this.$scope = $scope;\r\n      this.$element = $element;\r\n\r\n      this.setInputAriaLabeledBy = function(id) {\r\n        var inputs = $element[0].querySelectorAll('input,textarea');\r\n        inputs.length && inputs[0].setAttribute('aria-labelledby', id);\r\n      };\r\n\r\n      this.focus = function() {\r\n        var inputs = $element[0].querySelectorAll('input,textarea');\r\n        inputs.length && inputs[0].focus();\r\n      };\r\n    }]\r\n  };\r\n}]);\r\n\r\n/**\r\n* @ngdoc directive\r\n* @name ionLabel\r\n* @parent ionic.directive:ionList\r\n* @module ionic\r\n* @restrict E\r\n*\r\n* New in Ionic 1.2. It is strongly recommended that you use `<ion-label>` in place\r\n* of any `<label>` elements for maximum cross-browser support and performance.\r\n*\r\n* Creates a label for a form input.\r\n*\r\n* @usage\r\n*\r\n* ```html\r\n* <ion-list>\r\n*   <ion-input>\r\n*     <ion-label>Username</ion-label>\r\n*     <input type=\"text\">\r\n*   </ion-input>\r\n* </ion-list>\r\n* ```\r\n*/\r\nIonicModule\r\n.directive('ionLabel', [function() {\r\n  return {\r\n    restrict: 'E',\r\n    require: '?^ionInput',\r\n    compile: function() {\r\n\r\n      return function link($scope, $element, $attrs, ionInputCtrl) {\r\n        var element = $element[0];\r\n\r\n        $element.addClass('input-label');\r\n\r\n        $element.attr('aria-label', $element.text());\r\n        var id = element.id || '_label-' + ++labelIds;\r\n\r\n        if (!element.id) {\r\n          $element.attr('id', id);\r\n        }\r\n\r\n        if (ionInputCtrl) {\r\n\r\n          ionInputCtrl.setInputAriaLabeledBy(id);\r\n\r\n          $element.on('click', function() {\r\n            ionInputCtrl.focus();\r\n          });\r\n        }\r\n      };\r\n    }\r\n  };\r\n}]);\r\n\r\n/**\r\n * Input label adds accessibility to <span class=\"input-label\">.\r\n */\r\nIonicModule\r\n.directive('inputLabel', [function() {\r\n  return {\r\n    restrict: 'C',\r\n    require: '?^ionInput',\r\n    compile: function() {\r\n\r\n      return function link($scope, $element, $attrs, ionInputCtrl) {\r\n        var element = $element[0];\r\n\r\n        $element.attr('aria-label', $element.text());\r\n        var id = element.id || '_label-' + ++labelIds;\r\n\r\n        if (!element.id) {\r\n          $element.attr('id', id);\r\n        }\r\n\r\n        if (ionInputCtrl) {\r\n          ionInputCtrl.setInputAriaLabeledBy(id);\r\n        }\r\n\r\n      };\r\n    }\r\n  };\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/input.js\n ** module id = 50\n ** module chunks = 0\n **/","var ITEM_TPL_DELETE_BUTTON =\n  '<div class=\"item-left-edit item-delete enable-pointer-events\">' +\n  '</div>';\n/**\n* @ngdoc directive\n* @name ionDeleteButton\n* @parent ionic.directive:ionItem\n* @module ionic\n* @restrict E\n* Creates a delete button inside a list item, that is visible when the\n* {@link ionic.directive:ionList ionList parent's} `show-delete` evaluates to true or\n* `$ionicListDelegate.showDelete(true)` is called.\n*\n* Takes any ionicon as a class.\n*\n* See {@link ionic.directive:ionList} for a complete example & explanation.\n*\n* @usage\n*\n* ```html\n* <ion-list show-delete=\"shouldShowDelete\">\n*   <ion-item>\n*     <ion-delete-button class=\"ion-minus-circled\"></ion-delete-button>\n*     Hello, list item!\n*   </ion-item>\n* </ion-list>\n* <ion-toggle ng-model=\"shouldShowDelete\">\n*   Show Delete?\n* </ion-toggle>\n* ```\n*/\nIonicModule\n.directive('ionDeleteButton', function() {\n\n  function stopPropagation(ev) {\n    ev.stopPropagation();\n  }\n\n  return {\n    restrict: 'E',\n    require: ['^^ionItem', '^?ionList'],\n    //Run before anything else, so we can move it before other directives process\n    //its location (eg ngIf relies on the location of the directive in the dom)\n    priority: Number.MAX_VALUE,\n    compile: function($element, $attr) {\n      //Add the classes we need during the compile phase, so that they stay\n      //even if something else like ngIf removes the element and re-addss it\n      $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);\n      return function($scope, $element, $attr, ctrls) {\n        var itemCtrl = ctrls[0];\n        var listCtrl = ctrls[1];\n        var container = jqLite(ITEM_TPL_DELETE_BUTTON);\n        container.append($element);\n        itemCtrl.$element.append(container).addClass('item-left-editable');\n\n        //Don't bubble click up to main .item\n        $element.on('click', stopPropagation);\n\n        init();\n        $scope.$on('$ionic.reconnectScope', init);\n        function init() {\n          listCtrl = listCtrl || $element.controller('ionList');\n          if (listCtrl && listCtrl.showDelete()) {\n            container.addClass('visible active');\n          }\n        }\n      };\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/itemDeleteButton.js\n ** module id = 51\n ** module chunks = 0\n **/","\nIonicModule\n.directive('itemFloatingLabel', function() {\n  return {\n    restrict: 'C',\n    link: function(scope, element) {\n      var el = element[0];\n      var input = el.querySelector('input, textarea');\n      var inputLabel = el.querySelector('.input-label');\n\n      if (!input || !inputLabel) return;\n\n      var onInput = function() {\n        if (input.value) {\n          inputLabel.classList.add('has-input');\n        } else {\n          inputLabel.classList.remove('has-input');\n        }\n      };\n\n      input.addEventListener('input', onInput);\n\n      var ngModelCtrl = jqLite(input).controller('ngModel');\n      if (ngModelCtrl) {\n        ngModelCtrl.$render = function() {\n          input.value = ngModelCtrl.$viewValue || '';\n          onInput();\n        };\n      }\n\n      scope.$on('$destroy', function() {\n        input.removeEventListener('input', onInput);\n      });\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/itemFloatingLabel.js\n ** module id = 52\n ** module chunks = 0\n **/","/**\n* @ngdoc directive\n* @name ionItem\n* @parent ionic.directive:ionList\n* @module ionic\n* @restrict E\n* Creates a list-item that can easily be swiped,\n* deleted, reordered, edited, and more.\n*\n* See {@link ionic.directive:ionList} for a complete example & explanation.\n*\n* Can be assigned any item class name. See the\n* [list CSS documentation](/docs/components/#list).\n*\n* @usage\n*\n* ```html\n* <ion-list>\n*   <ion-item>Hello!</ion-item>\n*   <ion-item href=\"#/detail\">\n*     Link to detail page\n*   </ion-item>\n* </ion-list>\n* ```\n*/\nIonicModule\n.directive('ionItem', ['$$rAF', function($$rAF) {\n  return {\n    restrict: 'E',\n    controller: ['$scope', '$element', function($scope, $element) {\n      this.$scope = $scope;\n      this.$element = $element;\n    }],\n    scope: true,\n    compile: function($element, $attrs) {\n      var isAnchor = isDefined($attrs.href) ||\n                     isDefined($attrs.ngHref) ||\n                     isDefined($attrs.uiSref);\n      var isComplexItem = isAnchor ||\n        //Lame way of testing, but we have to know at compile what to do with the element\n        /ion-(delete|option|reorder)-button/i.test($element.html());\n\n      if (isComplexItem) {\n        var innerElement = jqLite(isAnchor ? '<a></a>' : '<div></div>');\n        innerElement.addClass('item-content');\n\n        if (isDefined($attrs.href) || isDefined($attrs.ngHref)) {\n          innerElement.attr('ng-href', '{{$href()}}');\n          if (isDefined($attrs.target)) {\n            innerElement.attr('target', '{{$target()}}');\n          }\n        }\n\n        innerElement.append($element.contents());\n\n        $element.addClass('item item-complex')\n                .append(innerElement);\n      } else {\n        $element.addClass('item');\n      }\n\n      return function link($scope, $element, $attrs) {\n        $scope.$href = function() {\n          return $attrs.href || $attrs.ngHref;\n        };\n        $scope.$target = function() {\n          return $attrs.target;\n        };\n\n        var content = $element[0].querySelector('.item-content');\n        if (content) {\n          $scope.$on('$collectionRepeatLeave', function() {\n            if (content && content.$$ionicOptionsOpen) {\n              content.style[ionic.CSS.TRANSFORM] = '';\n              content.style[ionic.CSS.TRANSITION] = 'none';\n              $$rAF(function() {\n                content.style[ionic.CSS.TRANSITION] = '';\n              });\n              content.$$ionicOptionsOpen = false;\n            }\n          });\n        }\n      };\n\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/item.js\n ** module id = 53\n ** module chunks = 0\n **/","var ITEM_TPL_OPTION_BUTTONS =\n  '<div class=\"item-options invisible\">' +\n  '</div>';\n/**\n* @ngdoc directive\n* @name ionOptionButton\n* @parent ionic.directive:ionItem\n* @module ionic\n* @restrict E\n* @description\n* Creates an option button inside a list item, that is visible when the item is swiped\n* to the left by the user.  Swiped open option buttons can be hidden with\n* {@link ionic.service:$ionicListDelegate#closeOptionButtons $ionicListDelegate.closeOptionButtons}.\n*\n* Can be assigned any button class.\n*\n* See {@link ionic.directive:ionList} for a complete example & explanation.\n*\n* @usage\n*\n* ```html\n* <ion-list>\n*   <ion-item>\n*     I love kittens!\n*     <ion-option-button class=\"button-positive\">Share</ion-option-button>\n*     <ion-option-button class=\"button-assertive\">Edit</ion-option-button>\n*   </ion-item>\n* </ion-list>\n* ```\n*/\nIonicModule.directive('ionOptionButton', [function() {\n  function stopPropagation(e) {\n    e.stopPropagation();\n  }\n  return {\n    restrict: 'E',\n    require: '^ionItem',\n    priority: Number.MAX_VALUE,\n    compile: function($element, $attr) {\n      $attr.$set('class', ($attr['class'] || '') + ' button', true);\n      return function($scope, $element, $attr, itemCtrl) {\n        if (!itemCtrl.optionsContainer) {\n          itemCtrl.optionsContainer = jqLite(ITEM_TPL_OPTION_BUTTONS);\n          itemCtrl.$element.append(itemCtrl.optionsContainer);\n        }\n        itemCtrl.optionsContainer.append($element);\n\n        itemCtrl.$element.addClass('item-right-editable');\n\n        //Don't bubble click up to main .item\n        $element.on('click', stopPropagation);\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/itemOptionButton.js\n ** module id = 54\n ** module chunks = 0\n **/","var ITEM_TPL_REORDER_BUTTON =\n  '<div data-prevent-scroll=\"true\" class=\"item-right-edit item-reorder enable-pointer-events\">' +\n  '</div>';\n\n/**\n* @ngdoc directive\n* @name ionReorderButton\n* @parent ionic.directive:ionItem\n* @module ionic\n* @restrict E\n* Creates a reorder button inside a list item, that is visible when the\n* {@link ionic.directive:ionList ionList parent's} `show-reorder` evaluates to true or\n* `$ionicListDelegate.showReorder(true)` is called.\n*\n* Can be dragged to reorder items in the list. Takes any ionicon class.\n*\n* Note: Reordering works best when used with `ng-repeat`.  Be sure that all `ion-item` children of an `ion-list` are part of the same `ng-repeat` expression.\n*\n* When an item reorder is complete, the expression given in the `on-reorder` attribute is called. The `on-reorder` expression is given two locals that can be used: `$fromIndex` and `$toIndex`.  See below for an example.\n*\n* Look at {@link ionic.directive:ionList} for more examples.\n*\n* @usage\n*\n* ```html\n* <ion-list ng-controller=\"MyCtrl\" show-reorder=\"true\">\n*   <ion-item ng-repeat=\"item in items\">\n*     Item {{item}}\n*     <ion-reorder-button class=\"ion-navicon\"\n*                         on-reorder=\"moveItem(item, $fromIndex, $toIndex)\">\n*     </ion-reorder-button>\n*   </ion-item>\n* </ion-list>\n* ```\n* ```js\n* function MyCtrl($scope) {\n*   $scope.items = [1, 2, 3, 4];\n*   $scope.moveItem = function(item, fromIndex, toIndex) {\n*     //Move the item in the array\n*     $scope.items.splice(fromIndex, 1);\n*     $scope.items.splice(toIndex, 0, item);\n*   };\n* }\n* ```\n*\n* @param {expression=} on-reorder Expression to call when an item is reordered.\n* Parameters given: $fromIndex, $toIndex.\n*/\nIonicModule\n.directive('ionReorderButton', ['$parse', function($parse) {\n  return {\n    restrict: 'E',\n    require: ['^ionItem', '^?ionList'],\n    priority: Number.MAX_VALUE,\n    compile: function($element, $attr) {\n      $attr.$set('class', ($attr['class'] || '') + ' button icon button-icon', true);\n      $element[0].setAttribute('data-prevent-scroll', true);\n      return function($scope, $element, $attr, ctrls) {\n        var itemCtrl = ctrls[0];\n        var listCtrl = ctrls[1];\n        var onReorderFn = $parse($attr.onReorder);\n\n        $scope.$onReorder = function(oldIndex, newIndex) {\n          onReorderFn($scope, {\n            $fromIndex: oldIndex,\n            $toIndex: newIndex\n          });\n        };\n\n        // prevent clicks from bubbling up to the item\n        if (!$attr.ngClick && !$attr.onClick && !$attr.onclick) {\n          $element[0].onclick = function(e) {\n            e.stopPropagation();\n            return false;\n          };\n        }\n\n        var container = jqLite(ITEM_TPL_REORDER_BUTTON);\n        container.append($element);\n        itemCtrl.$element.append(container).addClass('item-right-editable');\n\n        if (listCtrl && listCtrl.showReorder()) {\n          container.addClass('visible active');\n        }\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/itemReorderButton.js\n ** module id = 55\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name keyboardAttach\n * @module ionic\n * @restrict A\n *\n * @description\n * keyboard-attach is an attribute directive which will cause an element to float above\n * the keyboard when the keyboard shows. Currently only supports the\n * [ion-footer-bar]({{ page.versionHref }}/api/directive/ionFooterBar/) directive.\n *\n * ### Notes\n * - This directive requires the\n * [Ionic Keyboard Plugin](https://github.com/driftyco/ionic-plugins-keyboard).\n * - On Android not in fullscreen mode, i.e. you have\n *   `<preference name=\"Fullscreen\" value=\"false\" />` or no preference in your `config.xml` file,\n *   this directive is unnecessary since it is the default behavior.\n * - On iOS, if there is an input in your footer, you will need to set\n *   `cordova.plugins.Keyboard.disableScroll(true)`.\n *\n * @usage\n *\n * ```html\n *  <ion-footer-bar align-title=\"left\" keyboard-attach class=\"bar-assertive\">\n *    <h1 class=\"title\">Title!</h1>\n *  </ion-footer-bar>\n * ```\n */\n\nIonicModule\n.directive('keyboardAttach', function() {\n  return function(scope, element) {\n    ionic.on('native.keyboardshow', onShow, window);\n    ionic.on('native.keyboardhide', onHide, window);\n\n    //deprecated\n    ionic.on('native.showkeyboard', onShow, window);\n    ionic.on('native.hidekeyboard', onHide, window);\n\n\n    var scrollCtrl;\n\n    function onShow(e) {\n      if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {\n        return;\n      }\n\n      //for testing\n      var keyboardHeight = e.keyboardHeight || (e.detail && e.detail.keyboardHeight);\n      element.css('bottom', keyboardHeight + \"px\");\n      scrollCtrl = element.controller('$ionicScroll');\n      if (scrollCtrl) {\n        scrollCtrl.scrollView.__container.style.bottom = keyboardHeight + keyboardAttachGetClientHeight(element[0]) + \"px\";\n      }\n    }\n\n    function onHide() {\n      if (ionic.Platform.isAndroid() && !ionic.Platform.isFullScreen) {\n        return;\n      }\n\n      element.css('bottom', '');\n      if (scrollCtrl) {\n        scrollCtrl.scrollView.__container.style.bottom = '';\n      }\n    }\n\n    scope.$on('$destroy', function() {\n      ionic.off('native.keyboardshow', onShow, window);\n      ionic.off('native.keyboardhide', onHide, window);\n\n      //deprecated\n      ionic.off('native.showkeyboard', onShow, window);\n      ionic.off('native.hidekeyboard', onHide, window);\n    });\n  };\n});\n\nfunction keyboardAttachGetClientHeight(element) {\n  return element.clientHeight;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/keyboardAttach.js\n ** module id = 56\n ** module chunks = 0\n **/","/**\n* @ngdoc directive\n* @name ionList\n* @module ionic\n* @delegate ionic.service:$ionicListDelegate\n* @codepen JsHjf\n* @restrict E\n* @description\n* The List is a widely used interface element in almost any mobile app, and can include\n* content ranging from basic text all the way to buttons, toggles, icons, and thumbnails.\n*\n* Both the list, which contains items, and the list items themselves can be any HTML\n* element. The containing element requires the `list` class and each list item requires\n* the `item` class.\n*\n* However, using the ionList and ionItem directives make it easy to support various\n* interaction modes such as swipe to edit, drag to reorder, and removing items.\n*\n* Related: {@link ionic.directive:ionItem}, {@link ionic.directive:ionOptionButton}\n* {@link ionic.directive:ionReorderButton}, {@link ionic.directive:ionDeleteButton}, [`list CSS documentation`](/docs/components/#list).\n*\n* @usage\n*\n* Basic Usage:\n*\n* ```html\n* <ion-list>\n*   <ion-item ng-repeat=\"item in items\">\n*     {% raw %}Hello, {{item}}!{% endraw %}\n*   </ion-item>\n* </ion-list>\n* ```\n*\n* Advanced Usage: Thumbnails, Delete buttons, Reordering, Swiping\n*\n* ```html\n* <ion-list ng-controller=\"MyCtrl\"\n*           show-delete=\"shouldShowDelete\"\n*           show-reorder=\"shouldShowReorder\"\n*           can-swipe=\"listCanSwipe\">\n*   <ion-item ng-repeat=\"item in items\"\n*             class=\"item-thumbnail-left\">\n*\n*     {% raw %}<img ng-src=\"{{item.img}}\">\n*     <h2>{{item.title}}</h2>\n*     <p>{{item.description}}</p>{% endraw %}\n*     <ion-option-button class=\"button-positive\"\n*                        ng-click=\"share(item)\">\n*       Share\n*     </ion-option-button>\n*     <ion-option-button class=\"button-info\"\n*                        ng-click=\"edit(item)\">\n*       Edit\n*     </ion-option-button>\n*     <ion-delete-button class=\"ion-minus-circled\"\n*                        ng-click=\"items.splice($index, 1)\">\n*     </ion-delete-button>\n*     <ion-reorder-button class=\"ion-navicon\"\n*                         on-reorder=\"reorderItem(item, $fromIndex, $toIndex)\">\n*     </ion-reorder-button>\n*\n*   </ion-item>\n* </ion-list>\n* ```\n*\n*```javascript\n* app.controller('MyCtrl', function($scope) {\n*  $scope.shouldShowDelete = false;\n*  $scope.shouldShowReorder = false;\n*  $scope.listCanSwipe = true\n* });\n*```\n*\n* @param {string=} delegate-handle The handle used to identify this list with\n* {@link ionic.service:$ionicListDelegate}.\n* @param type {string=} The type of list to use (list-inset or card)\n* @param show-delete {boolean=} Whether the delete buttons for the items in the list are\n* currently shown or hidden.\n* @param show-reorder {boolean=} Whether the reorder buttons for the items in the list are\n* currently shown or hidden.\n* @param can-swipe {boolean=} Whether the items in the list are allowed to be swiped to reveal\n* option buttons. Default: true.\n*/\nIonicModule\n.directive('ionList', [\n  '$timeout',\nfunction($timeout) {\n  return {\n    restrict: 'E',\n    require: ['ionList', '^?$ionicScroll'],\n    controller: '$ionicList',\n    compile: function($element, $attr) {\n      var listEl = jqLite('<div class=\"list\">')\n        .append($element.contents())\n        .addClass($attr.type);\n\n      $element.append(listEl);\n\n      return function($scope, $element, $attrs, ctrls) {\n        var listCtrl = ctrls[0];\n        var scrollCtrl = ctrls[1];\n\n        // Wait for child elements to render...\n        $timeout(init);\n\n        function init() {\n          var listView = listCtrl.listView = new ionic.views.ListView({\n            el: $element[0],\n            listEl: $element.children()[0],\n            scrollEl: scrollCtrl && scrollCtrl.element,\n            scrollView: scrollCtrl && scrollCtrl.scrollView,\n            onReorder: function(el, oldIndex, newIndex) {\n              var itemScope = jqLite(el).scope();\n              if (itemScope && itemScope.$onReorder) {\n                // Make sure onReorder is called in apply cycle,\n                // but also make sure it has no conflicts by doing\n                // $evalAsync\n                $timeout(function() {\n                  itemScope.$onReorder(oldIndex, newIndex);\n                });\n              }\n            },\n            canSwipe: function() {\n              return listCtrl.canSwipeItems();\n            }\n          });\n\n          $scope.$on('$destroy', function() {\n            if (listView) {\n              listView.deregister && listView.deregister();\n              listView = null;\n            }\n          });\n\n          if (isDefined($attr.canSwipe)) {\n            $scope.$watch('!!(' + $attr.canSwipe + ')', function(value) {\n              listCtrl.canSwipeItems(value);\n            });\n          }\n          if (isDefined($attr.showDelete)) {\n            $scope.$watch('!!(' + $attr.showDelete + ')', function(value) {\n              listCtrl.showDelete(value);\n            });\n          }\n          if (isDefined($attr.showReorder)) {\n            $scope.$watch('!!(' + $attr.showReorder + ')', function(value) {\n              listCtrl.showReorder(value);\n            });\n          }\n\n          $scope.$watch(function() {\n            return listCtrl.showDelete();\n          }, function(isShown, wasShown) {\n            //Only use isShown=false if it was already shown\n            if (!isShown && !wasShown) { return; }\n\n            if (isShown) listCtrl.closeOptionButtons();\n            listCtrl.canSwipeItems(!isShown);\n\n            $element.children().toggleClass('list-left-editing', isShown);\n            $element.toggleClass('disable-pointer-events', isShown);\n\n            var deleteButton = jqLite($element[0].getElementsByClassName('item-delete'));\n            setButtonShown(deleteButton, listCtrl.showDelete);\n          });\n\n          $scope.$watch(function() {\n            return listCtrl.showReorder();\n          }, function(isShown, wasShown) {\n            //Only use isShown=false if it was already shown\n            if (!isShown && !wasShown) { return; }\n\n            if (isShown) listCtrl.closeOptionButtons();\n            listCtrl.canSwipeItems(!isShown);\n\n            $element.children().toggleClass('list-right-editing', isShown);\n            $element.toggleClass('disable-pointer-events', isShown);\n\n            var reorderButton = jqLite($element[0].getElementsByClassName('item-reorder'));\n            setButtonShown(reorderButton, listCtrl.showReorder);\n          });\n\n          function setButtonShown(el, shown) {\n            shown() && el.addClass('visible') || el.removeClass('active');\n            ionic.requestAnimationFrame(function() {\n              shown() && el.addClass('active') || el.removeClass('visible');\n            });\n          }\n        }\n\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/list.js\n ** module id = 57\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name menuClose\n * @module ionic\n * @restrict AC\n *\n * @description\n * `menu-close` is an attribute directive that closes a currently opened side menu.\n * Note that by default, navigation transitions will not animate between views when\n * the menu is open. Additionally, this directive will reset the entering view's\n * history stack, making the new page the root of the history stack. This is done\n * to replicate the user experience seen in most side menu implementations, which is\n * to not show the back button at the root of the stack and show only the\n * menu button. We recommend that you also use the `enable-menu-with-back-views=\"false\"`\n * {@link ionic.directive:ionSideMenus} attribute when using the menuClose directive.\n *\n * @usage\n * Below is an example of a link within a side menu. Tapping this link would\n * automatically close the currently opened menu.\n *\n * ```html\n * <a menu-close href=\"#/home\" class=\"item\">Home</a>\n * ```\n *\n * Note that if your destination state uses a resolve and that resolve asynchronously\n * takes longer than a standard transition (300ms), you'll need to set the\n * `nextViewOptions` manually as your resolve completes.\n *\n * ```js\n * $ionicHistory.nextViewOptions({\n *  historyRoot: true,\n *  disableAnimate: true,\n *  expire: 300\n * });\n * ```\n */\nIonicModule\n.directive('menuClose', ['$ionicHistory', '$timeout', function($ionicHistory, $timeout) {\n  return {\n    restrict: 'AC',\n    link: function($scope, $element) {\n      $element.bind('click', function() {\n        var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');\n        if (sideMenuCtrl) {\n          $ionicHistory.nextViewOptions({\n            historyRoot: true,\n            disableAnimate: true,\n            expire: 300\n          });\n          // if no transition in 300ms, reset nextViewOptions\n          // the expire should take care of it, but will be cancelled in some\n          // cases. This directive is an exception to the rules of history.js\n          $timeout( function() {\n            $ionicHistory.nextViewOptions({\n              historyRoot: false,\n              disableAnimate: false\n            });\n          }, 300);\n          sideMenuCtrl.close();\n        }\n      });\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/menuClose.js\n ** module id = 58\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name menuToggle\n * @module ionic\n * @restrict AC\n *\n * @description\n * Toggle a side menu on the given side.\n *\n * @usage\n * Below is an example of a link within a nav bar. Tapping this button\n * would open the given side menu, and tapping it again would close it.\n *\n * ```html\n * <ion-nav-bar>\n *   <ion-nav-buttons side=\"left\">\n *    <!-- Toggle left side menu -->\n *    <button menu-toggle=\"left\" class=\"button button-icon icon ion-navicon\"></button>\n *   </ion-nav-buttons>\n *   <ion-nav-buttons side=\"right\">\n *    <!-- Toggle right side menu -->\n *    <button menu-toggle=\"right\" class=\"button button-icon icon ion-navicon\"></button>\n *   </ion-nav-buttons>\n * </ion-nav-bar>\n * ```\n *\n * ### Button Hidden On Child Views\n * By default, the menu toggle button will only appear on a root\n * level side-menu page. Navigating in to child views will hide the menu-\n * toggle button. They can be made visible on child pages by setting the\n * enable-menu-with-back-views attribute of the {@link ionic.directive:ionSideMenus}\n * directive to true.\n *\n * ```html\n * <ion-side-menus enable-menu-with-back-views=\"true\">\n * ```\n */\nIonicModule\n.directive('menuToggle', function() {\n  return {\n    restrict: 'AC',\n    link: function($scope, $element, $attr) {\n      $scope.$on('$ionicView.beforeEnter', function(ev, viewData) {\n        if (viewData.enableBack) {\n          var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');\n          if (!sideMenuCtrl.enableMenuWithBackViews()) {\n            $element.addClass('hide');\n          }\n        } else {\n          $element.removeClass('hide');\n        }\n      });\n\n      $element.bind('click', function() {\n        var sideMenuCtrl = $element.inheritedData('$ionSideMenusController');\n        sideMenuCtrl && sideMenuCtrl.toggle($attr.menuToggle);\n      });\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/menuToggle.js\n ** module id = 59\n ** module chunks = 0\n **/","/*\n * We don't document the ionModal directive, we instead document\n * the $ionicModal service\n */\nIonicModule\n.directive('ionModal', [function() {\n  return {\n    restrict: 'E',\n    transclude: true,\n    replace: true,\n    controller: [function() {}],\n    template: '<div class=\"modal-backdrop\">' +\n                '<div class=\"modal-backdrop-bg\"></div>' +\n                '<div class=\"modal-wrapper\" ng-transclude></div>' +\n              '</div>'\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/modal.js\n ** module id = 60\n ** module chunks = 0\n **/","IonicModule\n.directive('ionModalView', function() {\n  return {\n    restrict: 'E',\n    compile: function(element) {\n      element.addClass('modal');\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/modalView.js\n ** module id = 61\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionNavBackButton\n * @module ionic\n * @restrict E\n * @parent ionNavBar\n * @description\n * Creates a back button inside an {@link ionic.directive:ionNavBar}.\n *\n * The back button will appear when the user is able to go back in the current navigation stack. By\n * default, the markup of the back button is automatically built using platform-appropriate defaults\n * (iOS back button icon on iOS and Android icon on Android).\n *\n * Additionally, the button is automatically set to `$ionicGoBack()` on click/tap. By default, the\n * app will navigate back one view when the back button is clicked.  More advanced behavior is also\n * possible, as outlined below.\n *\n * @usage\n *\n * Recommended markup for default settings:\n *\n * ```html\n * <ion-nav-bar>\n *   <ion-nav-back-button>\n *   </ion-nav-back-button>\n * </ion-nav-bar>\n * ```\n *\n * With custom inner markup, and automatically adds a default click action:\n *\n * ```html\n * <ion-nav-bar>\n *   <ion-nav-back-button class=\"button-clear\">\n *     <i class=\"ion-arrow-left-c\"></i> Back\n *   </ion-nav-back-button>\n * </ion-nav-bar>\n * ```\n *\n * With custom inner markup and custom click action, using {@link ionic.service:$ionicHistory}:\n *\n * ```html\n * <ion-nav-bar ng-controller=\"MyCtrl\">\n *   <ion-nav-back-button class=\"button-clear\"\n *     ng-click=\"myGoBack()\">\n *     <i class=\"ion-arrow-left-c\"></i> Back\n *   </ion-nav-back-button>\n * </ion-nav-bar>\n * ```\n * ```js\n * function MyCtrl($scope, $ionicHistory) {\n *   $scope.myGoBack = function() {\n *     $ionicHistory.goBack();\n *   };\n * }\n * ```\n */\nIonicModule\n.directive('ionNavBackButton', ['$ionicConfig', '$document', function($ionicConfig, $document) {\n  return {\n    restrict: 'E',\n    require: '^ionNavBar',\n    compile: function(tElement, tAttrs) {\n\n      // clone the back button, but as a <div>\n      var buttonEle = $document[0].createElement('button');\n      for (var n in tAttrs.$attr) {\n        buttonEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);\n      }\n\n      if (!tAttrs.ngClick) {\n        buttonEle.setAttribute('ng-click', '$ionicGoBack()');\n      }\n\n      buttonEle.className = 'button back-button hide buttons ' + (tElement.attr('class') || '');\n      buttonEle.innerHTML = tElement.html() || '';\n\n      var childNode;\n      var hasIcon = hasIconClass(tElement[0]);\n      var hasInnerText;\n      var hasButtonText;\n      var hasPreviousTitle;\n\n      for (var x = 0; x < tElement[0].childNodes.length; x++) {\n        childNode = tElement[0].childNodes[x];\n        if (childNode.nodeType === 1) {\n          if (hasIconClass(childNode)) {\n            hasIcon = true;\n          } else if (childNode.classList.contains('default-title')) {\n            hasButtonText = true;\n          } else if (childNode.classList.contains('previous-title')) {\n            hasPreviousTitle = true;\n          }\n        } else if (!hasInnerText && childNode.nodeType === 3) {\n          hasInnerText = !!childNode.nodeValue.trim();\n        }\n      }\n\n      function hasIconClass(ele) {\n        return /ion-|icon/.test(ele.className);\n      }\n\n      var defaultIcon = $ionicConfig.backButton.icon();\n      if (!hasIcon && defaultIcon && defaultIcon !== 'none') {\n        buttonEle.innerHTML = '<i class=\"icon ' + defaultIcon + '\"></i> ' + buttonEle.innerHTML;\n        buttonEle.className += ' button-clear';\n      }\n\n      if (!hasInnerText) {\n        var buttonTextEle = $document[0].createElement('span');\n        buttonTextEle.className = 'back-text';\n\n        if (!hasButtonText && $ionicConfig.backButton.text()) {\n          buttonTextEle.innerHTML += '<span class=\"default-title\">' + $ionicConfig.backButton.text() + '</span>';\n        }\n        if (!hasPreviousTitle && $ionicConfig.backButton.previousTitleText()) {\n          buttonTextEle.innerHTML += '<span class=\"previous-title\"></span>';\n        }\n        buttonEle.appendChild(buttonTextEle);\n\n      }\n\n      tElement.attr('class', 'hide');\n      tElement.empty();\n\n      return {\n        pre: function($scope, $element, $attr, navBarCtrl) {\n          // only register the plain HTML, the navBarCtrl takes care of scope/compile/link\n          navBarCtrl.navElement('backButton', buttonEle.outerHTML);\n          buttonEle = null;\n        }\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/navBackButton.js\n ** module id = 62\n ** module chunks = 0\n **/","\n/**\n * @ngdoc directive\n * @name ionNavBar\n * @module ionic\n * @delegate ionic.service:$ionicNavBarDelegate\n * @restrict E\n *\n * @description\n * If we have an {@link ionic.directive:ionNavView} directive, we can also create an\n * `<ion-nav-bar>`, which will create a topbar that updates as the application state changes.\n *\n * We can add a back button by putting an {@link ionic.directive:ionNavBackButton} inside.\n *\n * We can add buttons depending on the currently visible view using\n * {@link ionic.directive:ionNavButtons}.\n *\n * Note that the ion-nav-bar element will only work correctly if your content has an\n * ionView around it.\n *\n * @usage\n *\n * ```html\n * <body ng-app=\"starter\">\n *   <!-- The nav bar that will be updated as we navigate -->\n *   <ion-nav-bar class=\"bar-positive\">\n *   </ion-nav-bar>\n *\n *   <!-- where the initial view template will be rendered -->\n *   <ion-nav-view>\n *     <ion-view>\n *       <ion-content>Hello!</ion-content>\n *     </ion-view>\n *   </ion-nav-view>\n * </body>\n * ```\n *\n * @param {string=} delegate-handle The handle used to identify this navBar\n * with {@link ionic.service:$ionicNavBarDelegate}.\n * @param align-title {string=} Where to align the title of the navbar.\n * Available: 'left', 'right', 'center'. Defaults to 'center'.\n * @param {boolean=} no-tap-scroll By default, the navbar will scroll the content\n * to the top when tapped.  Set no-tap-scroll to true to disable this behavior.\n *\n * </table><br/>\n */\nIonicModule\n.directive('ionNavBar', function() {\n  return {\n    restrict: 'E',\n    controller: '$ionicNavBar',\n    scope: true,\n    link: function($scope, $element, $attr, ctrl) {\n      ctrl.init();\n    }\n  };\n});\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/navBar.js\n ** module id = 63\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionNavButtons\n * @module ionic\n * @restrict E\n * @parent ionNavView\n *\n * @description\n * Use nav buttons to set the buttons on your {@link ionic.directive:ionNavBar}\n * from within an {@link ionic.directive:ionView}. This gives each\n * view template the ability to specify which buttons should show in the nav bar,\n * overriding any default buttons already placed in the nav bar.\n *\n * Any buttons you declare will be positioned on the navbar's corresponding side. Primary\n * buttons generally map to the left side of the header, and secondary buttons are\n * generally on the right side. However, their exact locations are platform-specific.\n * For example, in iOS, the primary buttons are on the far left of the header, and\n * secondary buttons are on the far right, with the header title centered between them.\n * For Android, however, both groups of buttons are on the far right of the header,\n * with the header title aligned left.\n *\n * We recommend always using `primary` and `secondary`, so the buttons correctly map\n * to the side familiar to users of each platform. However, in cases where buttons should\n * always be on an exact side, both `left` and `right` sides are still available. For\n * example, a toggle button for a left side menu should be on the left side; in this case,\n * we'd recommend using `side=\"left\"`, so it's always on the left, no matter the platform.\n *\n * ***Note*** that `ion-nav-buttons` must be immediate descendants of the `ion-view` or\n * `ion-nav-bar` element (basically, don't wrap it in another div).\n *\n * @usage\n * ```html\n * <ion-nav-bar>\n * </ion-nav-bar>\n * <ion-nav-view>\n *   <ion-view>\n *     <ion-nav-buttons side=\"primary\">\n *       <button class=\"button\" ng-click=\"doSomething()\">\n *         I'm a button on the primary of the navbar!\n *       </button>\n *     </ion-nav-buttons>\n *     <ion-content>\n *       Some super content here!\n *     </ion-content>\n *   </ion-view>\n * </ion-nav-view>\n * ```\n *\n * @param {string} side The side to place the buttons in the\n * {@link ionic.directive:ionNavBar}. Available sides: `primary`, `secondary`, `left`, and `right`.\n */\nIonicModule\n.directive('ionNavButtons', ['$document', function($document) {\n  return {\n    require: '^ionNavBar',\n    restrict: 'E',\n    compile: function(tElement, tAttrs) {\n      var side = 'left';\n\n      if (/^primary|secondary|right$/i.test(tAttrs.side || '')) {\n        side = tAttrs.side.toLowerCase();\n      }\n\n      var spanEle = $document[0].createElement('span');\n      spanEle.className = side + '-buttons';\n      spanEle.innerHTML = tElement.html();\n\n      var navElementType = side + 'Buttons';\n\n      tElement.attr('class', 'hide');\n      tElement.empty();\n\n      return {\n        pre: function($scope, $element, $attrs, navBarCtrl) {\n          // only register the plain HTML, the navBarCtrl takes care of scope/compile/link\n\n          var parentViewCtrl = $element.parent().data('$ionViewController');\n          if (parentViewCtrl) {\n            // if the parent is an ion-view, then these are ion-nav-buttons for JUST this ion-view\n            parentViewCtrl.navElement(navElementType, spanEle.outerHTML);\n\n          } else {\n            // these are buttons for all views that do not have their own ion-nav-buttons\n            navBarCtrl.navElement(navElementType, spanEle.outerHTML);\n          }\n\n          spanEle = null;\n        }\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/navButtons.js\n ** module id = 64\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name navDirection\n * @module ionic\n * @restrict A\n *\n * @description\n * The direction which the nav view transition should animate. Available options\n * are: `forward`, `back`, `enter`, `exit`, `swap`.\n *\n * @usage\n *\n * ```html\n * <a nav-direction=\"forward\" href=\"#/home\">Home</a>\n * ```\n */\nIonicModule\n.directive('navDirection', ['$ionicViewSwitcher', function($ionicViewSwitcher) {\n  return {\n    restrict: 'A',\n    priority: 1000,\n    link: function($scope, $element, $attr) {\n      $element.bind('click', function() {\n        $ionicViewSwitcher.nextDirection($attr.navDirection);\n      });\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/navDirection.js\n ** module id = 65\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionNavTitle\n * @module ionic\n * @restrict E\n * @parent ionNavView\n *\n * @description\n *\n * The nav title directive replaces an {@link ionic.directive:ionNavBar} title text with\n * custom HTML from within an {@link ionic.directive:ionView} template. This gives each\n * view the ability to specify its own custom title element, such as an image or any HTML,\n * rather than being text-only. Alternatively, text-only titles can be updated using the\n * `view-title` {@link ionic.directive:ionView} attribute.\n *\n * Note that `ion-nav-title` must be an immediate descendant of the `ion-view` or\n * `ion-nav-bar` element (basically don't wrap it in another div).\n *\n * @usage\n * ```html\n * <ion-nav-bar>\n * </ion-nav-bar>\n * <ion-nav-view>\n *   <ion-view>\n *     <ion-nav-title>\n *       <img src=\"logo.svg\">\n *     </ion-nav-title>\n *     <ion-content>\n *       Some super content here!\n *     </ion-content>\n *   </ion-view>\n * </ion-nav-view>\n * ```\n *\n */\nIonicModule\n.directive('ionNavTitle', ['$document', function($document) {\n  return {\n    require: '^ionNavBar',\n    restrict: 'E',\n    compile: function(tElement, tAttrs) {\n      var navElementType = 'title';\n      var spanEle = $document[0].createElement('span');\n      for (var n in tAttrs.$attr) {\n        spanEle.setAttribute(tAttrs.$attr[n], tAttrs[n]);\n      }\n      spanEle.classList.add('nav-bar-title');\n      spanEle.innerHTML = tElement.html();\n\n      tElement.attr('class', 'hide');\n      tElement.empty();\n\n      return {\n        pre: function($scope, $element, $attrs, navBarCtrl) {\n          // only register the plain HTML, the navBarCtrl takes care of scope/compile/link\n\n          var parentViewCtrl = $element.parent().data('$ionViewController');\n          if (parentViewCtrl) {\n            // if the parent is an ion-view, then these are ion-nav-buttons for JUST this ion-view\n            parentViewCtrl.navElement(navElementType, spanEle.outerHTML);\n\n          } else {\n            // these are buttons for all views that do not have their own ion-nav-buttons\n            navBarCtrl.navElement(navElementType, spanEle.outerHTML);\n          }\n\n          spanEle = null;\n        }\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/navTitle.js\n ** module id = 66\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name navTransition\n * @module ionic\n * @restrict A\n *\n * @description\n * The transition type which the nav view transition should use when it animates.\n * Current, options are `ios`, `android`, and `none`. More options coming soon.\n *\n * @usage\n *\n * ```html\n * <a nav-transition=\"none\" href=\"#/home\">Home</a>\n * ```\n */\nIonicModule\n.directive('navTransition', ['$ionicViewSwitcher', function($ionicViewSwitcher) {\n  return {\n    restrict: 'A',\n    priority: 1000,\n    link: function($scope, $element, $attr) {\n      $element.bind('click', function() {\n        $ionicViewSwitcher.nextTransition($attr.navTransition);\n      });\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/navTransition.js\n ** module id = 67\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionNavView\n * @module ionic\n * @restrict E\n * @codepen odqCz\n *\n * @description\n * As a user navigates throughout your app, Ionic is able to keep track of their\n * navigation history. By knowing their history, transitions between views\n * correctly enter and exit using the platform's transition style. An additional\n * benefit to Ionic's navigation system is its ability to manage multiple\n * histories. For example, each tab can have it's own navigation history stack.\n *\n * Ionic uses the AngularUI Router module so app interfaces can be organized\n * into various \"states\". Like Angular's core $route service, URLs can be used\n * to control the views. However, the AngularUI Router provides a more powerful\n * state manager in that states are bound to named, nested, and parallel views,\n * allowing more than one template to be rendered on the same page.\n * Additionally, each state is not required to be bound to a URL, and data can\n * be pushed to each state which allows much flexibility.\n *\n * The ionNavView directive is used to render templates in your application. Each template\n * is part of a state. States are usually mapped to a url, and are defined programatically\n * using angular-ui-router (see [their docs](https://github.com/angular-ui/ui-router/wiki),\n * and remember to replace ui-view with ion-nav-view in examples).\n *\n * @usage\n * In this example, we will create a navigation view that contains our different states for the app.\n *\n * To do this, in our markup we use ionNavView top level directive. To display a header bar we use\n * the {@link ionic.directive:ionNavBar} directive that updates as we navigate through the\n * navigation stack.\n *\n * Next, we need to setup our states that will be rendered.\n *\n * ```js\n * var app = angular.module('myApp', ['ionic']);\n * app.config(function($stateProvider) {\n *   $stateProvider\n *   .state('index', {\n *     url: '/',\n *     templateUrl: 'home.html'\n *   })\n *   .state('music', {\n *     url: '/music',\n *     templateUrl: 'music.html'\n *   });\n * });\n * ```\n * Then on app start, $stateProvider will look at the url, see if it matches the index state,\n * and then try to load home.html into the `<ion-nav-view>`.\n *\n * Pages are loaded by the URLs given. One simple way to create templates in Angular is to put\n * them directly into your HTML file and use the `<script type=\"text/ng-template\">` syntax.\n * So here is one way to put home.html into our app:\n *\n * ```html\n * <script id=\"home\" type=\"text/ng-template\">\n *   <!-- The title of the ion-view will be shown on the navbar -->\n *   <ion-view view-title=\"Home\">\n *     <ion-content ng-controller=\"HomeCtrl\">\n *       <!-- The content of the page -->\n *       <a href=\"#/music\">Go to music page!</a>\n *     </ion-content>\n *   </ion-view>\n * </script>\n * ```\n *\n * This is good to do because the template will be cached for very fast loading, instead of\n * having to fetch them from the network.\n *\n * ## Caching\n *\n * By default, views are cached to improve performance. When a view is navigated away from, its\n * element is left in the DOM, and its scope is disconnected from the `$watch` cycle. When\n * navigating to a view that is already cached, its scope is then reconnected, and the existing\n * element that was left in the DOM becomes the active view. This also allows for the scroll\n * position of previous views to be maintained.\n *\n * Caching can be disabled and enabled in multiple ways. By default, Ionic will cache a maximum of\n * 10 views, and not only can this be configured, but apps can also explicitly state which views\n * should and should not be cached.\n *\n * Note that because we are caching these views, *we arent destroying scopes*. Instead, scopes\n * are being disconnected from the watch cycle. Because scopes are not being destroyed and\n * recreated, controllers are not loading again on a subsequent viewing. If the app/controller\n * needs to know when a view has entered or has left, then view events emitted from the\n * {@link ionic.directive:ionView} scope, such as `$ionicView.enter`, may be useful.\n *\n * By default, when navigating back in the history, the \"forward\" views are removed from the cache.\n * If you navigate forward to the same view again, it'll create a new DOM element and controller\n * instance. Basically, any forward views are reset each time. This can be configured using the\n * {@link ionic.provider:$ionicConfigProvider}:\n *\n * ```js\n * $ionicConfigProvider.views.forwardCache(true);\n * ```\n *\n * #### Disable cache globally\n *\n * The {@link ionic.provider:$ionicConfigProvider} can be used to set the maximum allowable views\n * which can be cached, but this can also be use to disable all caching by setting it to 0.\n *\n * ```js\n * $ionicConfigProvider.views.maxCache(0);\n * ```\n *\n * #### Disable cache within state provider\n *\n * ```js\n * $stateProvider.state('myState', {\n *    cache: false,\n *    url : '/myUrl',\n *    templateUrl : 'my-template.html'\n * })\n * ```\n *\n * #### Disable cache with an attribute\n *\n * ```html\n * <ion-view cache-view=\"false\" view-title=\"My Title!\">\n *   ...\n * </ion-view>\n * ```\n *\n *\n * ## AngularUI Router\n *\n * Please visit [AngularUI Router's docs](https://github.com/angular-ui/ui-router/wiki) for\n * more info. Below is a great video by the AngularUI Router team that may help to explain\n * how it all works:\n *\n * <iframe width=\"560\" height=\"315\" src=\"//www.youtube.com/embed/dqJRoh8MnBo\"\n * frameborder=\"0\" allowfullscreen></iframe>\n *\n * @param {string=} name A view name. The name should be unique amongst the other views in the\n * same state. You can have views of the same name that live in different states. For more\n * information, see ui-router's\n * [ui-view documentation](http://angular-ui.github.io/ui-router/site/#/api/ui.router.state.directive:ui-view).\n */\nIonicModule\n.directive('ionNavView', [\n  '$state',\n  '$ionicConfig',\nfunction($state, $ionicConfig) {\n  // IONIC's fork of Angular UI Router, v0.2.10\n  // the navView handles registering views in the history and how to transition between them\n  return {\n    restrict: 'E',\n    terminal: true,\n    priority: 2000,\n    transclude: true,\n    controller: '$ionicNavView',\n    compile: function(tElement, tAttrs, transclude) {\n\n      // a nav view element is a container for numerous views\n      tElement.addClass('view-container');\n      ionic.DomUtil.cachedAttr(tElement, 'nav-view-transition', $ionicConfig.views.transition());\n\n      return function($scope, $element, $attr, navViewCtrl) {\n        var latestLocals;\n\n        // Put in the compiled initial view\n        transclude($scope, function(clone) {\n          $element.append(clone);\n        });\n\n        var viewData = navViewCtrl.init();\n\n        // listen for $stateChangeSuccess\n        $scope.$on('$stateChangeSuccess', function() {\n          updateView(false);\n        });\n        $scope.$on('$viewContentLoading', function() {\n          updateView(false);\n        });\n\n        // initial load, ready go\n        updateView(true);\n\n\n        function updateView(firstTime) {\n          // get the current local according to the $state\n          var viewLocals = $state.$current && $state.$current.locals[viewData.name];\n\n          // do not update THIS nav-view if its is not the container for the given state\n          // if the viewLocals are the same as THIS latestLocals, then nothing to do\n          if (!viewLocals || (!firstTime && viewLocals === latestLocals)) return;\n\n          // update the latestLocals\n          latestLocals = viewLocals;\n          viewData.state = viewLocals.$$state;\n\n          // register, update and transition to the new view\n          navViewCtrl.register(viewLocals);\n        }\n\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/navView.js\n ** module id = 68\n ** module chunks = 0\n **/","IonicModule\n\n.config(['$provide', function($provide) {\n  $provide.decorator('ngClickDirective', ['$delegate', function($delegate) {\n    // drop the default ngClick directive\n    $delegate.shift();\n    return $delegate;\n  }]);\n}])\n\n/**\n * @private\n */\n.factory('$ionicNgClick', ['$parse', function($parse) {\n  return function(scope, element, clickExpr) {\n    var clickHandler = angular.isFunction(clickExpr) ?\n      clickExpr :\n      $parse(clickExpr);\n\n    element.on('click', function(event) {\n      scope.$apply(function() {\n        clickHandler(scope, {$event: (event)});\n      });\n    });\n\n    // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click\n    // something else nearby.\n    element.onclick = noop;\n  };\n}])\n\n.directive('ngClick', ['$ionicNgClick', function($ionicNgClick) {\n  return function(scope, element, attr) {\n    $ionicNgClick(scope, element, attr.ngClick);\n  };\n}])\n\n.directive('ionStopEvent', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attr) {\n      element.bind(attr.ionStopEvent, eventStopPropagation);\n    }\n  };\n});\nfunction eventStopPropagation(e) {\n  e.stopPropagation();\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/ngClick.js\n ** module id = 69\n ** module chunks = 0\n **/","\n/**\n * @ngdoc directive\n * @name ionPane\n * @module ionic\n * @restrict E\n *\n * @description A simple container that fits content, with no side effects.  Adds the 'pane' class to the element.\n */\nIonicModule\n.directive('ionPane', function() {\n  return {\n    restrict: 'E',\n    link: function(scope, element) {\n      element.addClass('pane');\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/pane.js\n ** module id = 70\n ** module chunks = 0\n **/","/*\n * We don't document the ionPopover directive, we instead document\n * the $ionicPopover service\n */\nIonicModule\n.directive('ionPopover', [function() {\n  return {\n    restrict: 'E',\n    transclude: true,\n    replace: true,\n    controller: [function() {}],\n    template: '<div class=\"popover-backdrop\">' +\n                '<div class=\"popover-wrapper\" ng-transclude></div>' +\n              '</div>'\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/popover.js\n ** module id = 71\n ** module chunks = 0\n **/","IonicModule\n.directive('ionPopoverView', function() {\n  return {\n    restrict: 'E',\n    compile: function(element) {\n      element.append(jqLite('<div class=\"popover-arrow\">'));\n      element.addClass('popover');\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/popoverView.js\n ** module id = 72\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionRadio\n * @module ionic\n * @restrict E\n * @codepen saoBG\n * @description\n * The radio directive is no different than the HTML radio input, except it's styled differently.\n *\n * Radio behaves like [AngularJS radio](http://docs.angularjs.org/api/ng/input/input[radio]).\n *\n * @usage\n * ```html\n * <ion-radio ng-model=\"choice\" ng-value=\"'A'\">Choose A</ion-radio>\n * <ion-radio ng-model=\"choice\" ng-value=\"'B'\">Choose B</ion-radio>\n * <ion-radio ng-model=\"choice\" ng-value=\"'C'\">Choose C</ion-radio>\n * ```\n *\n * @param {string=} name The name of the radio input.\n * @param {expression=} value The value of the radio input.\n * @param {boolean=} disabled The state of the radio input.\n * @param {string=} icon The icon to use when the radio input is selected.\n * @param {expression=} ng-value Angular equivalent of the value attribute.\n * @param {expression=} ng-model The angular model for the radio input.\n * @param {boolean=} ng-disabled Angular equivalent of the disabled attribute.\n * @param {expression=} ng-change Triggers given expression when radio input's model changes\n */\nIonicModule\n.directive('ionRadio', function() {\n  return {\n    restrict: 'E',\n    replace: true,\n    require: '?ngModel',\n    transclude: true,\n    template:\n      '<label class=\"item item-radio\">' +\n        '<input type=\"radio\" name=\"radio-group\">' +\n        '<div class=\"radio-content\">' +\n          '<div class=\"item-content disable-pointer-events\" ng-transclude></div>' +\n          '<i class=\"radio-icon disable-pointer-events icon ion-checkmark\"></i>' +\n        '</div>' +\n      '</label>',\n\n    compile: function(element, attr) {\n      if (attr.icon) {\n        var iconElm = element.find('i');\n        iconElm.removeClass('ion-checkmark').addClass(attr.icon);\n      }\n\n      var input = element.find('input');\n      forEach({\n          'name': attr.name,\n          'value': attr.value,\n          'disabled': attr.disabled,\n          'ng-value': attr.ngValue,\n          'ng-model': attr.ngModel,\n          'ng-disabled': attr.ngDisabled,\n          'ng-change': attr.ngChange,\n          'ng-required': attr.ngRequired,\n          'required': attr.required\n      }, function(value, name) {\n        if (isDefined(value)) {\n            input.attr(name, value);\n          }\n      });\n\n      return function(scope, element, attr) {\n        scope.getValue = function() {\n          return scope.ngValue || attr.value;\n        };\n      };\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/radio.js\n ** module id = 73\n ** module chunks = 0\n **/","\n/**\n * @ngdoc directive\n * @name ionRefresher\n * @module ionic\n * @restrict E\n * @parent ionic.directive:ionContent, ionic.directive:ionScroll\n * @description\n * Allows you to add pull-to-refresh to a scrollView.\n *\n * Place it as the first child of your {@link ionic.directive:ionContent} or\n * {@link ionic.directive:ionScroll} element.\n *\n * When refreshing is complete, $broadcast the 'scroll.refreshComplete' event\n * from your controller.\n *\n * @usage\n *\n * ```html\n * <ion-content ng-controller=\"MyController\">\n *   <ion-refresher\n *     pulling-text=\"Pull to refresh...\"\n *     on-refresh=\"doRefresh()\">\n *   </ion-refresher>\n *   <ion-list>\n *     <ion-item ng-repeat=\"item in items\"></ion-item>\n *   </ion-list>\n * </ion-content>\n * ```\n * ```js\n * angular.module('testApp', ['ionic'])\n * .controller('MyController', function($scope, $http) {\n *   $scope.items = [1,2,3];\n *   $scope.doRefresh = function() {\n *     $http.get('/new-items')\n *      .success(function(newItems) {\n *        $scope.items = newItems;\n *      })\n *      .finally(function() {\n *        // Stop the ion-refresher from spinning\n *        $scope.$broadcast('scroll.refreshComplete');\n *      });\n *   };\n * });\n * ```\n *\n * @param {expression=} on-refresh Called when the user pulls down enough and lets go\n * of the refresher.\n * @param {expression=} on-pulling Called when the user starts to pull down\n * on the refresher.\n * @param {string=} pulling-text The text to display while the user is pulling down.\n * @param {string=} pulling-icon The icon to display while the user is pulling down.\n * Default: 'ion-android-arrow-down'.\n * @param {string=} spinner The {@link ionic.directive:ionSpinner} icon to display\n * after user lets go of the refresher. The SVG {@link ionic.directive:ionSpinner}\n * is now the default, replacing rotating font icons. Set to `none` to disable both the\n * spinner and the icon.\n * @param {string=} refreshing-icon The font icon to display after user lets go of the\n * refresher. This is depreicated in favor of the SVG {@link ionic.directive:ionSpinner}.\n * @param {boolean=} disable-pulling-rotation Disables the rotation animation of the pulling\n * icon when it reaches its activated threshold. To be used with a custom `pulling-icon`.\n *\n */\nIonicModule\n.directive('ionRefresher', [function() {\n  return {\n    restrict: 'E',\n    replace: true,\n    require: ['?^$ionicScroll', 'ionRefresher'],\n    controller: '$ionicRefresher',\n    template:\n    '<div class=\"scroll-refresher invisible\" collection-repeat-ignore>' +\n      '<div class=\"ionic-refresher-content\" ' +\n      'ng-class=\"{\\'ionic-refresher-with-text\\': pullingText || refreshingText}\">' +\n        '<div class=\"icon-pulling\" ng-class=\"{\\'pulling-rotation-disabled\\':disablePullingRotation}\">' +\n          '<i class=\"icon {{pullingIcon}}\"></i>' +\n        '</div>' +\n        '<div class=\"text-pulling\" ng-bind-html=\"pullingText\"></div>' +\n        '<div class=\"icon-refreshing\">' +\n          '<ion-spinner ng-if=\"showSpinner\" icon=\"{{spinner}}\"></ion-spinner>' +\n          '<i ng-if=\"showIcon\" class=\"icon {{refreshingIcon}}\"></i>' +\n        '</div>' +\n        '<div class=\"text-refreshing\" ng-bind-html=\"refreshingText\"></div>' +\n      '</div>' +\n    '</div>',\n    link: function($scope, $element, $attrs, ctrls) {\n\n      // JS Scrolling uses the scroll controller\n      var scrollCtrl = ctrls[0],\n          refresherCtrl = ctrls[1];\n      if (!scrollCtrl || scrollCtrl.isNative()) {\n        // Kick off native scrolling\n        refresherCtrl.init();\n      } else {\n        $element[0].classList.add('js-scrolling');\n        scrollCtrl._setRefresher(\n          $scope,\n          $element[0],\n          refresherCtrl.getRefresherDomMethods()\n        );\n\n        $scope.$on('scroll.refreshComplete', function() {\n          $scope.$evalAsync(function() {\n            scrollCtrl.scrollView.finishPullToRefresh();\n          });\n        });\n      }\n\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/refresher.js\n ** module id = 74\n ** module chunks = 0\n **/","/**\r\n * @ngdoc directive\r\n * @name ionScroll\r\n * @module ionic\r\n * @delegate ionic.service:$ionicScrollDelegate\r\n * @codepen mwFuh\r\n * @restrict E\r\n *\r\n * @description\r\n * Creates a scrollable container for all content inside.\r\n *\r\n * @usage\r\n *\r\n * Basic usage:\r\n *\r\n * ```html\r\n * <ion-scroll zooming=\"true\" direction=\"xy\" style=\"width: 500px; height: 500px\">\r\n *   <div style=\"width: 5000px; height: 5000px; background: url('https://upload.wikimedia.org/wikipedia/commons/a/ad/Europe_geological_map-en.jpg') repeat\"></div>\r\n *  </ion-scroll>\r\n * ```\r\n *\r\n * Note that it's important to set the height of the scroll box as well as the height of the inner\r\n * content to enable scrolling. This makes it possible to have full control over scrollable areas.\r\n *\r\n * If you'd just like to have a center content scrolling area, use {@link ionic.directive:ionContent} instead.\r\n *\r\n * @param {string=} delegate-handle The handle used to identify this scrollView\r\n * with {@link ionic.service:$ionicScrollDelegate}.\r\n * @param {string=} direction Which way to scroll. 'x' or 'y' or 'xy'. Default 'y'.\r\n * @param {boolean=} locking Whether to lock scrolling in one direction at a time. Useful to set to false when zoomed in or scrolling in two directions. Default true.\r\n * @param {boolean=} paging Whether to scroll with paging.\r\n * @param {expression=} on-refresh Called on pull-to-refresh, triggered by an {@link ionic.directive:ionRefresher}.\r\n * @param {expression=} on-scroll Called whenever the user scrolls.\r\n * @param {boolean=} scrollbar-x Whether to show the horizontal scrollbar. Default true.\r\n * @param {boolean=} scrollbar-y Whether to show the vertical scrollbar. Default true.\r\n * @param {boolean=} zooming Whether to support pinch-to-zoom\r\n * @param {integer=} min-zoom The smallest zoom amount allowed (default is 0.5)\r\n * @param {integer=} max-zoom The largest zoom amount allowed (default is 3)\r\n * @param {boolean=} has-bouncing Whether to allow scrolling to bounce past the edges\r\n * of the content.  Defaults to true on iOS, false on Android.\r\n */\r\nIonicModule\r\n.directive('ionScroll', [\r\n  '$timeout',\r\n  '$controller',\r\n  '$ionicBind',\r\n  '$ionicConfig',\r\nfunction($timeout, $controller, $ionicBind, $ionicConfig) {\r\n  return {\r\n    restrict: 'E',\r\n    scope: true,\r\n    controller: function() {},\r\n    compile: function(element, attr) {\r\n      element.addClass('scroll-view ionic-scroll');\r\n\r\n      //We cannot transclude here because it breaks element.data() inheritance on compile\r\n      var innerElement = jqLite('<div class=\"scroll\"></div>');\r\n      innerElement.append(element.contents());\r\n      element.append(innerElement);\r\n\r\n      var nativeScrolling = attr.overflowScroll !== \"false\" && (attr.overflowScroll === \"true\" || !$ionicConfig.scrolling.jsScrolling());\r\n\r\n      return { pre: prelink };\r\n      function prelink($scope, $element, $attr) {\r\n        $ionicBind($scope, $attr, {\r\n          direction: '@',\r\n          paging: '@',\r\n          $onScroll: '&onScroll',\r\n          scroll: '@',\r\n          scrollbarX: '@',\r\n          scrollbarY: '@',\r\n          zooming: '@',\r\n          minZoom: '@',\r\n          maxZoom: '@'\r\n        });\r\n        $scope.direction = $scope.direction || 'y';\r\n\r\n        if (isDefined($attr.padding)) {\r\n          $scope.$watch($attr.padding, function(newVal) {\r\n            innerElement.toggleClass('padding', !!newVal);\r\n          });\r\n        }\r\n        if ($scope.$eval($scope.paging) === true) {\r\n          innerElement.addClass('scroll-paging');\r\n        }\r\n\r\n        if (!$scope.direction) { $scope.direction = 'y'; }\r\n        var isPaging = $scope.$eval($scope.paging) === true;\r\n\r\n        if (nativeScrolling) {\r\n          $element.addClass('overflow-scroll');\r\n        }\r\n\r\n        $element.addClass('scroll-' + $scope.direction);\r\n\r\n        var scrollViewOptions = {\r\n          el: $element[0],\r\n          delegateHandle: $attr.delegateHandle,\r\n          locking: ($attr.locking || 'true') === 'true',\r\n          bouncing: $scope.$eval($attr.hasBouncing),\r\n          paging: isPaging,\r\n          scrollbarX: $scope.$eval($scope.scrollbarX) !== false,\r\n          scrollbarY: $scope.$eval($scope.scrollbarY) !== false,\r\n          scrollingX: $scope.direction.indexOf('x') >= 0,\r\n          scrollingY: $scope.direction.indexOf('y') >= 0,\r\n          zooming: $scope.$eval($scope.zooming) === true,\r\n          maxZoom: $scope.$eval($scope.maxZoom) || 3,\r\n          minZoom: $scope.$eval($scope.minZoom) || 0.5,\r\n          preventDefault: true,\r\n          nativeScrolling: nativeScrolling\r\n        };\r\n\r\n        if (isPaging) {\r\n          scrollViewOptions.speedMultiplier = 0.8;\r\n          scrollViewOptions.bouncing = false;\r\n        }\r\n\r\n        $controller('$ionicScroll', {\r\n          $scope: $scope,\r\n          scrollViewOptions: scrollViewOptions\r\n        });\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/scroll.js\n ** module id = 75\n ** module chunks = 0\n **/","/**\r\n * @ngdoc directive\r\n * @name ionSideMenuContent\r\n * @module ionic\r\n * @restrict E\r\n * @parent ionic.directive:ionSideMenus\r\n *\r\n * @description\r\n * A container for the main visible content, sibling to one or more\r\n * {@link ionic.directive:ionSideMenu} directives.\r\n *\r\n * @usage\r\n * ```html\r\n * <ion-side-menu-content\r\n *   edge-drag-threshold=\"true\"\r\n *   drag-content=\"true\">\r\n * </ion-side-menu-content>\r\n * ```\r\n * For a complete side menu example, see the\r\n * {@link ionic.directive:ionSideMenus} documentation.\r\n *\r\n * @param {boolean=} drag-content Whether the content can be dragged. Default true.\r\n * @param {boolean|number=} edge-drag-threshold Whether the content drag can only start if it is below a certain threshold distance from the edge of the screen.  Default false. Accepts three types of values:\r\n   *  - If a non-zero number is given, that many pixels is used as the maximum allowed distance from the edge that starts dragging the side menu.\r\n   *  - If true is given, the default number of pixels (25) is used as the maximum allowed distance.\r\n   *  - If false or 0 is given, the edge drag threshold is disabled, and dragging from anywhere on the content is allowed.\r\n *\r\n */\r\nIonicModule\r\n.directive('ionSideMenuContent', [\r\n  '$timeout',\r\n  '$ionicGesture',\r\n  '$window',\r\nfunction($timeout, $ionicGesture, $window) {\r\n\r\n  return {\r\n    restrict: 'EA', //DEPRECATED 'A'\r\n    require: '^ionSideMenus',\r\n    scope: true,\r\n    compile: function(element, attr) {\r\n      element.addClass('menu-content pane');\r\n\r\n      return { pre: prelink };\r\n      function prelink($scope, $element, $attr, sideMenuCtrl) {\r\n        var startCoord = null;\r\n        var primaryScrollAxis = null;\r\n\r\n        if (isDefined(attr.dragContent)) {\r\n          $scope.$watch(attr.dragContent, function(value) {\r\n            sideMenuCtrl.canDragContent(value);\r\n          });\r\n        } else {\r\n          sideMenuCtrl.canDragContent(true);\r\n        }\r\n\r\n        if (isDefined(attr.edgeDragThreshold)) {\r\n          $scope.$watch(attr.edgeDragThreshold, function(value) {\r\n            sideMenuCtrl.edgeDragThreshold(value);\r\n          });\r\n        }\r\n\r\n        // Listen for taps on the content to close the menu\r\n        function onContentTap(gestureEvt) {\r\n          if (sideMenuCtrl.getOpenAmount() !== 0) {\r\n            sideMenuCtrl.close();\r\n            gestureEvt.gesture.srcEvent.preventDefault();\r\n            startCoord = null;\r\n            primaryScrollAxis = null;\r\n          } else if (!startCoord) {\r\n            startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);\r\n          }\r\n        }\r\n\r\n        function onDragX(e) {\r\n          if (!sideMenuCtrl.isDraggableTarget(e)) return;\r\n\r\n          if (getPrimaryScrollAxis(e) == 'x') {\r\n            sideMenuCtrl._handleDrag(e);\r\n            e.gesture.srcEvent.preventDefault();\r\n          }\r\n        }\r\n\r\n        function onDragY(e) {\r\n          if (getPrimaryScrollAxis(e) == 'x') {\r\n            e.gesture.srcEvent.preventDefault();\r\n          }\r\n        }\r\n\r\n        function onDragRelease(e) {\r\n          sideMenuCtrl._endDrag(e);\r\n          startCoord = null;\r\n          primaryScrollAxis = null;\r\n        }\r\n\r\n        function getPrimaryScrollAxis(gestureEvt) {\r\n          // gets whether the user is primarily scrolling on the X or Y\r\n          // If a majority of the drag has been on the Y since the start of\r\n          // the drag, but the X has moved a little bit, it's still a Y drag\r\n\r\n          if (primaryScrollAxis) {\r\n            // we already figured out which way they're scrolling\r\n            return primaryScrollAxis;\r\n          }\r\n\r\n          if (gestureEvt && gestureEvt.gesture) {\r\n\r\n            if (!startCoord) {\r\n              // get the starting point\r\n              startCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);\r\n\r\n            } else {\r\n              // we already have a starting point, figure out which direction they're going\r\n              var endCoord = ionic.tap.pointerCoord(gestureEvt.gesture.srcEvent);\r\n\r\n              var xDistance = Math.abs(endCoord.x - startCoord.x);\r\n              var yDistance = Math.abs(endCoord.y - startCoord.y);\r\n\r\n              var scrollAxis = (xDistance < yDistance ? 'y' : 'x');\r\n\r\n              if (Math.max(xDistance, yDistance) > 30) {\r\n                // ok, we pretty much know which way they're going\r\n                // let's lock it in\r\n                primaryScrollAxis = scrollAxis;\r\n              }\r\n\r\n              return scrollAxis;\r\n            }\r\n          }\r\n          return 'y';\r\n        }\r\n\r\n        var content = {\r\n          element: element[0],\r\n          onDrag: function() {},\r\n          endDrag: function() {},\r\n          setCanScroll: function(canScroll) {\r\n            var c = $element[0].querySelector('.scroll');\r\n\r\n            if (!c) {\r\n              return;\r\n            }\r\n\r\n            var content = angular.element(c.parentElement);\r\n            if (!content) {\r\n              return;\r\n            }\r\n\r\n            // freeze our scroll container if we have one\r\n            var scrollScope = content.scope();\r\n            scrollScope.scrollCtrl && scrollScope.scrollCtrl.freezeScrollShut(!canScroll);\r\n          },\r\n          getTranslateX: function() {\r\n            return $scope.sideMenuContentTranslateX || 0;\r\n          },\r\n          setTranslateX: ionic.animationFrameThrottle(function(amount) {\r\n            var xTransform = content.offsetX + amount;\r\n            $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + xTransform + 'px,0,0)';\r\n            $timeout(function() {\r\n              $scope.sideMenuContentTranslateX = amount;\r\n            });\r\n          }),\r\n          setMarginLeft: ionic.animationFrameThrottle(function(amount) {\r\n            if (amount) {\r\n              amount = parseInt(amount, 10);\r\n              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amount + 'px,0,0)';\r\n              $element[0].style.width = ($window.innerWidth - amount) + 'px';\r\n              content.offsetX = amount;\r\n            } else {\r\n              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n              $element[0].style.width = '';\r\n              content.offsetX = 0;\r\n            }\r\n          }),\r\n          setMarginRight: ionic.animationFrameThrottle(function(amount) {\r\n            if (amount) {\r\n              amount = parseInt(amount, 10);\r\n              $element[0].style.width = ($window.innerWidth - amount) + 'px';\r\n              content.offsetX = amount;\r\n            } else {\r\n              $element[0].style.width = '';\r\n              content.offsetX = 0;\r\n            }\r\n            // reset incase left gets grabby\r\n            $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n          }),\r\n          setMarginLeftAndRight: ionic.animationFrameThrottle(function(amountLeft, amountRight) {\r\n            amountLeft = amountLeft && parseInt(amountLeft, 10) || 0;\r\n            amountRight = amountRight && parseInt(amountRight, 10) || 0;\r\n\r\n            var amount = amountLeft + amountRight;\r\n\r\n            if (amount > 0) {\r\n              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(' + amountLeft + 'px,0,0)';\r\n              $element[0].style.width = ($window.innerWidth - amount) + 'px';\r\n              content.offsetX = amountLeft;\r\n            } else {\r\n              $element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n              $element[0].style.width = '';\r\n              content.offsetX = 0;\r\n            }\r\n            // reset incase left gets grabby\r\n            //$element[0].style[ionic.CSS.TRANSFORM] = 'translate3d(0,0,0)';\r\n          }),\r\n          enableAnimation: function() {\r\n            $scope.animationEnabled = true;\r\n            $element[0].classList.add('menu-animated');\r\n          },\r\n          disableAnimation: function() {\r\n            $scope.animationEnabled = false;\r\n            $element[0].classList.remove('menu-animated');\r\n          },\r\n          offsetX: 0\r\n        };\r\n\r\n        sideMenuCtrl.setContent(content);\r\n\r\n        // add gesture handlers\r\n        var gestureOpts = { stop_browser_behavior: false };\r\n        gestureOpts.prevent_default_directions = ['left', 'right'];\r\n        var contentTapGesture = $ionicGesture.on('tap', onContentTap, $element, gestureOpts);\r\n        var dragRightGesture = $ionicGesture.on('dragright', onDragX, $element, gestureOpts);\r\n        var dragLeftGesture = $ionicGesture.on('dragleft', onDragX, $element, gestureOpts);\r\n        var dragUpGesture = $ionicGesture.on('dragup', onDragY, $element, gestureOpts);\r\n        var dragDownGesture = $ionicGesture.on('dragdown', onDragY, $element, gestureOpts);\r\n        var releaseGesture = $ionicGesture.on('release', onDragRelease, $element, gestureOpts);\r\n\r\n        // Cleanup\r\n        $scope.$on('$destroy', function() {\r\n          if (content) {\r\n            content.element = null;\r\n            content = null;\r\n          }\r\n          $ionicGesture.off(dragLeftGesture, 'dragleft', onDragX);\r\n          $ionicGesture.off(dragRightGesture, 'dragright', onDragX);\r\n          $ionicGesture.off(dragUpGesture, 'dragup', onDragY);\r\n          $ionicGesture.off(dragDownGesture, 'dragdown', onDragY);\r\n          $ionicGesture.off(releaseGesture, 'release', onDragRelease);\r\n          $ionicGesture.off(contentTapGesture, 'tap', onContentTap);\r\n        });\r\n      }\r\n    }\r\n  };\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/sideMenuContent.js\n ** module id = 76\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionSideMenu\n * @module ionic\n * @restrict E\n * @parent ionic.directive:ionSideMenus\n *\n * @description\n * A container for a side menu, sibling to an {@link ionic.directive:ionSideMenuContent} directive.\n *\n * @usage\n * ```html\n * <ion-side-menu\n *   side=\"left\"\n *   width=\"myWidthValue + 20\"\n *   is-enabled=\"shouldLeftSideMenuBeEnabled()\">\n * </ion-side-menu>\n * ```\n * For a complete side menu example, see the\n * {@link ionic.directive:ionSideMenus} documentation.\n *\n * @param {string} side Which side the side menu is currently on.  Allowed values: 'left' or 'right'.\n * @param {boolean=} is-enabled Whether this side menu is enabled.\n * @param {number=} width How many pixels wide the side menu should be.  Defaults to 275.\n */\nIonicModule\n.directive('ionSideMenu', function() {\n  return {\n    restrict: 'E',\n    require: '^ionSideMenus',\n    scope: true,\n    compile: function(element, attr) {\n      angular.isUndefined(attr.isEnabled) && attr.$set('isEnabled', 'true');\n      angular.isUndefined(attr.width) && attr.$set('width', '275');\n\n      element.addClass('menu menu-' + attr.side);\n\n      return function($scope, $element, $attr, sideMenuCtrl) {\n        $scope.side = $attr.side || 'left';\n\n        var sideMenu = sideMenuCtrl[$scope.side] = new ionic.views.SideMenu({\n          width: attr.width,\n          el: $element[0],\n          isEnabled: true\n        });\n\n        $scope.$watch($attr.width, function(val) {\n          var numberVal = +val;\n          if (numberVal && numberVal == val) {\n            sideMenu.setWidth(+val);\n          }\n        });\n        $scope.$watch($attr.isEnabled, function(val) {\n          sideMenu.setIsEnabled(!!val);\n        });\n      };\n    }\n  };\n});\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/sideMenu.js\n ** module id = 77\n ** module chunks = 0\n **/","IonicModule\n\n/**\n * @ngdoc directive\n * @name ionSideMenus\n * @module ionic\n * @delegate ionic.service:$ionicSideMenuDelegate\n * @restrict E\n *\n * @description\n * A container element for side menu(s) and the main content. Allows the left and/or right side menu\n * to be toggled by dragging the main content area side to side.\n *\n * To automatically close an opened menu, you can add the {@link ionic.directive:menuClose} attribute\n * directive. The `menu-close` attribute is usually added to links and buttons within\n * `ion-side-menu-content`, so that when the element is clicked, the opened side menu will\n * automatically close.\n *\n * \"Burger Icon\" toggles can be added to the header with the {@link ionic.directive:menuToggle}\n * attribute directive. Clicking the toggle will open and close the side menu like the `menu-close`\n * directive. The side menu will automatically hide on child pages, but can be overridden with the\n * enable-menu-with-back-views attribute mentioned below.\n *\n * By default, side menus are hidden underneath their side menu content and can be opened by swiping\n * the content left or right or by toggling a button to show the side menu. Additionally, by adding the\n * {@link ionic.directive:exposeAsideWhen} attribute directive to an\n * {@link ionic.directive:ionSideMenu} element directive, a side menu can be given instructions about\n * \"when\" the menu should be exposed (always viewable).\n *\n * ![Side Menu](http://ionicframework.com.s3.amazonaws.com/docs/controllers/sidemenu.gif)\n *\n * For more information on side menus, check out:\n *\n * - {@link ionic.directive:ionSideMenuContent}\n * - {@link ionic.directive:ionSideMenu}\n * - {@link ionic.directive:menuToggle}\n * - {@link ionic.directive:menuClose}\n * - {@link ionic.directive:exposeAsideWhen}\n *\n * @usage\n * To use side menus, add an `<ion-side-menus>` parent element. This will encompass all pages that have a\n * side menu, and have at least 2 child elements: 1 `<ion-side-menu-content>` for the center content,\n * and one or more `<ion-side-menu>` directives for each side menu(left/right) that you wish to place.\n *\n * ```html\n * <ion-side-menus>\n *   <!-- Left menu -->\n *   <ion-side-menu side=\"left\">\n *   </ion-side-menu>\n *\n *   <ion-side-menu-content>\n *   <!-- Main content, usually <ion-nav-view> -->\n *   </ion-side-menu-content>\n *\n *   <!-- Right menu -->\n *   <ion-side-menu side=\"right\">\n *   </ion-side-menu>\n *\n * </ion-side-menus>\n * ```\n * ```js\n * function ContentController($scope, $ionicSideMenuDelegate) {\n *   $scope.toggleLeft = function() {\n *     $ionicSideMenuDelegate.toggleLeft();\n *   };\n * }\n * ```\n *\n * @param {bool=} enable-menu-with-back-views Determines whether the side menu is enabled when the\n * back button is showing. When set to `false`, any {@link ionic.directive:menuToggle} will be hidden,\n * and the user cannot swipe to open the menu. When going back to the root page of the side menu (the\n * page without a back button visible), then any menuToggle buttons will show again, and menus will be\n * enabled again.\n * @param {string=} delegate-handle The handle used to identify this side menu\n * with {@link ionic.service:$ionicSideMenuDelegate}.\n *\n */\n.directive('ionSideMenus', ['$ionicBody', function($ionicBody) {\n  return {\n    restrict: 'ECA',\n    controller: '$ionicSideMenus',\n    compile: function(element, attr) {\n      attr.$set('class', (attr['class'] || '') + ' view');\n\n      return { pre: prelink };\n      function prelink($scope, $element, $attrs, ctrl) {\n\n        ctrl.enableMenuWithBackViews($scope.$eval($attrs.enableMenuWithBackViews));\n\n        $scope.$on('$ionicExposeAside', function(evt, isAsideExposed) {\n          if (!$scope.$exposeAside) $scope.$exposeAside = {};\n          $scope.$exposeAside.active = isAsideExposed;\n          $ionicBody.enableClass(isAsideExposed, 'aside-open');\n        });\n\n        $scope.$on('$ionicView.beforeEnter', function(ev, d) {\n          if (d.historyId) {\n            $scope.$activeHistoryId = d.historyId;\n          }\n        });\n\n        $scope.$on('$destroy', function() {\n          $ionicBody.removeClass('menu-open', 'aside-open');\n        });\n\n      }\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/sideMenus.js\n ** module id = 78\n ** module chunks = 0\n **/","\r\n/**\r\n * @ngdoc directive\r\n * @name ionSlideBox\r\n * @module ionic\r\n * @deprecated will be removed in the next Ionic release in favor of the new ion-slides component.\r\n * Don't depend on the internal behavior of this widget.\r\n * @delegate ionic.service:$ionicSlideBoxDelegate\r\n * @restrict E\r\n * @description\r\n * The Slide Box is a multi-page container where each page can be swiped or dragged between:\r\n *\r\n * ![SlideBox](http://ionicframework.com.s3.amazonaws.com/docs/controllers/slideBox.gif)\r\n *\r\n * @usage\r\n * ```html\r\n * <ion-slide-box on-slide-changed=\"slideHasChanged($index)\">\r\n *   <ion-slide>\r\n *     <div class=\"box blue\"><h1>BLUE</h1></div>\r\n *   </ion-slide>\r\n *   <ion-slide>\r\n *     <div class=\"box yellow\"><h1>YELLOW</h1></div>\r\n *   </ion-slide>\r\n *   <ion-slide>\r\n *     <div class=\"box pink\"><h1>PINK</h1></div>\r\n *   </ion-slide>\r\n * </ion-slide-box>\r\n * ```\r\n *\r\n * @param {string=} delegate-handle The handle used to identify this slideBox\r\n * with {@link ionic.service:$ionicSlideBoxDelegate}.\r\n * @param {boolean=} does-continue Whether the slide box should loop.\r\n * @param {boolean=} auto-play Whether the slide box should automatically slide. Default true if does-continue is true.\r\n * @param {number=} slide-interval How many milliseconds to wait to change slides (if does-continue is true). Defaults to 4000.\r\n * @param {boolean=} show-pager Whether a pager should be shown for this slide box. Accepts expressions via `show-pager=\"{{shouldShow()}}\"`. Defaults to true.\r\n * @param {expression=} pager-click Expression to call when a pager is clicked (if show-pager is true). Is passed the 'index' variable.\r\n * @param {expression=} on-slide-changed Expression called whenever the slide is changed.  Is passed an '$index' variable.\r\n * @param {expression=} active-slide Model to bind the current slide index to.\r\n */\r\nIonicModule\r\n.directive('ionSlideBox', [\r\n  '$animate',\r\n  '$timeout',\r\n  '$compile',\r\n  '$ionicSlideBoxDelegate',\r\n  '$ionicHistory',\r\n  '$ionicScrollDelegate',\r\nfunction($animate, $timeout, $compile, $ionicSlideBoxDelegate, $ionicHistory, $ionicScrollDelegate) {\r\n  return {\r\n    restrict: 'E',\r\n    replace: true,\r\n    transclude: true,\r\n    scope: {\r\n      autoPlay: '=',\r\n      doesContinue: '@',\r\n      slideInterval: '@',\r\n      showPager: '@',\r\n      pagerClick: '&',\r\n      disableScroll: '@',\r\n      onSlideChanged: '&',\r\n      activeSlide: '=?',\r\n      bounce: '@'\r\n    },\r\n    controller: ['$scope', '$element', '$attrs', function($scope, $element, $attrs) {\r\n      var _this = this;\r\n\r\n      var continuous = $scope.$eval($scope.doesContinue) === true;\r\n      var bouncing = ($scope.$eval($scope.bounce) !== false); //Default to true\r\n      var shouldAutoPlay = isDefined($attrs.autoPlay) ? !!$scope.autoPlay : false;\r\n      var slideInterval = shouldAutoPlay ? $scope.$eval($scope.slideInterval) || 4000 : 0;\r\n\r\n      var slider = new ionic.views.Slider({\r\n        el: $element[0],\r\n        auto: slideInterval,\r\n        continuous: continuous,\r\n        startSlide: $scope.activeSlide,\r\n        bouncing: bouncing,\r\n        slidesChanged: function() {\r\n          $scope.currentSlide = slider.currentIndex();\r\n\r\n          // Try to trigger a digest\r\n          $timeout(function() {});\r\n        },\r\n        callback: function(slideIndex) {\r\n          $scope.currentSlide = slideIndex;\r\n          $scope.onSlideChanged({ index: $scope.currentSlide, $index: $scope.currentSlide});\r\n          $scope.$parent.$broadcast('slideBox.slideChanged', slideIndex);\r\n          $scope.activeSlide = slideIndex;\r\n          // Try to trigger a digest\r\n          $timeout(function() {});\r\n        },\r\n        onDrag: function() {\r\n          freezeAllScrolls(true);\r\n        },\r\n        onDragEnd: function() {\r\n          freezeAllScrolls(false);\r\n        }\r\n      });\r\n\r\n      function freezeAllScrolls(shouldFreeze) {\r\n        if (shouldFreeze && !_this.isScrollFreeze) {\r\n          $ionicScrollDelegate.freezeAllScrolls(shouldFreeze);\r\n\r\n        } else if (!shouldFreeze && _this.isScrollFreeze) {\r\n          $ionicScrollDelegate.freezeAllScrolls(false);\r\n        }\r\n        _this.isScrollFreeze = shouldFreeze;\r\n      }\r\n\r\n      slider.enableSlide($scope.$eval($attrs.disableScroll) !== true);\r\n\r\n      $scope.$watch('activeSlide', function(nv) {\r\n        if (isDefined(nv)) {\r\n          slider.slide(nv);\r\n        }\r\n      });\r\n\r\n      $scope.$on('slideBox.nextSlide', function() {\r\n        slider.next();\r\n      });\r\n\r\n      $scope.$on('slideBox.prevSlide', function() {\r\n        slider.prev();\r\n      });\r\n\r\n      $scope.$on('slideBox.setSlide', function(e, index) {\r\n        slider.slide(index);\r\n      });\r\n\r\n      //Exposed for testing\r\n      this.__slider = slider;\r\n\r\n      var deregisterInstance = $ionicSlideBoxDelegate._registerInstance(\r\n        slider, $attrs.delegateHandle, function() {\r\n          return $ionicHistory.isActiveScope($scope);\r\n        }\r\n      );\r\n      $scope.$on('$destroy', function() {\r\n        deregisterInstance();\r\n        slider.kill();\r\n      });\r\n\r\n      this.slidesCount = function() {\r\n        return slider.slidesCount();\r\n      };\r\n\r\n      this.onPagerClick = function(index) {\r\n        $scope.pagerClick({index: index});\r\n      };\r\n\r\n      $timeout(function() {\r\n        slider.load();\r\n      });\r\n    }],\r\n    template: '<div class=\"slider\">' +\r\n      '<div class=\"slider-slides\" ng-transclude>' +\r\n      '</div>' +\r\n    '</div>',\r\n\r\n    link: function($scope, $element, $attr) {\r\n      // Disable ngAnimate for slidebox and its children\r\n      $animate.enabled(false, $element);\r\n\r\n      // if showPager is undefined, show the pager\r\n      if (!isDefined($attr.showPager)) {\r\n        $scope.showPager = true;\r\n        getPager().toggleClass('hide', !true);\r\n      }\r\n\r\n      $attr.$observe('showPager', function(show) {\r\n        if (show === undefined) return;\r\n        show = $scope.$eval(show);\r\n        getPager().toggleClass('hide', !show);\r\n      });\r\n\r\n      var pager;\r\n      function getPager() {\r\n        if (!pager) {\r\n          var childScope = $scope.$new();\r\n          pager = jqLite('<ion-pager></ion-pager>');\r\n          $element.append(pager);\r\n          pager = $compile(pager)(childScope);\r\n        }\r\n        return pager;\r\n      }\r\n    }\r\n  };\r\n}])\r\n.directive('ionSlide', function() {\r\n  return {\r\n    restrict: 'E',\r\n    require: '?^ionSlideBox',\r\n    compile: function(element) {\r\n      element.addClass('slider-slide');\r\n    }\r\n  };\r\n})\r\n\r\n.directive('ionPager', function() {\r\n  return {\r\n    restrict: 'E',\r\n    replace: true,\r\n    require: '^ionSlideBox',\r\n    template: '<div class=\"slider-pager\"><span class=\"slider-pager-page\" ng-repeat=\"slide in numSlides() track by $index\" ng-class=\"{active: $index == currentSlide}\" ng-click=\"pagerClick($index)\"><i class=\"icon ion-record\"></i></span></div>',\r\n    link: function($scope, $element, $attr, slideBox) {\r\n      var selectPage = function(index) {\r\n        var children = $element[0].children;\r\n        var length = children.length;\r\n        for (var i = 0; i < length; i++) {\r\n          if (i == index) {\r\n            children[i].classList.add('active');\r\n          } else {\r\n            children[i].classList.remove('active');\r\n          }\r\n        }\r\n      };\r\n\r\n      $scope.pagerClick = function(index) {\r\n        slideBox.onPagerClick(index);\r\n      };\r\n\r\n      $scope.numSlides = function() {\r\n        return new Array(slideBox.slidesCount());\r\n      };\r\n\r\n      $scope.$watch('currentSlide', function(v) {\r\n        selectPage(v);\r\n      });\r\n    }\r\n  };\r\n\r\n});\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/slideBox.js\n ** module id = 79\n ** module chunks = 0\n **/","\r\n/**\r\n * @ngdoc directive\r\n * @name ionSlides\r\n * @module ionic\r\n * @delegate ionic.service:$ionicSlideBoxDelegate\r\n * @restrict E\r\n * @description\r\n * The Slides component is a powerful multi-page container where each page can be swiped or dragged between.\r\n *\r\n * Note: this is a new version of the Ionic Slide Box based on the [Swiper](http://www.idangero.us/swiper/#.Vmc1J-ODFBc) widget from\r\n * [idangerous](http://www.idangero.us/).\r\n *\r\n * ![SlideBox](http://ionicframework.com.s3.amazonaws.com/docs/controllers/slideBox.gif)\r\n *\r\n * @usage\r\n * ```html\r\n * <ion-slides on-slide-changed=\"slideHasChanged($index)\">\r\n *   <ion-slide-page>\r\n *     <div class=\"box blue\"><h1>BLUE</h1></div>\r\n *   </ion-slide-page>\r\n *   <ion-slide-page>\r\n *     <div class=\"box yellow\"><h1>YELLOW</h1></div>\r\n *   </ion-slide-page>\r\n *   <ion-slide-page>\r\n *     <div class=\"box pink\"><h1>PINK</h1></div>\r\n *   </ion-slide-page>\r\n * </ion-slides>\r\n * ```\r\n *\r\n * @param {string=} delegate-handle The handle used to identify this slideBox\r\n * with {@link ionic.service:$ionicSlideBoxDelegate}.\r\n * @param {object=} options to pass to the widget. See the full ist here: [http://www.idangero.us/swiper/api/](http://www.idangero.us/swiper/api/)\r\n */\r\nIonicModule\r\n.directive('ionSlides', [\r\n  '$animate',\r\n  '$timeout',\r\n  '$compile',\r\nfunction($animate, $timeout, $compile) {\r\n  return {\r\n    restrict: 'E',\r\n    transclude: true,\r\n    scope: {\r\n      options: '=',\r\n      slider: '='\r\n    },\r\n    template: '<div class=\"swiper-container\">' +\r\n      '<div class=\"swiper-wrapper\" ng-transclude>' +\r\n      '</div>' +\r\n        '<div ng-hide=\"!showPager\" class=\"swiper-pagination\"></div>' +\r\n      '</div>',\r\n    controller: ['$scope', '$element', function($scope, $element) {\r\n      var _this = this;\r\n\r\n      this.update = function() {\r\n        $timeout(function() {\r\n          if (!_this.__slider) {\r\n            return;\r\n          }\r\n\r\n          _this.__slider.update();\r\n          if (_this._options.loop) {\r\n            _this.__slider.createLoop();\r\n          }\r\n\r\n          // Don't allow pager to show with > 10 slides\r\n          if (_this.__slider.slides.length > 10) {\r\n            $scope.showPager = false;\r\n          }\r\n        });\r\n      };\r\n\r\n      this.rapidUpdate = ionic.debounce(function() {\r\n        _this.update();\r\n      }, 50);\r\n\r\n      this.getSlider = function() {\r\n        return _this.__slider;\r\n      };\r\n\r\n      var options = $scope.options || {};\r\n\r\n      var newOptions = angular.extend({\r\n        pagination: '.swiper-pagination',\r\n        paginationClickable: true,\r\n        lazyLoading: true,\r\n        preloadImages: false\r\n      }, options);\r\n\r\n      this._options = newOptions;\r\n\r\n      $timeout(function() {\r\n        var slider = new ionic.views.Swiper($element.children()[0], newOptions, $scope, $compile);\r\n\r\n        _this.__slider = slider;\r\n        $scope.slider = _this.__slider;\r\n\r\n        $scope.$on('$destroy', function() {\r\n          slider.destroy();\r\n        });\r\n      });\r\n\r\n    }],\r\n\r\n\r\n    link: function($scope) {\r\n      $scope.showPager = true;\r\n      // Disable ngAnimate for slidebox and its children\r\n      //$animate.enabled(false, $element);\r\n    }\r\n  };\r\n}])\r\n.directive('ionSlidePage', [function() {\r\n  return {\r\n    restrict: 'E',\r\n    require: '?^ionSlides',\r\n    transclude: true,\r\n    replace: true,\r\n    template: '<div class=\"swiper-slide\" ng-transclude></div>',\r\n    link: function($scope, $element, $attr, ionSlidesCtrl) {\r\n      ionSlidesCtrl.rapidUpdate();\r\n    }\r\n  };\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/slides.js\n ** module id = 80\n ** module chunks = 0\n **/","/**\n* @ngdoc directive\n* @name ionSpinner\n* @module ionic\n* @restrict E\n *\n * @description\n * The `ionSpinner` directive provides a variety of animated spinners.\n * Spinners enables you to give your users feedback that the app is\n * processing/thinking/waiting/chillin' out, or whatever you'd like it to indicate.\n * By default, the {@link ionic.directive:ionRefresher} feature uses this spinner, rather\n * than rotating font icons (previously included in [ionicons](http://ionicons.com/)).\n * While font icons are great for simple or stationary graphics, they're not suited to\n * provide great animations, which is why Ionic uses SVG instead.\n *\n * Ionic offers ten spinners out of the box, and by default, it will use the appropriate spinner\n * for the platform on which it's running. Under the hood, the `ionSpinner` directive dynamically\n * builds the required SVG element, which allows Ionic to provide all ten of the animated SVGs\n * within 3KB.\n *\n * <style>\n * .spinner-table {\n *   max-width: 280px;\n * }\n * .spinner-table tbody > tr > th, .spinner-table tbody > tr > td {\n *   vertical-align: middle;\n *   width: 42px;\n *   height: 42px;\n * }\n * .spinner {\n *   stroke: #444;\n *   fill: #444; }\n *   .spinner svg {\n *     width: 28px;\n *     height: 28px; }\n *   .spinner.spinner-inverse {\n *     stroke: #fff;\n *     fill: #fff; }\n *\n * .spinner-android {\n *   stroke: #4b8bf4; }\n *\n * .spinner-ios, .spinner-ios-small {\n *   stroke: #69717d; }\n *\n * .spinner-spiral .stop1 {\n *   stop-color: #fff;\n *   stop-opacity: 0; }\n * .spinner-spiral.spinner-inverse .stop1 {\n *   stop-color: #000; }\n * .spinner-spiral.spinner-inverse .stop2 {\n *   stop-color: #fff; }\n * </style>\n *\n * <script src=\"http://code.ionicframework.com/nightly/js/ionic.bundle.min.js\"></script>\n * <table class=\"table spinner-table\" ng-app=\"ionic\">\n *  <tr>\n *    <th>\n *      <code>android</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"android\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>ios</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"ios\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>ios-small</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"ios-small\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>bubbles</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"bubbles\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>circles</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"circles\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>crescent</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"crescent\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>dots</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"dots\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>lines</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"lines\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>ripple</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"ripple\"></ion-spinner>\n *    </td>\n *  </tr>\n *  <tr>\n *    <th>\n *      <code>spiral</code>\n *    </th>\n *    <td>\n *      <ion-spinner icon=\"spiral\"></ion-spinner>\n *    </td>\n *  </tr>\n * </table>\n *\n * Each spinner uses SVG with SMIL animations, however, the Android spinner also uses JavaScript\n * so it also works on Android 4.0-4.3. Additionally, each spinner can be styled with CSS,\n * and scaled to any size.\n *\n *\n * @usage\n * The following code would use the default spinner for the platform it's running from. If it's neither\n * iOS or Android, it'll default to use `ios`.\n *\n * ```html\n * <ion-spinner></ion-spinner>\n * ```\n *\n * By setting the `icon` attribute, you can specify which spinner to use, no matter what\n * the platform is.\n *\n * ```html\n * <ion-spinner icon=\"spiral\"></ion-spinner>\n * ```\n *\n * ## Spinner Colors\n * Like with most of Ionic's other components, spinners can also be styled using\n * Ionic's standard color naming convention. For example:\n *\n * ```html\n * <ion-spinner class=\"spinner-energized\"></ion-spinner>\n * ```\n *\n *\n * ## Styling SVG with CSS\n * One cool thing about SVG is its ability to be styled with CSS! Some of the properties\n * have different names, for example, SVG uses the term `stroke` instead of `border`, and\n * `fill` instead of `background-color`.\n *\n * ```css\n * .spinner svg {\n *   width: 28px;\n *   height: 28px;\n *   stroke: #444;\n *   fill: #444;\n * }\n * ```\n *\n*/\nIonicModule\n.directive('ionSpinner', function() {\n  return {\n    restrict: 'E',\n    controller: '$ionicSpinner',\n    link: function($scope, $element, $attrs, ctrl) {\n      var spinnerName = ctrl.init();\n      $element.addClass('spinner spinner-' + spinnerName);\n\n      $element.on('$destroy', function onDestroy() {\n        ctrl.stop();\n      });\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/spinner.js\n ** module id = 81\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionTab\n * @module ionic\n * @restrict E\n * @parent ionic.directive:ionTabs\n *\n * @description\n * Contains a tab's content.  The content only exists while the given tab is selected.\n *\n * Each ionTab has its own view history.\n *\n * @usage\n * ```html\n * <ion-tab\n *   title=\"Tab!\"\n *   icon=\"my-icon\"\n *   href=\"#/tab/tab-link\"\n *   on-select=\"onTabSelected()\"\n *   on-deselect=\"onTabDeselected()\">\n * </ion-tab>\n * ```\n * For a complete, working tab bar example, see the {@link ionic.directive:ionTabs} documentation.\n *\n * @param {string} title The title of the tab.\n * @param {string=} href The link that this tab will navigate to when tapped.\n * @param {string=} icon The icon of the tab. If given, this will become the default for icon-on and icon-off.\n * @param {string=} icon-on The icon of the tab while it is selected.\n * @param {string=} icon-off The icon of the tab while it is not selected.\n * @param {expression=} badge The badge to put on this tab (usually a number).\n * @param {expression=} badge-style The style of badge to put on this tab (eg: badge-positive).\n * @param {expression=} on-select Called when this tab is selected.\n * @param {expression=} on-deselect Called when this tab is deselected.\n * @param {expression=} ng-click By default, the tab will be selected on click. If ngClick is set, it will not.  You can explicitly switch tabs using {@link ionic.service:$ionicTabsDelegate#select $ionicTabsDelegate.select()}.\n * @param {expression=} hidden Whether the tab is to be hidden or not.\n * @param {expression=} disabled Whether the tab is to be disabled or not.\n */\nIonicModule\n.directive('ionTab', [\n  '$compile',\n  '$ionicConfig',\n  '$ionicBind',\n  '$ionicViewSwitcher',\nfunction($compile, $ionicConfig, $ionicBind, $ionicViewSwitcher) {\n\n  //Returns ' key=\"value\"' if value exists\n  function attrStr(k, v) {\n    return isDefined(v) ? ' ' + k + '=\"' + v + '\"' : '';\n  }\n  return {\n    restrict: 'E',\n    require: ['^ionTabs', 'ionTab'],\n    controller: '$ionicTab',\n    scope: true,\n    compile: function(element, attr) {\n\n      //We create the tabNavTemplate in the compile phase so that the\n      //attributes we pass down won't be interpolated yet - we want\n      //to pass down the 'raw' versions of the attributes\n      var tabNavTemplate = '<ion-tab-nav' +\n        attrStr('ng-click', attr.ngClick) +\n        attrStr('title', attr.title) +\n        attrStr('icon', attr.icon) +\n        attrStr('icon-on', attr.iconOn) +\n        attrStr('icon-off', attr.iconOff) +\n        attrStr('badge', attr.badge) +\n        attrStr('badge-style', attr.badgeStyle) +\n        attrStr('hidden', attr.hidden) +\n        attrStr('disabled', attr.disabled) +\n        attrStr('class', attr['class']) +\n        '></ion-tab-nav>';\n\n      //Remove the contents of the element so we can compile them later, if tab is selected\n      var tabContentEle = document.createElement('div');\n      for (var x = 0; x < element[0].children.length; x++) {\n        tabContentEle.appendChild(element[0].children[x].cloneNode(true));\n      }\n      var childElementCount = tabContentEle.childElementCount;\n      element.empty();\n\n      var navViewName, isNavView;\n      if (childElementCount) {\n        if (tabContentEle.children[0].tagName === 'ION-NAV-VIEW') {\n          // get the name if it's a nav-view\n          navViewName = tabContentEle.children[0].getAttribute('name');\n          tabContentEle.children[0].classList.add('view-container');\n          isNavView = true;\n        }\n        if (childElementCount === 1) {\n          // make the 1 child element the primary tab content container\n          tabContentEle = tabContentEle.children[0];\n        }\n        if (!isNavView) tabContentEle.classList.add('pane');\n        tabContentEle.classList.add('tab-content');\n      }\n\n      return function link($scope, $element, $attr, ctrls) {\n        var childScope;\n        var childElement;\n        var tabsCtrl = ctrls[0];\n        var tabCtrl = ctrls[1];\n        var isTabContentAttached = false;\n        $scope.$tabSelected = false;\n\n        $ionicBind($scope, $attr, {\n          onSelect: '&',\n          onDeselect: '&',\n          title: '@',\n          uiSref: '@',\n          href: '@'\n        });\n\n        tabsCtrl.add($scope);\n        $scope.$on('$destroy', function() {\n          if (!$scope.$tabsDestroy) {\n            // if the containing ionTabs directive is being destroyed\n            // then don't bother going through the controllers remove\n            // method, since remove will reset the active tab as each tab\n            // is being destroyed, causing unnecessary view loads and transitions\n            tabsCtrl.remove($scope);\n          }\n          tabNavElement.isolateScope().$destroy();\n          tabNavElement.remove();\n          tabNavElement = tabContentEle = childElement = null;\n        });\n\n        //Remove title attribute so browser-tooltip does not apear\n        $element[0].removeAttribute('title');\n\n        if (navViewName) {\n          tabCtrl.navViewName = $scope.navViewName = navViewName;\n        }\n        $scope.$on('$stateChangeSuccess', selectIfMatchesState);\n        selectIfMatchesState();\n        function selectIfMatchesState() {\n          if (tabCtrl.tabMatchesState()) {\n            tabsCtrl.select($scope, false);\n          }\n        }\n\n        var tabNavElement = jqLite(tabNavTemplate);\n        tabNavElement.data('$ionTabsController', tabsCtrl);\n        tabNavElement.data('$ionTabController', tabCtrl);\n        tabsCtrl.$tabsElement.append($compile(tabNavElement)($scope));\n\n\n        function tabSelected(isSelected) {\n          if (isSelected && childElementCount) {\n            // this tab is being selected\n\n            // check if the tab is already in the DOM\n            // only do this if the tab has child elements\n            if (!isTabContentAttached) {\n              // tab should be selected and is NOT in the DOM\n              // create a new scope and append it\n              childScope = $scope.$new();\n              childElement = jqLite(tabContentEle);\n              $ionicViewSwitcher.viewEleIsActive(childElement, true);\n              tabsCtrl.$element.append(childElement);\n              $compile(childElement)(childScope);\n              isTabContentAttached = true;\n            }\n\n            // remove the hide class so the tabs content shows up\n            $ionicViewSwitcher.viewEleIsActive(childElement, true);\n\n          } else if (isTabContentAttached && childElement) {\n            // this tab should NOT be selected, and it is already in the DOM\n\n            if ($ionicConfig.views.maxCache() > 0) {\n              // keep the tabs in the DOM, only css hide it\n              $ionicViewSwitcher.viewEleIsActive(childElement, false);\n\n            } else {\n              // do not keep tabs in the DOM\n              destroyTab();\n            }\n\n          }\n        }\n\n        function destroyTab() {\n          childScope && childScope.$destroy();\n          isTabContentAttached && childElement && childElement.remove();\n          tabContentEle.innerHTML = '';\n          isTabContentAttached = childScope = childElement = null;\n        }\n\n        $scope.$watch('$tabSelected', tabSelected);\n\n        $scope.$on('$ionicView.afterEnter', function() {\n          $ionicViewSwitcher.viewEleIsActive(childElement, $scope.$tabSelected);\n        });\n\n        $scope.$on('$ionicView.clearCache', function() {\n          if (!$scope.$tabSelected) {\n            destroyTab();\n          }\n        });\n\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/tab.js\n ** module id = 82\n ** module chunks = 0\n **/","IonicModule\n.directive('ionTabNav', [function() {\n  return {\n    restrict: 'E',\n    replace: true,\n    require: ['^ionTabs', '^ionTab'],\n    template:\n    '<a ng-class=\"{\\'tab-item-active\\': isTabActive(), \\'has-badge\\':badge, \\'tab-hidden\\':isHidden()}\" ' +\n      ' ng-disabled=\"disabled()\" class=\"tab-item\">' +\n      '<span class=\"badge {{badgeStyle}}\" ng-if=\"badge\">{{badge}}</span>' +\n      '<i class=\"icon {{getIconOn()}}\" ng-if=\"getIconOn() && isTabActive()\"></i>' +\n      '<i class=\"icon {{getIconOff()}}\" ng-if=\"getIconOff() && !isTabActive()\"></i>' +\n      '<span class=\"tab-title\" ng-bind-html=\"title\"></span>' +\n    '</a>',\n    scope: {\n      title: '@',\n      icon: '@',\n      iconOn: '@',\n      iconOff: '@',\n      badge: '=',\n      hidden: '@',\n      disabled: '&',\n      badgeStyle: '@',\n      'class': '@'\n    },\n    link: function($scope, $element, $attrs, ctrls) {\n      var tabsCtrl = ctrls[0],\n        tabCtrl = ctrls[1];\n\n      //Remove title attribute so browser-tooltip does not apear\n      $element[0].removeAttribute('title');\n\n      $scope.selectTab = function(e) {\n        e.preventDefault();\n        tabsCtrl.select(tabCtrl.$scope, true);\n      };\n      if (!$attrs.ngClick) {\n        $element.on('click', function(event) {\n          $scope.$apply(function() {\n            $scope.selectTab(event);\n          });\n        });\n      }\n\n      $scope.isHidden = function() {\n        if ($attrs.hidden === 'true' || $attrs.hidden === true) return true;\n        return false;\n      };\n\n      $scope.getIconOn = function() {\n        return $scope.iconOn || $scope.icon;\n      };\n      $scope.getIconOff = function() {\n        return $scope.iconOff || $scope.icon;\n      };\n\n      $scope.isTabActive = function() {\n        return tabsCtrl.selectedTab() === tabCtrl.$scope;\n      };\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/tabNav.js\n ** module id = 83\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionTabs\n * @module ionic\n * @delegate ionic.service:$ionicTabsDelegate\n * @restrict E\n * @codepen odqCz\n *\n * @description\n * Powers a multi-tabbed interface with a Tab Bar and a set of \"pages\" that can be tabbed\n * through.\n *\n * Assign any [tabs class](/docs/components#tabs) to the element to define\n * its look and feel.\n *\n * For iOS, tabs will appear at the bottom of the screen. For Android, tabs will be at the top\n * of the screen, below the nav-bar. This follows each OS's design specification, but can be\n * configured with the {@link ionic.provider:$ionicConfigProvider}.\n *\n * See the {@link ionic.directive:ionTab} directive's documentation for more details on\n * individual tabs.\n *\n * Note: do not place ion-tabs inside of an ion-content element; it has been known to cause a\n * certain CSS bug.\n *\n * @usage\n * ```html\n * <ion-tabs class=\"tabs-positive tabs-icon-top\">\n *\n *   <ion-tab title=\"Home\" icon-on=\"ion-ios-filing\" icon-off=\"ion-ios-filing-outline\">\n *     <!-- Tab 1 content -->\n *   </ion-tab>\n *\n *   <ion-tab title=\"About\" icon-on=\"ion-ios-clock\" icon-off=\"ion-ios-clock-outline\">\n *     <!-- Tab 2 content -->\n *   </ion-tab>\n *\n *   <ion-tab title=\"Settings\" icon-on=\"ion-ios-gear\" icon-off=\"ion-ios-gear-outline\">\n *     <!-- Tab 3 content -->\n *   </ion-tab>\n *\n * </ion-tabs>\n * ```\n *\n * @param {string=} delegate-handle The handle used to identify these tabs\n * with {@link ionic.service:$ionicTabsDelegate}.\n */\n\nIonicModule\n.directive('ionTabs', [\n  '$ionicTabsDelegate',\n  '$ionicConfig',\nfunction($ionicTabsDelegate, $ionicConfig) {\n  return {\n    restrict: 'E',\n    scope: true,\n    controller: '$ionicTabs',\n    compile: function(tElement) {\n      //We cannot use regular transclude here because it breaks element.data()\n      //inheritance on compile\n      var innerElement = jqLite('<div class=\"tab-nav tabs\">');\n      innerElement.append(tElement.contents());\n\n      tElement.append(innerElement)\n              .addClass('tabs-' + $ionicConfig.tabs.position() + ' tabs-' + $ionicConfig.tabs.style());\n\n      return { pre: prelink, post: postLink };\n      function prelink($scope, $element, $attr, tabsCtrl) {\n        var deregisterInstance = $ionicTabsDelegate._registerInstance(\n          tabsCtrl, $attr.delegateHandle, tabsCtrl.hasActiveScope\n        );\n\n        tabsCtrl.$scope = $scope;\n        tabsCtrl.$element = $element;\n        tabsCtrl.$tabsElement = jqLite($element[0].querySelector('.tabs'));\n\n        $scope.$watch(function() { return $element[0].className; }, function(value) {\n          var isTabsTop = value.indexOf('tabs-top') !== -1;\n          var isHidden = value.indexOf('tabs-item-hide') !== -1;\n          $scope.$hasTabs = !isTabsTop && !isHidden;\n          $scope.$hasTabsTop = isTabsTop && !isHidden;\n          $scope.$emit('$ionicTabs.top', $scope.$hasTabsTop);\n        });\n\n        function emitLifecycleEvent(ev, data) {\n          ev.stopPropagation();\n          var previousSelectedTab = tabsCtrl.previousSelectedTab();\n          if (previousSelectedTab) {\n            previousSelectedTab.$broadcast(ev.name.replace('NavView', 'Tabs'), data);\n          }\n        }\n\n        $scope.$on('$ionicNavView.beforeLeave', emitLifecycleEvent);\n        $scope.$on('$ionicNavView.afterLeave', emitLifecycleEvent);\n        $scope.$on('$ionicNavView.leave', emitLifecycleEvent);\n\n        $scope.$on('$destroy', function() {\n          // variable to inform child tabs that they're all being blown away\n          // used so that while destorying an individual tab, each one\n          // doesn't select the next tab as the active one, which causes unnecessary\n          // loading of tab views when each will eventually all go away anyway\n          $scope.$tabsDestroy = true;\n          deregisterInstance();\n          tabsCtrl.$tabsElement = tabsCtrl.$element = tabsCtrl.$scope = innerElement = null;\n          delete $scope.$hasTabs;\n          delete $scope.$hasTabsTop;\n        });\n      }\n\n      function postLink($scope, $element, $attr, tabsCtrl) {\n        if (!tabsCtrl.selectedTab()) {\n          // all the tabs have been added\n          // but one hasn't been selected yet\n          tabsCtrl.select(0);\n        }\n      }\n    }\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/tabs.js\n ** module id = 84\n ** module chunks = 0\n **/","/**\r\n* @ngdoc directive\r\n* @name ionTitle\r\n* @module ionic\r\n* @restrict E\r\n*\r\n* Used for titles in header and nav bars. New in 1.2\r\n*\r\n* Identical to <div class=\"title\"> but with future compatibility for Ionic 2\r\n*\r\n* @usage\r\n*\r\n* ```html\r\n* <ion-nav-bar>\r\n*   <ion-title>Hello</ion-title>\r\n* <ion-nav-bar>\r\n* ```\r\n*/\r\nIonicModule\r\n.directive('ionTitle', [function() {\r\n  return {\r\n    restrict: 'E',\r\n    compile: function(element) {\r\n      element.addClass('title');\r\n    }\r\n  };\r\n}]);\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/title.js\n ** module id = 85\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionToggle\n * @module ionic\n * @codepen tfAzj\n * @restrict E\n *\n * @description\n * A toggle is an animated switch which binds a given model to a boolean.\n *\n * Allows dragging of the switch's nub.\n *\n * The toggle behaves like any [AngularJS checkbox](http://docs.angularjs.org/api/ng/input/input[checkbox]) otherwise.\n *\n * @param toggle-class {string=} Sets the CSS class on the inner `label.toggle` element created by the directive.\n *\n * @usage\n * Below is an example of a toggle directive which is wired up to the `airplaneMode` model\n * and has the `toggle-calm` CSS class assigned to the inner element.\n *\n * ```html\n * <ion-toggle ng-model=\"airplaneMode\" toggle-class=\"toggle-calm\">Airplane Mode</ion-toggle>\n * ```\n */\nIonicModule\n.directive('ionToggle', [\n  '$timeout',\n  '$ionicConfig',\nfunction($timeout, $ionicConfig) {\n\n  return {\n    restrict: 'E',\n    replace: true,\n    require: '?ngModel',\n    transclude: true,\n    template:\n      '<div class=\"item item-toggle\">' +\n        '<div ng-transclude></div>' +\n        '<label class=\"toggle\">' +\n          '<input type=\"checkbox\">' +\n          '<div class=\"track\">' +\n            '<div class=\"handle\"></div>' +\n          '</div>' +\n        '</label>' +\n      '</div>',\n\n    compile: function(element, attr) {\n      var input = element.find('input');\n      forEach({\n        'name': attr.name,\n        'ng-value': attr.ngValue,\n        'ng-model': attr.ngModel,\n        'ng-checked': attr.ngChecked,\n        'ng-disabled': attr.ngDisabled,\n        'ng-true-value': attr.ngTrueValue,\n        'ng-false-value': attr.ngFalseValue,\n        'ng-change': attr.ngChange,\n        'ng-required': attr.ngRequired,\n        'required': attr.required\n      }, function(value, name) {\n        if (isDefined(value)) {\n          input.attr(name, value);\n        }\n      });\n\n      if (attr.toggleClass) {\n        element[0].getElementsByTagName('label')[0].classList.add(attr.toggleClass);\n      }\n\n      element.addClass('toggle-' + $ionicConfig.form.toggle());\n\n      return function($scope, $element) {\n        var el = $element[0].getElementsByTagName('label')[0];\n        var checkbox = el.children[0];\n        var track = el.children[1];\n        var handle = track.children[0];\n\n        var ngModelController = jqLite(checkbox).controller('ngModel');\n\n        $scope.toggle = new ionic.views.Toggle({\n          el: el,\n          track: track,\n          checkbox: checkbox,\n          handle: handle,\n          onChange: function() {\n            if (ngModelController) {\n              ngModelController.$setViewValue(checkbox.checked);\n              $scope.$apply();\n            }\n          }\n        });\n\n        $scope.$on('$destroy', function() {\n          $scope.toggle.destroy();\n        });\n      };\n    }\n\n  };\n}]);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/toggle.js\n ** module id = 86\n ** module chunks = 0\n **/","/**\n * @ngdoc directive\n * @name ionView\n * @module ionic\n * @restrict E\n * @parent ionNavView\n *\n * @description\n * A container for view content and any navigational and header bar information. When a view\n * enters and exits its parent {@link ionic.directive:ionNavView}, the view also emits view\n * information, such as its title, whether the back button should be displayed or not, whether the\n * corresponding {@link ionic.directive:ionNavBar} should be displayed or not, which transition the view\n * should use to animate, and which direction to animate.\n *\n * *Views are cached to improve performance.* When a view is navigated away from, its element is\n * left in the DOM, and its scope is disconnected from the `$watch` cycle. When navigating to a\n * view that is already cached, its scope is reconnected, and the existing element, which was\n * left in the DOM, becomes active again. This can be disabled, or the maximum number of cached\n * views changed in {@link ionic.provider:$ionicConfigProvider}, in the view's `$state` configuration, or\n * as an attribute on the view itself (see below).\n *\n * @usage\n * Below is an example where our page will load with a {@link ionic.directive:ionNavBar} containing\n * \"My Page\" as the title.\n *\n * ```html\n * <ion-nav-bar></ion-nav-bar>\n * <ion-nav-view>\n *   <ion-view view-title=\"My Page\">\n *     <ion-content>\n *       Hello!\n *     </ion-content>\n *   </ion-view>\n * </ion-nav-view>\n * ```\n *\n * ## View LifeCycle and Events\n *\n * Views can be cached, which means ***controllers normally only load once***, which may\n * affect your controller logic. To know when a view has entered or left, events\n * have been added that are emitted from the view's scope. These events also\n * contain data about the view, such as the title and whether the back button should\n * show. Also contained is transition data, such as the transition type and\n * direction that will be or was used.\n *\n * <table class=\"table\">\n *  <tr>\n *   <td><code>$ionicView.loaded</code></td>\n *   <td>The view has loaded. This event only happens once per\n * view being created and added to the DOM. If a view leaves but is cached,\n * then this event will not fire again on a subsequent viewing. The loaded event\n * is good place to put your setup code for the view; however, it is not the\n * recommended event to listen to when a view becomes active.</td>\n *  </tr>\n *  <tr>\n *   <td><code>$ionicView.enter</code></td>\n *   <td>The view has fully entered and is now the active view.\n * This event will fire, whether it was the first load or a cached view.</td>\n *  </tr>\n *  <tr>\n *   <td><code>$ionicView.leave</code></td>\n *   <td>The view has finished leaving and is no longer the\n * active view. This event will fire, whether it is cached or destroyed.</td>\n *  </tr>\n *  <tr>\n *   <td><code>$ionicView.beforeEnter</code></td>\n *   <td>The view is about to enter and become the active view.</td>\n *  </tr>\n *  <tr>\n *   <td><code>$ionicView.beforeLeave</code></td>\n *   <td>The view is about to leave and no longer be the active view.</td>\n *  </tr>\n *  <tr>\n *   <td><code>$ionicView.afterEnter</code></td>\n *   <td>The view has fully entered and is now the active view.</td>\n *  </tr>\n *  <tr>\n *   <td><code>$ionicView.afterLeave</code></td>\n *   <td>The view has finished leaving and is no longer the active view.</td>\n *  </tr>\n *  <tr>\n *   <td><code>$ionicView.unloaded</code></td>\n *   <td>The view's controller has been destroyed and its element has been\n * removed from the DOM.</td>\n *  </tr>\n * </table>\n *\n * ## Caching\n *\n * Caching can be disabled and enabled in multiple ways. By default, Ionic will\n * cache a maximum of 10 views. You can optionally choose to disable caching at\n * either an individual view basis, or by global configuration. Please see the\n * _Caching_ section in {@link ionic.directive:ionNavView} for more info.\n *\n * @param {string=} view-title A text-only title to display on the parent {@link ionic.directive:ionNavBar}.\n * For an HTML title, such as an image, see {@link ionic.directive:ionNavTitle} instead.\n * @param {boolean=} cache-view If this view should be allowed to be cached or not.\n * Please see the _Caching_ section in {@link ionic.directive:ionNavView} for\n * more info. Default `true`\n * @param {boolean=} can-swipe-back If this view should be allowed to use the swipe to go back gesture or not.\n * This does not enable the swipe to go back feature if it is not available for the platform it's running\n * from, or there isn't a previous view. Default `true`\n * @param {boolean=} hide-back-button Whether to hide the back button on the parent\n * {@link ionic.directive:ionNavBar} by default.\n * @param {boolean=} hide-nav-bar Whether to hide the parent\n * {@link ionic.directive:ionNavBar} by default.\n */\nIonicModule\n.directive('ionView', function() {\n  return {\n    restrict: 'EA',\n    priority: 1000,\n    controller: '$ionicView',\n    compile: function(tElement) {\n      tElement.addClass('pane');\n      tElement[0].removeAttribute('title');\n      return function link($scope, $element, $attrs, viewCtrl) {\n        viewCtrl.init();\n      };\n    }\n  };\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ionic-sdk/js/angular/directive/view.js\n ** module id = 87\n ** module chunks = 0\n **/"],"sourceRoot":""}